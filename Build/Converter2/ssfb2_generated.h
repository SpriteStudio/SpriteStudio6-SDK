// automatically generated by the FlatBuffers compiler, do not modify


#ifndef FLATBUFFERS_GENERATED_SSFB2_SS_SSFB2_H_
#define FLATBUFFERS_GENERATED_SSFB2_SS_SSFB2_H_

#include "flatbuffers/flatbuffers.h"

namespace ss {
namespace ssfb2 {

struct Vector2;

struct Vector3;

struct Rect;

struct DataMesh;

struct Cell;

struct LibraryDataCellMap;

struct DataCellMap;

struct Bone;

struct Vertex;

struct BindMesh;

struct Color32;

struct Color;

struct ColorLabel;

struct Catalog;

struct DataModelParts;

struct Label;

struct RangeFloat;

struct RangeVector2;

struct RangeColor;

struct PatternEmit;

struct AnimationAttributeCell;

struct AnimationAttributePartsColor;

struct CodeValueContainer;

struct ContainerStatus;

struct ContainerCell;

struct ContainerVector3;

struct ContainerVector2;

struct ContainerFloat;

struct ContainerInt;

struct ContainerPartsColor;

struct VertexCorrection;

struct ContainerVertexCorrection;

struct ContainerUserData;

struct AnimationAttributeInstance;

struct ContainerInstance;

struct AnimationAttributeEffect;

struct ContainerEffect;

struct AnimationAttributeDeform;

struct ContainerDeform;

struct DataAnimationParts;

struct LibraryDataAnimation;

struct UserData;

struct DataSetup;

struct DataAnimation;

struct DataEffectParts;

struct DataEffectEmitter;

struct DataEffect;

struct ProjectData;

enum DataModelPartsKindFeature {
  DataModelPartsKindFeature_Root = 0,
  DataModelPartsKindFeature_Null = 1,
  DataModelPartsKindFeature_Normal = 2,
  DataModelPartsKindFeature_Instance = 3,
  DataModelPartsKindFeature_Effect = 4,
  DataModelPartsKindFeature_Mask = 5,
  DataModelPartsKindFeature_Joint = 6,
  DataModelPartsKindFeature_Bone = 7,
  DataModelPartsKindFeature_MoveNode = 8,
  DataModelPartsKindFeature_Constraint = 9,
  DataModelPartsKindFeature_BonePoint = 10,
  DataModelPartsKindFeature_Mesh = 11,
  DataModelPartsKindFeature_Terminator = 12,
  DataModelPartsKindFeature_MIN = DataModelPartsKindFeature_Root,
  DataModelPartsKindFeature_MAX = DataModelPartsKindFeature_Terminator
};

inline const DataModelPartsKindFeature (&EnumValuesDataModelPartsKindFeature())[13] {
  static const DataModelPartsKindFeature values[] = {
    DataModelPartsKindFeature_Root,
    DataModelPartsKindFeature_Null,
    DataModelPartsKindFeature_Normal,
    DataModelPartsKindFeature_Instance,
    DataModelPartsKindFeature_Effect,
    DataModelPartsKindFeature_Mask,
    DataModelPartsKindFeature_Joint,
    DataModelPartsKindFeature_Bone,
    DataModelPartsKindFeature_MoveNode,
    DataModelPartsKindFeature_Constraint,
    DataModelPartsKindFeature_BonePoint,
    DataModelPartsKindFeature_Mesh,
    DataModelPartsKindFeature_Terminator
  };
  return values;
}

inline const char * const *EnumNamesDataModelPartsKindFeature() {
  static const char * const names[] = {
    "Root",
    "Null",
    "Normal",
    "Instance",
    "Effect",
    "Mask",
    "Joint",
    "Bone",
    "MoveNode",
    "Constraint",
    "BonePoint",
    "Mesh",
    "Terminator",
    nullptr
  };
  return names;
}

inline const char *EnumNameDataModelPartsKindFeature(DataModelPartsKindFeature e) {
  if (e < DataModelPartsKindFeature_Root || e > DataModelPartsKindFeature_Terminator) return "";
  const size_t index = static_cast<size_t>(e);
  return EnumNamesDataModelPartsKindFeature()[index];
}

enum KindCollision {
  KindCollision_Non = 0,
  KindCollision_Square = 1,
  KindCollision_Aabb = 2,
  KindCollision_Circle = 3,
  KindCollision_CircleScaleMinimum = 4,
  KindCollision_CircleScaleMaximum = 5,
  KindCollision_MIN = KindCollision_Non,
  KindCollision_MAX = KindCollision_CircleScaleMaximum
};

inline const KindCollision (&EnumValuesKindCollision())[6] {
  static const KindCollision values[] = {
    KindCollision_Non,
    KindCollision_Square,
    KindCollision_Aabb,
    KindCollision_Circle,
    KindCollision_CircleScaleMinimum,
    KindCollision_CircleScaleMaximum
  };
  return values;
}

inline const char * const *EnumNamesKindCollision() {
  static const char * const names[] = {
    "Non",
    "Square",
    "Aabb",
    "Circle",
    "CircleScaleMinimum",
    "CircleScaleMaximum",
    nullptr
  };
  return names;
}

inline const char *EnumNameKindCollision(KindCollision e) {
  if (e < KindCollision_Non || e > KindCollision_CircleScaleMaximum) return "";
  const size_t index = static_cast<size_t>(e);
  return EnumNamesKindCollision()[index];
}

enum ColorLabelKindForm {
  ColorLabelKindForm_Non = 0,
  ColorLabelKindForm_Red = 1,
  ColorLabelKindForm_Orange = 2,
  ColorLabelKindForm_Yellow = 3,
  ColorLabelKindForm_Green = 4,
  ColorLabelKindForm_Blue = 5,
  ColorLabelKindForm_Violet = 6,
  ColorLabelKindForm_Gray = 7,
  ColorLabelKindForm_Terminator = 8,
  ColorLabelKindForm_MIN = ColorLabelKindForm_Non,
  ColorLabelKindForm_MAX = ColorLabelKindForm_Terminator
};

inline const ColorLabelKindForm (&EnumValuesColorLabelKindForm())[9] {
  static const ColorLabelKindForm values[] = {
    ColorLabelKindForm_Non,
    ColorLabelKindForm_Red,
    ColorLabelKindForm_Orange,
    ColorLabelKindForm_Yellow,
    ColorLabelKindForm_Green,
    ColorLabelKindForm_Blue,
    ColorLabelKindForm_Violet,
    ColorLabelKindForm_Gray,
    ColorLabelKindForm_Terminator
  };
  return values;
}

inline const char * const *EnumNamesColorLabelKindForm() {
  static const char * const names[] = {
    "Non",
    "Red",
    "Orange",
    "Yellow",
    "Green",
    "Blue",
    "Violet",
    "Gray",
    "Terminator",
    nullptr
  };
  return names;
}

inline const char *EnumNameColorLabelKindForm(ColorLabelKindForm e) {
  if (e < ColorLabelKindForm_Non || e > ColorLabelKindForm_Terminator) return "";
  const size_t index = static_cast<size_t>(e);
  return EnumNamesColorLabelKindForm()[index];
}

enum KindOperationBlend {
  KindOperationBlend_MaskPre = -2,
  KindOperationBlend_Mask = -1,
  KindOperationBlend_Mix = 0,
  KindOperationBlend_Add = 1,
  KindOperationBlend_Sub = 2,
  KindOperationBlend_Mul = 3,
  KindOperationBlend_MulNa = 4,
  KindOperationBlend_Scr = 5,
  KindOperationBlend_Exc = 6,
  KindOperationBlend_Inv = 7,
  KindOperationBlend_Terminator = 8,
  KindOperationBlend_MIN = KindOperationBlend_MaskPre,
  KindOperationBlend_MAX = KindOperationBlend_Terminator
};

inline const KindOperationBlend (&EnumValuesKindOperationBlend())[11] {
  static const KindOperationBlend values[] = {
    KindOperationBlend_MaskPre,
    KindOperationBlend_Mask,
    KindOperationBlend_Mix,
    KindOperationBlend_Add,
    KindOperationBlend_Sub,
    KindOperationBlend_Mul,
    KindOperationBlend_MulNa,
    KindOperationBlend_Scr,
    KindOperationBlend_Exc,
    KindOperationBlend_Inv,
    KindOperationBlend_Terminator
  };
  return values;
}

inline const char * const *EnumNamesKindOperationBlend() {
  static const char * const names[] = {
    "MaskPre",
    "Mask",
    "Mix",
    "Add",
    "Sub",
    "Mul",
    "MulNa",
    "Scr",
    "Exc",
    "Inv",
    "Terminator",
    nullptr
  };
  return names;
}

inline const char *EnumNameKindOperationBlend(KindOperationBlend e) {
  if (e < KindOperationBlend_MaskPre || e > KindOperationBlend_Terminator) return "";
  const size_t index = static_cast<size_t>(e) - static_cast<size_t>(KindOperationBlend_MaskPre);
  return EnumNamesKindOperationBlend()[index];
}

enum KindModeSort {
  KindModeSort_Priority = 0,
  KindModeSort_PositionZ = 1,
  KindModeSort_MIN = KindModeSort_Priority,
  KindModeSort_MAX = KindModeSort_PositionZ
};

inline const KindModeSort (&EnumValuesKindModeSort())[2] {
  static const KindModeSort values[] = {
    KindModeSort_Priority,
    KindModeSort_PositionZ
  };
  return values;
}

inline const char * const *EnumNamesKindModeSort() {
  static const char * const names[] = {
    "Priority",
    "PositionZ",
    nullptr
  };
  return names;
}

inline const char *EnumNameKindModeSort(KindModeSort e) {
  if (e < KindModeSort_Priority || e > KindModeSort_PositionZ) return "";
  const size_t index = static_cast<size_t>(e);
  return EnumNamesKindModeSort()[index];
}

enum DataAnimationPartsFlagBitStatus {
  DataAnimationPartsFlagBitStatus_Clear = 0,
  DataAnimationPartsFlagBitStatus_NoEffect = 65536,
  DataAnimationPartsFlagBitStatus_NoInstance = 131072,
  DataAnimationPartsFlagBitStatus_NoPartsColor = 262144,
  DataAnimationPartsFlagBitStatus_NoUserData = 524288,
  DataAnimationPartsFlagBitStatus_NoTransformationTexture = 1048576,
  DataAnimationPartsFlagBitStatus_NoScaling = 2097152,
  DataAnimationPartsFlagBitStatus_NoRotation = 4194304,
  DataAnimationPartsFlagBitStatus_NoPosition = 8388608,
  DataAnimationPartsFlagBitStatus_NotMasking = 134217728,
  DataAnimationPartsFlagBitStatus_HideFull = 268435456,
  DataAnimationPartsFlagBitStatus_NotUsed = 536870912,
  DataAnimationPartsFlagBitStatus_Valid = 1073741824,
  DataAnimationPartsFlagBitStatus_MIN = DataAnimationPartsFlagBitStatus_Clear,
  DataAnimationPartsFlagBitStatus_MAX = DataAnimationPartsFlagBitStatus_Valid
};

inline const DataAnimationPartsFlagBitStatus (&EnumValuesDataAnimationPartsFlagBitStatus())[13] {
  static const DataAnimationPartsFlagBitStatus values[] = {
    DataAnimationPartsFlagBitStatus_Clear,
    DataAnimationPartsFlagBitStatus_NoEffect,
    DataAnimationPartsFlagBitStatus_NoInstance,
    DataAnimationPartsFlagBitStatus_NoPartsColor,
    DataAnimationPartsFlagBitStatus_NoUserData,
    DataAnimationPartsFlagBitStatus_NoTransformationTexture,
    DataAnimationPartsFlagBitStatus_NoScaling,
    DataAnimationPartsFlagBitStatus_NoRotation,
    DataAnimationPartsFlagBitStatus_NoPosition,
    DataAnimationPartsFlagBitStatus_NotMasking,
    DataAnimationPartsFlagBitStatus_HideFull,
    DataAnimationPartsFlagBitStatus_NotUsed,
    DataAnimationPartsFlagBitStatus_Valid
  };
  return values;
}

inline const char *EnumNameDataAnimationPartsFlagBitStatus(DataAnimationPartsFlagBitStatus e) {
  switch (e) {
    case DataAnimationPartsFlagBitStatus_Clear: return "Clear";
    case DataAnimationPartsFlagBitStatus_NoEffect: return "NoEffect";
    case DataAnimationPartsFlagBitStatus_NoInstance: return "NoInstance";
    case DataAnimationPartsFlagBitStatus_NoPartsColor: return "NoPartsColor";
    case DataAnimationPartsFlagBitStatus_NoUserData: return "NoUserData";
    case DataAnimationPartsFlagBitStatus_NoTransformationTexture: return "NoTransformationTexture";
    case DataAnimationPartsFlagBitStatus_NoScaling: return "NoScaling";
    case DataAnimationPartsFlagBitStatus_NoRotation: return "NoRotation";
    case DataAnimationPartsFlagBitStatus_NoPosition: return "NoPosition";
    case DataAnimationPartsFlagBitStatus_NotMasking: return "NotMasking";
    case DataAnimationPartsFlagBitStatus_HideFull: return "HideFull";
    case DataAnimationPartsFlagBitStatus_NotUsed: return "NotUsed";
    case DataAnimationPartsFlagBitStatus_Valid: return "Valid";
    default: return "";
  }
}

enum KindOperationBlendEffect {
  KindOperationBlendEffect_Non = -1,
  KindOperationBlendEffect_Mix = 0,
  KindOperationBlendEffect_Add = 1,
  KindOperationBlendEffect_Terminator = 2,
  KindOperationBlendEffect_MIN = KindOperationBlendEffect_Non,
  KindOperationBlendEffect_MAX = KindOperationBlendEffect_Terminator
};

inline const KindOperationBlendEffect (&EnumValuesKindOperationBlendEffect())[4] {
  static const KindOperationBlendEffect values[] = {
    KindOperationBlendEffect_Non,
    KindOperationBlendEffect_Mix,
    KindOperationBlendEffect_Add,
    KindOperationBlendEffect_Terminator
  };
  return values;
}

inline const char * const *EnumNamesKindOperationBlendEffect() {
  static const char * const names[] = {
    "Non",
    "Mix",
    "Add",
    "Terminator",
    nullptr
  };
  return names;
}

inline const char *EnumNameKindOperationBlendEffect(KindOperationBlendEffect e) {
  if (e < KindOperationBlendEffect_Non || e > KindOperationBlendEffect_Terminator) return "";
  const size_t index = static_cast<size_t>(e) - static_cast<size_t>(KindOperationBlendEffect_Non);
  return EnumNamesKindOperationBlendEffect()[index];
}

enum KindTypePack {
  KindTypePack_STANDARD_UNCOMPRESSED = 0,
  KindTypePack_STANDARD_CPE = 1,
  KindTypePack_CPE_FLYWEIGHT = 2,
  KindTypePack_CPE_INTERPOLATE = 3,
  KindTypePack_TERMINATOR = 4,
  KindTypePack_MIN = KindTypePack_STANDARD_UNCOMPRESSED,
  KindTypePack_MAX = KindTypePack_TERMINATOR
};

inline const KindTypePack (&EnumValuesKindTypePack())[5] {
  static const KindTypePack values[] = {
    KindTypePack_STANDARD_UNCOMPRESSED,
    KindTypePack_STANDARD_CPE,
    KindTypePack_CPE_FLYWEIGHT,
    KindTypePack_CPE_INTERPOLATE,
    KindTypePack_TERMINATOR
  };
  return values;
}

inline const char * const *EnumNamesKindTypePack() {
  static const char * const names[] = {
    "STANDARD_UNCOMPRESSED",
    "STANDARD_CPE",
    "CPE_FLYWEIGHT",
    "CPE_INTERPOLATE",
    "TERMINATOR",
    nullptr
  };
  return names;
}

inline const char *EnumNameKindTypePack(KindTypePack e) {
  if (e < KindTypePack_STANDARD_UNCOMPRESSED || e > KindTypePack_TERMINATOR) return "";
  const size_t index = static_cast<size_t>(e);
  return EnumNamesKindTypePack()[index];
}

enum UserDataFlagBit {
  UserDataFlagBit_CLEAR = 0,
  UserDataFlagBit_NUMBER = 1,
  UserDataFlagBit_RECTANGLE = 2,
  UserDataFlagBit_COORDINATE = 4,
  UserDataFlagBit_TEXT = 8,
  UserDataFlagBit_VALID = 1073741824,
  UserDataFlagBit_MIN = UserDataFlagBit_CLEAR,
  UserDataFlagBit_MAX = UserDataFlagBit_VALID
};

inline const UserDataFlagBit (&EnumValuesUserDataFlagBit())[6] {
  static const UserDataFlagBit values[] = {
    UserDataFlagBit_CLEAR,
    UserDataFlagBit_NUMBER,
    UserDataFlagBit_RECTANGLE,
    UserDataFlagBit_COORDINATE,
    UserDataFlagBit_TEXT,
    UserDataFlagBit_VALID
  };
  return values;
}

inline const char *EnumNameUserDataFlagBit(UserDataFlagBit e) {
  switch (e) {
    case UserDataFlagBit_CLEAR: return "CLEAR";
    case UserDataFlagBit_NUMBER: return "NUMBER";
    case UserDataFlagBit_RECTANGLE: return "RECTANGLE";
    case UserDataFlagBit_COORDINATE: return "COORDINATE";
    case UserDataFlagBit_TEXT: return "TEXT";
    case UserDataFlagBit_VALID: return "VALID";
    default: return "";
  }
}

enum DataEffectFlagBit {
  DataEffectFlagBit_Clear = 0,
  DataEffectFlagBit_SeedRandomLock = 1,
  DataEffectFlagBit_MIN = DataEffectFlagBit_Clear,
  DataEffectFlagBit_MAX = DataEffectFlagBit_SeedRandomLock
};

inline const DataEffectFlagBit (&EnumValuesDataEffectFlagBit())[2] {
  static const DataEffectFlagBit values[] = {
    DataEffectFlagBit_Clear,
    DataEffectFlagBit_SeedRandomLock
  };
  return values;
}

inline const char * const *EnumNamesDataEffectFlagBit() {
  static const char * const names[] = {
    "Clear",
    "SeedRandomLock",
    nullptr
  };
  return names;
}

inline const char *EnumNameDataEffectFlagBit(DataEffectFlagBit e) {
  if (e < DataEffectFlagBit_Clear || e > DataEffectFlagBit_SeedRandomLock) return "";
  const size_t index = static_cast<size_t>(e);
  return EnumNamesDataEffectFlagBit()[index];
}

enum DataEffectPartsKindFeature {
  DataEffectPartsKindFeature_Root = 0,
  DataEffectPartsKindFeature_Emitter = 1,
  DataEffectPartsKindFeature_Particle = 2,
  DataEffectPartsKindFeature_Terminator = 3,
  DataEffectPartsKindFeature_MIN = DataEffectPartsKindFeature_Root,
  DataEffectPartsKindFeature_MAX = DataEffectPartsKindFeature_Terminator
};

inline const DataEffectPartsKindFeature (&EnumValuesDataEffectPartsKindFeature())[4] {
  static const DataEffectPartsKindFeature values[] = {
    DataEffectPartsKindFeature_Root,
    DataEffectPartsKindFeature_Emitter,
    DataEffectPartsKindFeature_Particle,
    DataEffectPartsKindFeature_Terminator
  };
  return values;
}

inline const char * const *EnumNamesDataEffectPartsKindFeature() {
  static const char * const names[] = {
    "Root",
    "Emitter",
    "Particle",
    "Terminator",
    nullptr
  };
  return names;
}

inline const char *EnumNameDataEffectPartsKindFeature(DataEffectPartsKindFeature e) {
  if (e < DataEffectPartsKindFeature_Root || e > DataEffectPartsKindFeature_Terminator) return "";
  const size_t index = static_cast<size_t>(e);
  return EnumNamesDataEffectPartsKindFeature()[index];
}

enum DataEffectEmitterFlagBit {
  DataEffectEmitterFlagBit_Clear = 0,
  DataEffectEmitterFlagBit_Basic = 1,
  DataEffectEmitterFlagBit_TangentialAccelation = 2,
  DataEffectEmitterFlagBit_TurnDirection = 4,
  DataEffectEmitterFlagBit_SeedRandom = 8,
  DataEffectEmitterFlagBit_Delay = 16,
  DataEffectEmitterFlagBit_Position = 256,
  DataEffectEmitterFlagBit_PositionFluctuation = 512,
  DataEffectEmitterFlagBit_Rotation = 1024,
  DataEffectEmitterFlagBit_RotationFluctuation = 2048,
  DataEffectEmitterFlagBit_ScaleStart = 4096,
  DataEffectEmitterFlagBit_ScaleEnd = 8192,
  DataEffectEmitterFlagBit_Speed = 65536,
  DataEffectEmitterFlagBit_SpeedFluctuation = 131072,
  DataEffectEmitterFlagBit_GravityDirection = 262144,
  DataEffectEmitterFlagBit_GravityPoint = 524288,
  DataEffectEmitterFlagBit_ColorVertex = 1048576,
  DataEffectEmitterFlagBit_ColorVertexFluctuation = 2097152,
  DataEffectEmitterFlagBit_FadeAlpha = 4194304,
  DataEffectEmitterFlagBit_MaskParticle = 16777215,
  DataEffectEmitterFlagBit_EmitInfinite = 16777216,
  DataEffectEmitterFlagBit_MaskEmitter = 2130706432,
  DataEffectEmitterFlagBit_MaskValid = 2147483647,
  DataEffectEmitterFlagBit_MIN = DataEffectEmitterFlagBit_Clear,
  DataEffectEmitterFlagBit_MAX = DataEffectEmitterFlagBit_MaskValid
};

inline const DataEffectEmitterFlagBit (&EnumValuesDataEffectEmitterFlagBit())[23] {
  static const DataEffectEmitterFlagBit values[] = {
    DataEffectEmitterFlagBit_Clear,
    DataEffectEmitterFlagBit_Basic,
    DataEffectEmitterFlagBit_TangentialAccelation,
    DataEffectEmitterFlagBit_TurnDirection,
    DataEffectEmitterFlagBit_SeedRandom,
    DataEffectEmitterFlagBit_Delay,
    DataEffectEmitterFlagBit_Position,
    DataEffectEmitterFlagBit_PositionFluctuation,
    DataEffectEmitterFlagBit_Rotation,
    DataEffectEmitterFlagBit_RotationFluctuation,
    DataEffectEmitterFlagBit_ScaleStart,
    DataEffectEmitterFlagBit_ScaleEnd,
    DataEffectEmitterFlagBit_Speed,
    DataEffectEmitterFlagBit_SpeedFluctuation,
    DataEffectEmitterFlagBit_GravityDirection,
    DataEffectEmitterFlagBit_GravityPoint,
    DataEffectEmitterFlagBit_ColorVertex,
    DataEffectEmitterFlagBit_ColorVertexFluctuation,
    DataEffectEmitterFlagBit_FadeAlpha,
    DataEffectEmitterFlagBit_MaskParticle,
    DataEffectEmitterFlagBit_EmitInfinite,
    DataEffectEmitterFlagBit_MaskEmitter,
    DataEffectEmitterFlagBit_MaskValid
  };
  return values;
}

inline const char *EnumNameDataEffectEmitterFlagBit(DataEffectEmitterFlagBit e) {
  switch (e) {
    case DataEffectEmitterFlagBit_Clear: return "Clear";
    case DataEffectEmitterFlagBit_Basic: return "Basic";
    case DataEffectEmitterFlagBit_TangentialAccelation: return "TangentialAccelation";
    case DataEffectEmitterFlagBit_TurnDirection: return "TurnDirection";
    case DataEffectEmitterFlagBit_SeedRandom: return "SeedRandom";
    case DataEffectEmitterFlagBit_Delay: return "Delay";
    case DataEffectEmitterFlagBit_Position: return "Position";
    case DataEffectEmitterFlagBit_PositionFluctuation: return "PositionFluctuation";
    case DataEffectEmitterFlagBit_Rotation: return "Rotation";
    case DataEffectEmitterFlagBit_RotationFluctuation: return "RotationFluctuation";
    case DataEffectEmitterFlagBit_ScaleStart: return "ScaleStart";
    case DataEffectEmitterFlagBit_ScaleEnd: return "ScaleEnd";
    case DataEffectEmitterFlagBit_Speed: return "Speed";
    case DataEffectEmitterFlagBit_SpeedFluctuation: return "SpeedFluctuation";
    case DataEffectEmitterFlagBit_GravityDirection: return "GravityDirection";
    case DataEffectEmitterFlagBit_GravityPoint: return "GravityPoint";
    case DataEffectEmitterFlagBit_ColorVertex: return "ColorVertex";
    case DataEffectEmitterFlagBit_ColorVertexFluctuation: return "ColorVertexFluctuation";
    case DataEffectEmitterFlagBit_FadeAlpha: return "FadeAlpha";
    case DataEffectEmitterFlagBit_MaskParticle: return "MaskParticle";
    case DataEffectEmitterFlagBit_EmitInfinite: return "EmitInfinite";
    case DataEffectEmitterFlagBit_MaskEmitter: return "MaskEmitter";
    case DataEffectEmitterFlagBit_MaskValid: return "MaskValid";
    default: return "";
  }
}

struct Vector2 FLATBUFFERS_FINAL_CLASS : private flatbuffers::Table {
  enum FlatBuffersVTableOffset FLATBUFFERS_VTABLE_UNDERLYING_TYPE {
    VT_X = 4,
    VT_Y = 6
  };
  float x() const {
    return GetField<float>(VT_X, 0.0f);
  }
  float y() const {
    return GetField<float>(VT_Y, 0.0f);
  }
  bool Verify(flatbuffers::Verifier &verifier) const {
    return VerifyTableStart(verifier) &&
           VerifyField<float>(verifier, VT_X) &&
           VerifyField<float>(verifier, VT_Y) &&
           verifier.EndTable();
  }
};

struct Vector2Builder {
  flatbuffers::FlatBufferBuilder &fbb_;
  flatbuffers::uoffset_t start_;
  void add_x(float x) {
    fbb_.AddElement<float>(Vector2::VT_X, x, 0.0f);
  }
  void add_y(float y) {
    fbb_.AddElement<float>(Vector2::VT_Y, y, 0.0f);
  }
  explicit Vector2Builder(flatbuffers::FlatBufferBuilder &_fbb)
        : fbb_(_fbb) {
    start_ = fbb_.StartTable();
  }
  Vector2Builder &operator=(const Vector2Builder &);
  flatbuffers::Offset<Vector2> Finish() {
    const auto end = fbb_.EndTable(start_);
    auto o = flatbuffers::Offset<Vector2>(end);
    return o;
  }
};

inline flatbuffers::Offset<Vector2> CreateVector2(
    flatbuffers::FlatBufferBuilder &_fbb,
    float x = 0.0f,
    float y = 0.0f) {
  Vector2Builder builder_(_fbb);
  builder_.add_y(y);
  builder_.add_x(x);
  return builder_.Finish();
}

struct Vector3 FLATBUFFERS_FINAL_CLASS : private flatbuffers::Table {
  enum FlatBuffersVTableOffset FLATBUFFERS_VTABLE_UNDERLYING_TYPE {
    VT_X = 4,
    VT_Y = 6,
    VT_Z = 8
  };
  float x() const {
    return GetField<float>(VT_X, 0.0f);
  }
  float y() const {
    return GetField<float>(VT_Y, 0.0f);
  }
  float z() const {
    return GetField<float>(VT_Z, 0.0f);
  }
  bool Verify(flatbuffers::Verifier &verifier) const {
    return VerifyTableStart(verifier) &&
           VerifyField<float>(verifier, VT_X) &&
           VerifyField<float>(verifier, VT_Y) &&
           VerifyField<float>(verifier, VT_Z) &&
           verifier.EndTable();
  }
};

struct Vector3Builder {
  flatbuffers::FlatBufferBuilder &fbb_;
  flatbuffers::uoffset_t start_;
  void add_x(float x) {
    fbb_.AddElement<float>(Vector3::VT_X, x, 0.0f);
  }
  void add_y(float y) {
    fbb_.AddElement<float>(Vector3::VT_Y, y, 0.0f);
  }
  void add_z(float z) {
    fbb_.AddElement<float>(Vector3::VT_Z, z, 0.0f);
  }
  explicit Vector3Builder(flatbuffers::FlatBufferBuilder &_fbb)
        : fbb_(_fbb) {
    start_ = fbb_.StartTable();
  }
  Vector3Builder &operator=(const Vector3Builder &);
  flatbuffers::Offset<Vector3> Finish() {
    const auto end = fbb_.EndTable(start_);
    auto o = flatbuffers::Offset<Vector3>(end);
    return o;
  }
};

inline flatbuffers::Offset<Vector3> CreateVector3(
    flatbuffers::FlatBufferBuilder &_fbb,
    float x = 0.0f,
    float y = 0.0f,
    float z = 0.0f) {
  Vector3Builder builder_(_fbb);
  builder_.add_z(z);
  builder_.add_y(y);
  builder_.add_x(x);
  return builder_.Finish();
}

struct Rect FLATBUFFERS_FINAL_CLASS : private flatbuffers::Table {
  enum FlatBuffersVTableOffset FLATBUFFERS_VTABLE_UNDERLYING_TYPE {
    VT_X_MIN = 4,
    VT_Y_MIN = 6,
    VT_X_MAX = 8,
    VT_Y_MAX = 10
  };
  float x_min() const {
    return GetField<float>(VT_X_MIN, 0.0f);
  }
  float y_min() const {
    return GetField<float>(VT_Y_MIN, 0.0f);
  }
  float x_max() const {
    return GetField<float>(VT_X_MAX, 0.0f);
  }
  float y_max() const {
    return GetField<float>(VT_Y_MAX, 0.0f);
  }
  bool Verify(flatbuffers::Verifier &verifier) const {
    return VerifyTableStart(verifier) &&
           VerifyField<float>(verifier, VT_X_MIN) &&
           VerifyField<float>(verifier, VT_Y_MIN) &&
           VerifyField<float>(verifier, VT_X_MAX) &&
           VerifyField<float>(verifier, VT_Y_MAX) &&
           verifier.EndTable();
  }
};

struct RectBuilder {
  flatbuffers::FlatBufferBuilder &fbb_;
  flatbuffers::uoffset_t start_;
  void add_x_min(float x_min) {
    fbb_.AddElement<float>(Rect::VT_X_MIN, x_min, 0.0f);
  }
  void add_y_min(float y_min) {
    fbb_.AddElement<float>(Rect::VT_Y_MIN, y_min, 0.0f);
  }
  void add_x_max(float x_max) {
    fbb_.AddElement<float>(Rect::VT_X_MAX, x_max, 0.0f);
  }
  void add_y_max(float y_max) {
    fbb_.AddElement<float>(Rect::VT_Y_MAX, y_max, 0.0f);
  }
  explicit RectBuilder(flatbuffers::FlatBufferBuilder &_fbb)
        : fbb_(_fbb) {
    start_ = fbb_.StartTable();
  }
  RectBuilder &operator=(const RectBuilder &);
  flatbuffers::Offset<Rect> Finish() {
    const auto end = fbb_.EndTable(start_);
    auto o = flatbuffers::Offset<Rect>(end);
    return o;
  }
};

inline flatbuffers::Offset<Rect> CreateRect(
    flatbuffers::FlatBufferBuilder &_fbb,
    float x_min = 0.0f,
    float y_min = 0.0f,
    float x_max = 0.0f,
    float y_max = 0.0f) {
  RectBuilder builder_(_fbb);
  builder_.add_y_max(y_max);
  builder_.add_x_max(x_max);
  builder_.add_y_min(y_min);
  builder_.add_x_min(x_min);
  return builder_.Finish();
}

struct DataMesh FLATBUFFERS_FINAL_CLASS : private flatbuffers::Table {
  enum FlatBuffersVTableOffset FLATBUFFERS_VTABLE_UNDERLYING_TYPE {
    VT_TABLE_COORDINATE = 4,
    VT_TABLE_INDEX_VERTEX = 6
  };
  const flatbuffers::Vector<flatbuffers::Offset<Vector2>> *table_coordinate() const {
    return GetPointer<const flatbuffers::Vector<flatbuffers::Offset<Vector2>> *>(VT_TABLE_COORDINATE);
  }
  const flatbuffers::Vector<uint16_t> *table_index_vertex() const {
    return GetPointer<const flatbuffers::Vector<uint16_t> *>(VT_TABLE_INDEX_VERTEX);
  }
  bool Verify(flatbuffers::Verifier &verifier) const {
    return VerifyTableStart(verifier) &&
           VerifyOffset(verifier, VT_TABLE_COORDINATE) &&
           verifier.VerifyVector(table_coordinate()) &&
           verifier.VerifyVectorOfTables(table_coordinate()) &&
           VerifyOffset(verifier, VT_TABLE_INDEX_VERTEX) &&
           verifier.VerifyVector(table_index_vertex()) &&
           verifier.EndTable();
  }
};

struct DataMeshBuilder {
  flatbuffers::FlatBufferBuilder &fbb_;
  flatbuffers::uoffset_t start_;
  void add_table_coordinate(flatbuffers::Offset<flatbuffers::Vector<flatbuffers::Offset<Vector2>>> table_coordinate) {
    fbb_.AddOffset(DataMesh::VT_TABLE_COORDINATE, table_coordinate);
  }
  void add_table_index_vertex(flatbuffers::Offset<flatbuffers::Vector<uint16_t>> table_index_vertex) {
    fbb_.AddOffset(DataMesh::VT_TABLE_INDEX_VERTEX, table_index_vertex);
  }
  explicit DataMeshBuilder(flatbuffers::FlatBufferBuilder &_fbb)
        : fbb_(_fbb) {
    start_ = fbb_.StartTable();
  }
  DataMeshBuilder &operator=(const DataMeshBuilder &);
  flatbuffers::Offset<DataMesh> Finish() {
    const auto end = fbb_.EndTable(start_);
    auto o = flatbuffers::Offset<DataMesh>(end);
    return o;
  }
};

inline flatbuffers::Offset<DataMesh> CreateDataMesh(
    flatbuffers::FlatBufferBuilder &_fbb,
    flatbuffers::Offset<flatbuffers::Vector<flatbuffers::Offset<Vector2>>> table_coordinate = 0,
    flatbuffers::Offset<flatbuffers::Vector<uint16_t>> table_index_vertex = 0) {
  DataMeshBuilder builder_(_fbb);
  builder_.add_table_index_vertex(table_index_vertex);
  builder_.add_table_coordinate(table_coordinate);
  return builder_.Finish();
}

inline flatbuffers::Offset<DataMesh> CreateDataMeshDirect(
    flatbuffers::FlatBufferBuilder &_fbb,
    const std::vector<flatbuffers::Offset<Vector2>> *table_coordinate = nullptr,
    const std::vector<uint16_t> *table_index_vertex = nullptr) {
  auto table_coordinate__ = table_coordinate ? _fbb.CreateVector<flatbuffers::Offset<Vector2>>(*table_coordinate) : 0;
  auto table_index_vertex__ = table_index_vertex ? _fbb.CreateVector<uint16_t>(*table_index_vertex) : 0;
  return ss::ssfb2::CreateDataMesh(
      _fbb,
      table_coordinate__,
      table_index_vertex__);
}

struct Cell FLATBUFFERS_FINAL_CLASS : private flatbuffers::Table {
  enum FlatBuffersVTableOffset FLATBUFFERS_VTABLE_UNDERLYING_TYPE {
    VT_NAME = 4,
    VT_RECTANGLE = 6,
    VT_PIVOT = 8,
    VT_MESH = 10
  };
  const flatbuffers::String *name() const {
    return GetPointer<const flatbuffers::String *>(VT_NAME);
  }
  const Rect *rectangle() const {
    return GetPointer<const Rect *>(VT_RECTANGLE);
  }
  const Vector2 *pivot() const {
    return GetPointer<const Vector2 *>(VT_PIVOT);
  }
  const DataMesh *mesh() const {
    return GetPointer<const DataMesh *>(VT_MESH);
  }
  bool Verify(flatbuffers::Verifier &verifier) const {
    return VerifyTableStart(verifier) &&
           VerifyOffset(verifier, VT_NAME) &&
           verifier.VerifyString(name()) &&
           VerifyOffset(verifier, VT_RECTANGLE) &&
           verifier.VerifyTable(rectangle()) &&
           VerifyOffset(verifier, VT_PIVOT) &&
           verifier.VerifyTable(pivot()) &&
           VerifyOffset(verifier, VT_MESH) &&
           verifier.VerifyTable(mesh()) &&
           verifier.EndTable();
  }
};

struct CellBuilder {
  flatbuffers::FlatBufferBuilder &fbb_;
  flatbuffers::uoffset_t start_;
  void add_name(flatbuffers::Offset<flatbuffers::String> name) {
    fbb_.AddOffset(Cell::VT_NAME, name);
  }
  void add_rectangle(flatbuffers::Offset<Rect> rectangle) {
    fbb_.AddOffset(Cell::VT_RECTANGLE, rectangle);
  }
  void add_pivot(flatbuffers::Offset<Vector2> pivot) {
    fbb_.AddOffset(Cell::VT_PIVOT, pivot);
  }
  void add_mesh(flatbuffers::Offset<DataMesh> mesh) {
    fbb_.AddOffset(Cell::VT_MESH, mesh);
  }
  explicit CellBuilder(flatbuffers::FlatBufferBuilder &_fbb)
        : fbb_(_fbb) {
    start_ = fbb_.StartTable();
  }
  CellBuilder &operator=(const CellBuilder &);
  flatbuffers::Offset<Cell> Finish() {
    const auto end = fbb_.EndTable(start_);
    auto o = flatbuffers::Offset<Cell>(end);
    return o;
  }
};

inline flatbuffers::Offset<Cell> CreateCell(
    flatbuffers::FlatBufferBuilder &_fbb,
    flatbuffers::Offset<flatbuffers::String> name = 0,
    flatbuffers::Offset<Rect> rectangle = 0,
    flatbuffers::Offset<Vector2> pivot = 0,
    flatbuffers::Offset<DataMesh> mesh = 0) {
  CellBuilder builder_(_fbb);
  builder_.add_mesh(mesh);
  builder_.add_pivot(pivot);
  builder_.add_rectangle(rectangle);
  builder_.add_name(name);
  return builder_.Finish();
}

inline flatbuffers::Offset<Cell> CreateCellDirect(
    flatbuffers::FlatBufferBuilder &_fbb,
    const char *name = nullptr,
    flatbuffers::Offset<Rect> rectangle = 0,
    flatbuffers::Offset<Vector2> pivot = 0,
    flatbuffers::Offset<DataMesh> mesh = 0) {
  auto name__ = name ? _fbb.CreateString(name) : 0;
  return ss::ssfb2::CreateCell(
      _fbb,
      name__,
      rectangle,
      pivot,
      mesh);
}

struct LibraryDataCellMap FLATBUFFERS_FINAL_CLASS : private flatbuffers::Table {
  enum FlatBuffersVTableOffset FLATBUFFERS_VTABLE_UNDERLYING_TYPE {
    VT_NAME = 4,
    VT_SIZE_ORIGINAL = 6,
    VT_TABLE_CELL = 8
  };
  const flatbuffers::String *name() const {
    return GetPointer<const flatbuffers::String *>(VT_NAME);
  }
  const Vector2 *size_original() const {
    return GetPointer<const Vector2 *>(VT_SIZE_ORIGINAL);
  }
  const flatbuffers::Vector<flatbuffers::Offset<Cell>> *table_cell() const {
    return GetPointer<const flatbuffers::Vector<flatbuffers::Offset<Cell>> *>(VT_TABLE_CELL);
  }
  bool Verify(flatbuffers::Verifier &verifier) const {
    return VerifyTableStart(verifier) &&
           VerifyOffset(verifier, VT_NAME) &&
           verifier.VerifyString(name()) &&
           VerifyOffset(verifier, VT_SIZE_ORIGINAL) &&
           verifier.VerifyTable(size_original()) &&
           VerifyOffset(verifier, VT_TABLE_CELL) &&
           verifier.VerifyVector(table_cell()) &&
           verifier.VerifyVectorOfTables(table_cell()) &&
           verifier.EndTable();
  }
};

struct LibraryDataCellMapBuilder {
  flatbuffers::FlatBufferBuilder &fbb_;
  flatbuffers::uoffset_t start_;
  void add_name(flatbuffers::Offset<flatbuffers::String> name) {
    fbb_.AddOffset(LibraryDataCellMap::VT_NAME, name);
  }
  void add_size_original(flatbuffers::Offset<Vector2> size_original) {
    fbb_.AddOffset(LibraryDataCellMap::VT_SIZE_ORIGINAL, size_original);
  }
  void add_table_cell(flatbuffers::Offset<flatbuffers::Vector<flatbuffers::Offset<Cell>>> table_cell) {
    fbb_.AddOffset(LibraryDataCellMap::VT_TABLE_CELL, table_cell);
  }
  explicit LibraryDataCellMapBuilder(flatbuffers::FlatBufferBuilder &_fbb)
        : fbb_(_fbb) {
    start_ = fbb_.StartTable();
  }
  LibraryDataCellMapBuilder &operator=(const LibraryDataCellMapBuilder &);
  flatbuffers::Offset<LibraryDataCellMap> Finish() {
    const auto end = fbb_.EndTable(start_);
    auto o = flatbuffers::Offset<LibraryDataCellMap>(end);
    return o;
  }
};

inline flatbuffers::Offset<LibraryDataCellMap> CreateLibraryDataCellMap(
    flatbuffers::FlatBufferBuilder &_fbb,
    flatbuffers::Offset<flatbuffers::String> name = 0,
    flatbuffers::Offset<Vector2> size_original = 0,
    flatbuffers::Offset<flatbuffers::Vector<flatbuffers::Offset<Cell>>> table_cell = 0) {
  LibraryDataCellMapBuilder builder_(_fbb);
  builder_.add_table_cell(table_cell);
  builder_.add_size_original(size_original);
  builder_.add_name(name);
  return builder_.Finish();
}

inline flatbuffers::Offset<LibraryDataCellMap> CreateLibraryDataCellMapDirect(
    flatbuffers::FlatBufferBuilder &_fbb,
    const char *name = nullptr,
    flatbuffers::Offset<Vector2> size_original = 0,
    const std::vector<flatbuffers::Offset<Cell>> *table_cell = nullptr) {
  auto name__ = name ? _fbb.CreateString(name) : 0;
  auto table_cell__ = table_cell ? _fbb.CreateVector<flatbuffers::Offset<Cell>>(*table_cell) : 0;
  return ss::ssfb2::CreateLibraryDataCellMap(
      _fbb,
      name__,
      size_original,
      table_cell__);
}

struct DataCellMap FLATBUFFERS_FINAL_CLASS : private flatbuffers::Table {
  enum FlatBuffersVTableOffset FLATBUFFERS_VTABLE_UNDERLYING_TYPE {
    VT_VERSION = 4,
    VT_TABLE_CELL_MAP = 6
  };
  uint32_t version() const {
    return GetField<uint32_t>(VT_VERSION, 0);
  }
  const flatbuffers::Vector<flatbuffers::Offset<LibraryDataCellMap>> *table_cell_map() const {
    return GetPointer<const flatbuffers::Vector<flatbuffers::Offset<LibraryDataCellMap>> *>(VT_TABLE_CELL_MAP);
  }
  bool Verify(flatbuffers::Verifier &verifier) const {
    return VerifyTableStart(verifier) &&
           VerifyField<uint32_t>(verifier, VT_VERSION) &&
           VerifyOffset(verifier, VT_TABLE_CELL_MAP) &&
           verifier.VerifyVector(table_cell_map()) &&
           verifier.VerifyVectorOfTables(table_cell_map()) &&
           verifier.EndTable();
  }
};

struct DataCellMapBuilder {
  flatbuffers::FlatBufferBuilder &fbb_;
  flatbuffers::uoffset_t start_;
  void add_version(uint32_t version) {
    fbb_.AddElement<uint32_t>(DataCellMap::VT_VERSION, version, 0);
  }
  void add_table_cell_map(flatbuffers::Offset<flatbuffers::Vector<flatbuffers::Offset<LibraryDataCellMap>>> table_cell_map) {
    fbb_.AddOffset(DataCellMap::VT_TABLE_CELL_MAP, table_cell_map);
  }
  explicit DataCellMapBuilder(flatbuffers::FlatBufferBuilder &_fbb)
        : fbb_(_fbb) {
    start_ = fbb_.StartTable();
  }
  DataCellMapBuilder &operator=(const DataCellMapBuilder &);
  flatbuffers::Offset<DataCellMap> Finish() {
    const auto end = fbb_.EndTable(start_);
    auto o = flatbuffers::Offset<DataCellMap>(end);
    return o;
  }
};

inline flatbuffers::Offset<DataCellMap> CreateDataCellMap(
    flatbuffers::FlatBufferBuilder &_fbb,
    uint32_t version = 0,
    flatbuffers::Offset<flatbuffers::Vector<flatbuffers::Offset<LibraryDataCellMap>>> table_cell_map = 0) {
  DataCellMapBuilder builder_(_fbb);
  builder_.add_table_cell_map(table_cell_map);
  builder_.add_version(version);
  return builder_.Finish();
}

inline flatbuffers::Offset<DataCellMap> CreateDataCellMapDirect(
    flatbuffers::FlatBufferBuilder &_fbb,
    uint32_t version = 0,
    const std::vector<flatbuffers::Offset<LibraryDataCellMap>> *table_cell_map = nullptr) {
  auto table_cell_map__ = table_cell_map ? _fbb.CreateVector<flatbuffers::Offset<LibraryDataCellMap>>(*table_cell_map) : 0;
  return ss::ssfb2::CreateDataCellMap(
      _fbb,
      version,
      table_cell_map__);
}

struct Bone FLATBUFFERS_FINAL_CLASS : private flatbuffers::Table {
  enum FlatBuffersVTableOffset FLATBUFFERS_VTABLE_UNDERLYING_TYPE {
    VT_INDEX = 4,
    VT_WEIGHT = 6,
    VT_COORDINATE_OFFSET = 8
  };
  uint16_t index() const {
    return GetField<uint16_t>(VT_INDEX, 0);
  }
  float weight() const {
    return GetField<float>(VT_WEIGHT, 0.0f);
  }
  const Vector3 *coordinate_offset() const {
    return GetPointer<const Vector3 *>(VT_COORDINATE_OFFSET);
  }
  bool Verify(flatbuffers::Verifier &verifier) const {
    return VerifyTableStart(verifier) &&
           VerifyField<uint16_t>(verifier, VT_INDEX) &&
           VerifyField<float>(verifier, VT_WEIGHT) &&
           VerifyOffset(verifier, VT_COORDINATE_OFFSET) &&
           verifier.VerifyTable(coordinate_offset()) &&
           verifier.EndTable();
  }
};

struct BoneBuilder {
  flatbuffers::FlatBufferBuilder &fbb_;
  flatbuffers::uoffset_t start_;
  void add_index(uint16_t index) {
    fbb_.AddElement<uint16_t>(Bone::VT_INDEX, index, 0);
  }
  void add_weight(float weight) {
    fbb_.AddElement<float>(Bone::VT_WEIGHT, weight, 0.0f);
  }
  void add_coordinate_offset(flatbuffers::Offset<Vector3> coordinate_offset) {
    fbb_.AddOffset(Bone::VT_COORDINATE_OFFSET, coordinate_offset);
  }
  explicit BoneBuilder(flatbuffers::FlatBufferBuilder &_fbb)
        : fbb_(_fbb) {
    start_ = fbb_.StartTable();
  }
  BoneBuilder &operator=(const BoneBuilder &);
  flatbuffers::Offset<Bone> Finish() {
    const auto end = fbb_.EndTable(start_);
    auto o = flatbuffers::Offset<Bone>(end);
    return o;
  }
};

inline flatbuffers::Offset<Bone> CreateBone(
    flatbuffers::FlatBufferBuilder &_fbb,
    uint16_t index = 0,
    float weight = 0.0f,
    flatbuffers::Offset<Vector3> coordinate_offset = 0) {
  BoneBuilder builder_(_fbb);
  builder_.add_coordinate_offset(coordinate_offset);
  builder_.add_weight(weight);
  builder_.add_index(index);
  return builder_.Finish();
}

struct Vertex FLATBUFFERS_FINAL_CLASS : private flatbuffers::Table {
  enum FlatBuffersVTableOffset FLATBUFFERS_VTABLE_UNDERLYING_TYPE {
    VT_TABLE_BONE = 4
  };
  const flatbuffers::Vector<flatbuffers::Offset<Bone>> *table_bone() const {
    return GetPointer<const flatbuffers::Vector<flatbuffers::Offset<Bone>> *>(VT_TABLE_BONE);
  }
  bool Verify(flatbuffers::Verifier &verifier) const {
    return VerifyTableStart(verifier) &&
           VerifyOffset(verifier, VT_TABLE_BONE) &&
           verifier.VerifyVector(table_bone()) &&
           verifier.VerifyVectorOfTables(table_bone()) &&
           verifier.EndTable();
  }
};

struct VertexBuilder {
  flatbuffers::FlatBufferBuilder &fbb_;
  flatbuffers::uoffset_t start_;
  void add_table_bone(flatbuffers::Offset<flatbuffers::Vector<flatbuffers::Offset<Bone>>> table_bone) {
    fbb_.AddOffset(Vertex::VT_TABLE_BONE, table_bone);
  }
  explicit VertexBuilder(flatbuffers::FlatBufferBuilder &_fbb)
        : fbb_(_fbb) {
    start_ = fbb_.StartTable();
  }
  VertexBuilder &operator=(const VertexBuilder &);
  flatbuffers::Offset<Vertex> Finish() {
    const auto end = fbb_.EndTable(start_);
    auto o = flatbuffers::Offset<Vertex>(end);
    return o;
  }
};

inline flatbuffers::Offset<Vertex> CreateVertex(
    flatbuffers::FlatBufferBuilder &_fbb,
    flatbuffers::Offset<flatbuffers::Vector<flatbuffers::Offset<Bone>>> table_bone = 0) {
  VertexBuilder builder_(_fbb);
  builder_.add_table_bone(table_bone);
  return builder_.Finish();
}

inline flatbuffers::Offset<Vertex> CreateVertexDirect(
    flatbuffers::FlatBufferBuilder &_fbb,
    const std::vector<flatbuffers::Offset<Bone>> *table_bone = nullptr) {
  auto table_bone__ = table_bone ? _fbb.CreateVector<flatbuffers::Offset<Bone>>(*table_bone) : 0;
  return ss::ssfb2::CreateVertex(
      _fbb,
      table_bone__);
}

struct BindMesh FLATBUFFERS_FINAL_CLASS : private flatbuffers::Table {
  enum FlatBuffersVTableOffset FLATBUFFERS_VTABLE_UNDERLYING_TYPE {
    VT_COUNT_VERTEX = 4,
    VT_TABLE_VERTEX = 6,
    VT_TABLE_RATE_UV = 8,
    VT_TABLE_INDEX_VERTEX = 10,
    VT_COUNT_VERTEX_DEFORM = 12
  };
  int32_t count_vertex() const {
    return GetField<int32_t>(VT_COUNT_VERTEX, 0);
  }
  const flatbuffers::Vector<flatbuffers::Offset<Vertex>> *table_vertex() const {
    return GetPointer<const flatbuffers::Vector<flatbuffers::Offset<Vertex>> *>(VT_TABLE_VERTEX);
  }
  const flatbuffers::Vector<flatbuffers::Offset<Vector2>> *table_rate_uv() const {
    return GetPointer<const flatbuffers::Vector<flatbuffers::Offset<Vector2>> *>(VT_TABLE_RATE_UV);
  }
  const flatbuffers::Vector<int32_t> *table_index_vertex() const {
    return GetPointer<const flatbuffers::Vector<int32_t> *>(VT_TABLE_INDEX_VERTEX);
  }
  int32_t count_vertex_deform() const {
    return GetField<int32_t>(VT_COUNT_VERTEX_DEFORM, 0);
  }
  bool Verify(flatbuffers::Verifier &verifier) const {
    return VerifyTableStart(verifier) &&
           VerifyField<int32_t>(verifier, VT_COUNT_VERTEX) &&
           VerifyOffset(verifier, VT_TABLE_VERTEX) &&
           verifier.VerifyVector(table_vertex()) &&
           verifier.VerifyVectorOfTables(table_vertex()) &&
           VerifyOffset(verifier, VT_TABLE_RATE_UV) &&
           verifier.VerifyVector(table_rate_uv()) &&
           verifier.VerifyVectorOfTables(table_rate_uv()) &&
           VerifyOffset(verifier, VT_TABLE_INDEX_VERTEX) &&
           verifier.VerifyVector(table_index_vertex()) &&
           VerifyField<int32_t>(verifier, VT_COUNT_VERTEX_DEFORM) &&
           verifier.EndTable();
  }
};

struct BindMeshBuilder {
  flatbuffers::FlatBufferBuilder &fbb_;
  flatbuffers::uoffset_t start_;
  void add_count_vertex(int32_t count_vertex) {
    fbb_.AddElement<int32_t>(BindMesh::VT_COUNT_VERTEX, count_vertex, 0);
  }
  void add_table_vertex(flatbuffers::Offset<flatbuffers::Vector<flatbuffers::Offset<Vertex>>> table_vertex) {
    fbb_.AddOffset(BindMesh::VT_TABLE_VERTEX, table_vertex);
  }
  void add_table_rate_uv(flatbuffers::Offset<flatbuffers::Vector<flatbuffers::Offset<Vector2>>> table_rate_uv) {
    fbb_.AddOffset(BindMesh::VT_TABLE_RATE_UV, table_rate_uv);
  }
  void add_table_index_vertex(flatbuffers::Offset<flatbuffers::Vector<int32_t>> table_index_vertex) {
    fbb_.AddOffset(BindMesh::VT_TABLE_INDEX_VERTEX, table_index_vertex);
  }
  void add_count_vertex_deform(int32_t count_vertex_deform) {
    fbb_.AddElement<int32_t>(BindMesh::VT_COUNT_VERTEX_DEFORM, count_vertex_deform, 0);
  }
  explicit BindMeshBuilder(flatbuffers::FlatBufferBuilder &_fbb)
        : fbb_(_fbb) {
    start_ = fbb_.StartTable();
  }
  BindMeshBuilder &operator=(const BindMeshBuilder &);
  flatbuffers::Offset<BindMesh> Finish() {
    const auto end = fbb_.EndTable(start_);
    auto o = flatbuffers::Offset<BindMesh>(end);
    return o;
  }
};

inline flatbuffers::Offset<BindMesh> CreateBindMesh(
    flatbuffers::FlatBufferBuilder &_fbb,
    int32_t count_vertex = 0,
    flatbuffers::Offset<flatbuffers::Vector<flatbuffers::Offset<Vertex>>> table_vertex = 0,
    flatbuffers::Offset<flatbuffers::Vector<flatbuffers::Offset<Vector2>>> table_rate_uv = 0,
    flatbuffers::Offset<flatbuffers::Vector<int32_t>> table_index_vertex = 0,
    int32_t count_vertex_deform = 0) {
  BindMeshBuilder builder_(_fbb);
  builder_.add_count_vertex_deform(count_vertex_deform);
  builder_.add_table_index_vertex(table_index_vertex);
  builder_.add_table_rate_uv(table_rate_uv);
  builder_.add_table_vertex(table_vertex);
  builder_.add_count_vertex(count_vertex);
  return builder_.Finish();
}

inline flatbuffers::Offset<BindMesh> CreateBindMeshDirect(
    flatbuffers::FlatBufferBuilder &_fbb,
    int32_t count_vertex = 0,
    const std::vector<flatbuffers::Offset<Vertex>> *table_vertex = nullptr,
    const std::vector<flatbuffers::Offset<Vector2>> *table_rate_uv = nullptr,
    const std::vector<int32_t> *table_index_vertex = nullptr,
    int32_t count_vertex_deform = 0) {
  auto table_vertex__ = table_vertex ? _fbb.CreateVector<flatbuffers::Offset<Vertex>>(*table_vertex) : 0;
  auto table_rate_uv__ = table_rate_uv ? _fbb.CreateVector<flatbuffers::Offset<Vector2>>(*table_rate_uv) : 0;
  auto table_index_vertex__ = table_index_vertex ? _fbb.CreateVector<int32_t>(*table_index_vertex) : 0;
  return ss::ssfb2::CreateBindMesh(
      _fbb,
      count_vertex,
      table_vertex__,
      table_rate_uv__,
      table_index_vertex__,
      count_vertex_deform);
}

struct Color32 FLATBUFFERS_FINAL_CLASS : private flatbuffers::Table {
  enum FlatBuffersVTableOffset FLATBUFFERS_VTABLE_UNDERLYING_TYPE {
    VT_R = 4,
    VT_G = 6,
    VT_B = 8,
    VT_A = 10
  };
  uint8_t r() const {
    return GetField<uint8_t>(VT_R, 0);
  }
  uint8_t g() const {
    return GetField<uint8_t>(VT_G, 0);
  }
  uint8_t b() const {
    return GetField<uint8_t>(VT_B, 0);
  }
  uint8_t a() const {
    return GetField<uint8_t>(VT_A, 0);
  }
  bool Verify(flatbuffers::Verifier &verifier) const {
    return VerifyTableStart(verifier) &&
           VerifyField<uint8_t>(verifier, VT_R) &&
           VerifyField<uint8_t>(verifier, VT_G) &&
           VerifyField<uint8_t>(verifier, VT_B) &&
           VerifyField<uint8_t>(verifier, VT_A) &&
           verifier.EndTable();
  }
};

struct Color32Builder {
  flatbuffers::FlatBufferBuilder &fbb_;
  flatbuffers::uoffset_t start_;
  void add_r(uint8_t r) {
    fbb_.AddElement<uint8_t>(Color32::VT_R, r, 0);
  }
  void add_g(uint8_t g) {
    fbb_.AddElement<uint8_t>(Color32::VT_G, g, 0);
  }
  void add_b(uint8_t b) {
    fbb_.AddElement<uint8_t>(Color32::VT_B, b, 0);
  }
  void add_a(uint8_t a) {
    fbb_.AddElement<uint8_t>(Color32::VT_A, a, 0);
  }
  explicit Color32Builder(flatbuffers::FlatBufferBuilder &_fbb)
        : fbb_(_fbb) {
    start_ = fbb_.StartTable();
  }
  Color32Builder &operator=(const Color32Builder &);
  flatbuffers::Offset<Color32> Finish() {
    const auto end = fbb_.EndTable(start_);
    auto o = flatbuffers::Offset<Color32>(end);
    return o;
  }
};

inline flatbuffers::Offset<Color32> CreateColor32(
    flatbuffers::FlatBufferBuilder &_fbb,
    uint8_t r = 0,
    uint8_t g = 0,
    uint8_t b = 0,
    uint8_t a = 0) {
  Color32Builder builder_(_fbb);
  builder_.add_a(a);
  builder_.add_b(b);
  builder_.add_g(g);
  builder_.add_r(r);
  return builder_.Finish();
}

struct Color FLATBUFFERS_FINAL_CLASS : private flatbuffers::Table {
  enum FlatBuffersVTableOffset FLATBUFFERS_VTABLE_UNDERLYING_TYPE {
    VT_R = 4,
    VT_G = 6,
    VT_B = 8,
    VT_A = 10
  };
  float r() const {
    return GetField<float>(VT_R, 0.0f);
  }
  float g() const {
    return GetField<float>(VT_G, 0.0f);
  }
  float b() const {
    return GetField<float>(VT_B, 0.0f);
  }
  float a() const {
    return GetField<float>(VT_A, 0.0f);
  }
  bool Verify(flatbuffers::Verifier &verifier) const {
    return VerifyTableStart(verifier) &&
           VerifyField<float>(verifier, VT_R) &&
           VerifyField<float>(verifier, VT_G) &&
           VerifyField<float>(verifier, VT_B) &&
           VerifyField<float>(verifier, VT_A) &&
           verifier.EndTable();
  }
};

struct ColorBuilder {
  flatbuffers::FlatBufferBuilder &fbb_;
  flatbuffers::uoffset_t start_;
  void add_r(float r) {
    fbb_.AddElement<float>(Color::VT_R, r, 0.0f);
  }
  void add_g(float g) {
    fbb_.AddElement<float>(Color::VT_G, g, 0.0f);
  }
  void add_b(float b) {
    fbb_.AddElement<float>(Color::VT_B, b, 0.0f);
  }
  void add_a(float a) {
    fbb_.AddElement<float>(Color::VT_A, a, 0.0f);
  }
  explicit ColorBuilder(flatbuffers::FlatBufferBuilder &_fbb)
        : fbb_(_fbb) {
    start_ = fbb_.StartTable();
  }
  ColorBuilder &operator=(const ColorBuilder &);
  flatbuffers::Offset<Color> Finish() {
    const auto end = fbb_.EndTable(start_);
    auto o = flatbuffers::Offset<Color>(end);
    return o;
  }
};

inline flatbuffers::Offset<Color> CreateColor(
    flatbuffers::FlatBufferBuilder &_fbb,
    float r = 0.0f,
    float g = 0.0f,
    float b = 0.0f,
    float a = 0.0f) {
  ColorBuilder builder_(_fbb);
  builder_.add_a(a);
  builder_.add_b(b);
  builder_.add_g(g);
  builder_.add_r(r);
  return builder_.Finish();
}

struct ColorLabel FLATBUFFERS_FINAL_CLASS : private flatbuffers::Table {
  enum FlatBuffersVTableOffset FLATBUFFERS_VTABLE_UNDERLYING_TYPE {
    VT_FORM = 4,
    VT_COLOR = 6
  };
  ColorLabelKindForm form() const {
    return static_cast<ColorLabelKindForm>(GetField<uint8_t>(VT_FORM, 0));
  }
  const Color32 *color() const {
    return GetPointer<const Color32 *>(VT_COLOR);
  }
  bool Verify(flatbuffers::Verifier &verifier) const {
    return VerifyTableStart(verifier) &&
           VerifyField<uint8_t>(verifier, VT_FORM) &&
           VerifyOffset(verifier, VT_COLOR) &&
           verifier.VerifyTable(color()) &&
           verifier.EndTable();
  }
};

struct ColorLabelBuilder {
  flatbuffers::FlatBufferBuilder &fbb_;
  flatbuffers::uoffset_t start_;
  void add_form(ColorLabelKindForm form) {
    fbb_.AddElement<uint8_t>(ColorLabel::VT_FORM, static_cast<uint8_t>(form), 0);
  }
  void add_color(flatbuffers::Offset<Color32> color) {
    fbb_.AddOffset(ColorLabel::VT_COLOR, color);
  }
  explicit ColorLabelBuilder(flatbuffers::FlatBufferBuilder &_fbb)
        : fbb_(_fbb) {
    start_ = fbb_.StartTable();
  }
  ColorLabelBuilder &operator=(const ColorLabelBuilder &);
  flatbuffers::Offset<ColorLabel> Finish() {
    const auto end = fbb_.EndTable(start_);
    auto o = flatbuffers::Offset<ColorLabel>(end);
    return o;
  }
};

inline flatbuffers::Offset<ColorLabel> CreateColorLabel(
    flatbuffers::FlatBufferBuilder &_fbb,
    ColorLabelKindForm form = ColorLabelKindForm_Non,
    flatbuffers::Offset<Color32> color = 0) {
  ColorLabelBuilder builder_(_fbb);
  builder_.add_color(color);
  builder_.add_form(form);
  return builder_.Finish();
}

struct Catalog FLATBUFFERS_FINAL_CLASS : private flatbuffers::Table {
  enum FlatBuffersVTableOffset FLATBUFFERS_VTABLE_UNDERLYING_TYPE {
    VT_TABLE_ID_PARTS_NULL = 4,
    VT_TABLE_ID_PARTS_NORMAL = 6,
    VT_TABLE_ID_PARTS_INSTANCE = 8,
    VT_TABLE_ID_PARTS_EFFECT = 10,
    VT_TABLE_ID_PARTS_MASK = 12,
    VT_TABLE_ID_PARTS_JOINT = 14,
    VT_TABLE_ID_PARTS_BONE = 16,
    VT_TABLE_ID_PARTS_MOVE_NODE = 18,
    VT_TABLE_ID_PARTS_CONSTRAINT = 20,
    VT_TABLE_ID_PARTS_BONE_POINT = 22,
    VT_TABLE_ID_PARTS_MESH = 24
  };
  const flatbuffers::Vector<uint16_t> *table_id_parts_null() const {
    return GetPointer<const flatbuffers::Vector<uint16_t> *>(VT_TABLE_ID_PARTS_NULL);
  }
  const flatbuffers::Vector<uint16_t> *table_id_parts_normal() const {
    return GetPointer<const flatbuffers::Vector<uint16_t> *>(VT_TABLE_ID_PARTS_NORMAL);
  }
  const flatbuffers::Vector<uint16_t> *table_id_parts_instance() const {
    return GetPointer<const flatbuffers::Vector<uint16_t> *>(VT_TABLE_ID_PARTS_INSTANCE);
  }
  const flatbuffers::Vector<uint16_t> *table_id_parts_effect() const {
    return GetPointer<const flatbuffers::Vector<uint16_t> *>(VT_TABLE_ID_PARTS_EFFECT);
  }
  const flatbuffers::Vector<uint16_t> *table_id_parts_mask() const {
    return GetPointer<const flatbuffers::Vector<uint16_t> *>(VT_TABLE_ID_PARTS_MASK);
  }
  const flatbuffers::Vector<uint16_t> *table_id_parts_joint() const {
    return GetPointer<const flatbuffers::Vector<uint16_t> *>(VT_TABLE_ID_PARTS_JOINT);
  }
  const flatbuffers::Vector<uint16_t> *table_id_parts_bone() const {
    return GetPointer<const flatbuffers::Vector<uint16_t> *>(VT_TABLE_ID_PARTS_BONE);
  }
  const flatbuffers::Vector<uint16_t> *table_id_parts_move_node() const {
    return GetPointer<const flatbuffers::Vector<uint16_t> *>(VT_TABLE_ID_PARTS_MOVE_NODE);
  }
  const flatbuffers::Vector<uint16_t> *table_id_parts_constraint() const {
    return GetPointer<const flatbuffers::Vector<uint16_t> *>(VT_TABLE_ID_PARTS_CONSTRAINT);
  }
  const flatbuffers::Vector<uint16_t> *table_id_parts_bone_point() const {
    return GetPointer<const flatbuffers::Vector<uint16_t> *>(VT_TABLE_ID_PARTS_BONE_POINT);
  }
  const flatbuffers::Vector<uint16_t> *table_id_parts_mesh() const {
    return GetPointer<const flatbuffers::Vector<uint16_t> *>(VT_TABLE_ID_PARTS_MESH);
  }
  bool Verify(flatbuffers::Verifier &verifier) const {
    return VerifyTableStart(verifier) &&
           VerifyOffset(verifier, VT_TABLE_ID_PARTS_NULL) &&
           verifier.VerifyVector(table_id_parts_null()) &&
           VerifyOffset(verifier, VT_TABLE_ID_PARTS_NORMAL) &&
           verifier.VerifyVector(table_id_parts_normal()) &&
           VerifyOffset(verifier, VT_TABLE_ID_PARTS_INSTANCE) &&
           verifier.VerifyVector(table_id_parts_instance()) &&
           VerifyOffset(verifier, VT_TABLE_ID_PARTS_EFFECT) &&
           verifier.VerifyVector(table_id_parts_effect()) &&
           VerifyOffset(verifier, VT_TABLE_ID_PARTS_MASK) &&
           verifier.VerifyVector(table_id_parts_mask()) &&
           VerifyOffset(verifier, VT_TABLE_ID_PARTS_JOINT) &&
           verifier.VerifyVector(table_id_parts_joint()) &&
           VerifyOffset(verifier, VT_TABLE_ID_PARTS_BONE) &&
           verifier.VerifyVector(table_id_parts_bone()) &&
           VerifyOffset(verifier, VT_TABLE_ID_PARTS_MOVE_NODE) &&
           verifier.VerifyVector(table_id_parts_move_node()) &&
           VerifyOffset(verifier, VT_TABLE_ID_PARTS_CONSTRAINT) &&
           verifier.VerifyVector(table_id_parts_constraint()) &&
           VerifyOffset(verifier, VT_TABLE_ID_PARTS_BONE_POINT) &&
           verifier.VerifyVector(table_id_parts_bone_point()) &&
           VerifyOffset(verifier, VT_TABLE_ID_PARTS_MESH) &&
           verifier.VerifyVector(table_id_parts_mesh()) &&
           verifier.EndTable();
  }
};

struct CatalogBuilder {
  flatbuffers::FlatBufferBuilder &fbb_;
  flatbuffers::uoffset_t start_;
  void add_table_id_parts_null(flatbuffers::Offset<flatbuffers::Vector<uint16_t>> table_id_parts_null) {
    fbb_.AddOffset(Catalog::VT_TABLE_ID_PARTS_NULL, table_id_parts_null);
  }
  void add_table_id_parts_normal(flatbuffers::Offset<flatbuffers::Vector<uint16_t>> table_id_parts_normal) {
    fbb_.AddOffset(Catalog::VT_TABLE_ID_PARTS_NORMAL, table_id_parts_normal);
  }
  void add_table_id_parts_instance(flatbuffers::Offset<flatbuffers::Vector<uint16_t>> table_id_parts_instance) {
    fbb_.AddOffset(Catalog::VT_TABLE_ID_PARTS_INSTANCE, table_id_parts_instance);
  }
  void add_table_id_parts_effect(flatbuffers::Offset<flatbuffers::Vector<uint16_t>> table_id_parts_effect) {
    fbb_.AddOffset(Catalog::VT_TABLE_ID_PARTS_EFFECT, table_id_parts_effect);
  }
  void add_table_id_parts_mask(flatbuffers::Offset<flatbuffers::Vector<uint16_t>> table_id_parts_mask) {
    fbb_.AddOffset(Catalog::VT_TABLE_ID_PARTS_MASK, table_id_parts_mask);
  }
  void add_table_id_parts_joint(flatbuffers::Offset<flatbuffers::Vector<uint16_t>> table_id_parts_joint) {
    fbb_.AddOffset(Catalog::VT_TABLE_ID_PARTS_JOINT, table_id_parts_joint);
  }
  void add_table_id_parts_bone(flatbuffers::Offset<flatbuffers::Vector<uint16_t>> table_id_parts_bone) {
    fbb_.AddOffset(Catalog::VT_TABLE_ID_PARTS_BONE, table_id_parts_bone);
  }
  void add_table_id_parts_move_node(flatbuffers::Offset<flatbuffers::Vector<uint16_t>> table_id_parts_move_node) {
    fbb_.AddOffset(Catalog::VT_TABLE_ID_PARTS_MOVE_NODE, table_id_parts_move_node);
  }
  void add_table_id_parts_constraint(flatbuffers::Offset<flatbuffers::Vector<uint16_t>> table_id_parts_constraint) {
    fbb_.AddOffset(Catalog::VT_TABLE_ID_PARTS_CONSTRAINT, table_id_parts_constraint);
  }
  void add_table_id_parts_bone_point(flatbuffers::Offset<flatbuffers::Vector<uint16_t>> table_id_parts_bone_point) {
    fbb_.AddOffset(Catalog::VT_TABLE_ID_PARTS_BONE_POINT, table_id_parts_bone_point);
  }
  void add_table_id_parts_mesh(flatbuffers::Offset<flatbuffers::Vector<uint16_t>> table_id_parts_mesh) {
    fbb_.AddOffset(Catalog::VT_TABLE_ID_PARTS_MESH, table_id_parts_mesh);
  }
  explicit CatalogBuilder(flatbuffers::FlatBufferBuilder &_fbb)
        : fbb_(_fbb) {
    start_ = fbb_.StartTable();
  }
  CatalogBuilder &operator=(const CatalogBuilder &);
  flatbuffers::Offset<Catalog> Finish() {
    const auto end = fbb_.EndTable(start_);
    auto o = flatbuffers::Offset<Catalog>(end);
    return o;
  }
};

inline flatbuffers::Offset<Catalog> CreateCatalog(
    flatbuffers::FlatBufferBuilder &_fbb,
    flatbuffers::Offset<flatbuffers::Vector<uint16_t>> table_id_parts_null = 0,
    flatbuffers::Offset<flatbuffers::Vector<uint16_t>> table_id_parts_normal = 0,
    flatbuffers::Offset<flatbuffers::Vector<uint16_t>> table_id_parts_instance = 0,
    flatbuffers::Offset<flatbuffers::Vector<uint16_t>> table_id_parts_effect = 0,
    flatbuffers::Offset<flatbuffers::Vector<uint16_t>> table_id_parts_mask = 0,
    flatbuffers::Offset<flatbuffers::Vector<uint16_t>> table_id_parts_joint = 0,
    flatbuffers::Offset<flatbuffers::Vector<uint16_t>> table_id_parts_bone = 0,
    flatbuffers::Offset<flatbuffers::Vector<uint16_t>> table_id_parts_move_node = 0,
    flatbuffers::Offset<flatbuffers::Vector<uint16_t>> table_id_parts_constraint = 0,
    flatbuffers::Offset<flatbuffers::Vector<uint16_t>> table_id_parts_bone_point = 0,
    flatbuffers::Offset<flatbuffers::Vector<uint16_t>> table_id_parts_mesh = 0) {
  CatalogBuilder builder_(_fbb);
  builder_.add_table_id_parts_mesh(table_id_parts_mesh);
  builder_.add_table_id_parts_bone_point(table_id_parts_bone_point);
  builder_.add_table_id_parts_constraint(table_id_parts_constraint);
  builder_.add_table_id_parts_move_node(table_id_parts_move_node);
  builder_.add_table_id_parts_bone(table_id_parts_bone);
  builder_.add_table_id_parts_joint(table_id_parts_joint);
  builder_.add_table_id_parts_mask(table_id_parts_mask);
  builder_.add_table_id_parts_effect(table_id_parts_effect);
  builder_.add_table_id_parts_instance(table_id_parts_instance);
  builder_.add_table_id_parts_normal(table_id_parts_normal);
  builder_.add_table_id_parts_null(table_id_parts_null);
  return builder_.Finish();
}

inline flatbuffers::Offset<Catalog> CreateCatalogDirect(
    flatbuffers::FlatBufferBuilder &_fbb,
    const std::vector<uint16_t> *table_id_parts_null = nullptr,
    const std::vector<uint16_t> *table_id_parts_normal = nullptr,
    const std::vector<uint16_t> *table_id_parts_instance = nullptr,
    const std::vector<uint16_t> *table_id_parts_effect = nullptr,
    const std::vector<uint16_t> *table_id_parts_mask = nullptr,
    const std::vector<uint16_t> *table_id_parts_joint = nullptr,
    const std::vector<uint16_t> *table_id_parts_bone = nullptr,
    const std::vector<uint16_t> *table_id_parts_move_node = nullptr,
    const std::vector<uint16_t> *table_id_parts_constraint = nullptr,
    const std::vector<uint16_t> *table_id_parts_bone_point = nullptr,
    const std::vector<uint16_t> *table_id_parts_mesh = nullptr) {
  auto table_id_parts_null__ = table_id_parts_null ? _fbb.CreateVector<uint16_t>(*table_id_parts_null) : 0;
  auto table_id_parts_normal__ = table_id_parts_normal ? _fbb.CreateVector<uint16_t>(*table_id_parts_normal) : 0;
  auto table_id_parts_instance__ = table_id_parts_instance ? _fbb.CreateVector<uint16_t>(*table_id_parts_instance) : 0;
  auto table_id_parts_effect__ = table_id_parts_effect ? _fbb.CreateVector<uint16_t>(*table_id_parts_effect) : 0;
  auto table_id_parts_mask__ = table_id_parts_mask ? _fbb.CreateVector<uint16_t>(*table_id_parts_mask) : 0;
  auto table_id_parts_joint__ = table_id_parts_joint ? _fbb.CreateVector<uint16_t>(*table_id_parts_joint) : 0;
  auto table_id_parts_bone__ = table_id_parts_bone ? _fbb.CreateVector<uint16_t>(*table_id_parts_bone) : 0;
  auto table_id_parts_move_node__ = table_id_parts_move_node ? _fbb.CreateVector<uint16_t>(*table_id_parts_move_node) : 0;
  auto table_id_parts_constraint__ = table_id_parts_constraint ? _fbb.CreateVector<uint16_t>(*table_id_parts_constraint) : 0;
  auto table_id_parts_bone_point__ = table_id_parts_bone_point ? _fbb.CreateVector<uint16_t>(*table_id_parts_bone_point) : 0;
  auto table_id_parts_mesh__ = table_id_parts_mesh ? _fbb.CreateVector<uint16_t>(*table_id_parts_mesh) : 0;
  return ss::ssfb2::CreateCatalog(
      _fbb,
      table_id_parts_null__,
      table_id_parts_normal__,
      table_id_parts_instance__,
      table_id_parts_effect__,
      table_id_parts_mask__,
      table_id_parts_joint__,
      table_id_parts_bone__,
      table_id_parts_move_node__,
      table_id_parts_constraint__,
      table_id_parts_bone_point__,
      table_id_parts_mesh__);
}

struct DataModelParts FLATBUFFERS_FINAL_CLASS : private flatbuffers::Table {
  enum FlatBuffersVTableOffset FLATBUFFERS_VTABLE_UNDERLYING_TYPE {
    VT_NAME = 4,
    VT_ID = 6,
    VT_ID_PARENT = 8,
    VT_TABLE_ID_CHILDREN = 10,
    VT_FEATURE = 12,
    VT_COUNT_MESH = 14,
    VT_MESH = 16,
    VT_LABEL_COLOR = 18,
    VT_OPERATION_BLEND_TARGET = 20,
    VT_SHAPE_COLLISION = 22,
    VT_SIZE_COLLISION = 24,
    VT_INDEX_ANIMATION_PACK_UNDER_CONTROL = 26,
    VT_INDEX_EFFECT_UNDER_CONTROL = 28,
    VT_NAME_ANIMATION_UNDER_CONTROL = 30
  };
  const flatbuffers::String *name() const {
    return GetPointer<const flatbuffers::String *>(VT_NAME);
  }
  int32_t id() const {
    return GetField<int32_t>(VT_ID, 0);
  }
  int32_t id_parent() const {
    return GetField<int32_t>(VT_ID_PARENT, 0);
  }
  const flatbuffers::Vector<int32_t> *table_id_children() const {
    return GetPointer<const flatbuffers::Vector<int32_t> *>(VT_TABLE_ID_CHILDREN);
  }
  DataModelPartsKindFeature feature() const {
    return static_cast<DataModelPartsKindFeature>(GetField<uint8_t>(VT_FEATURE, 0));
  }
  int32_t count_mesh() const {
    return GetField<int32_t>(VT_COUNT_MESH, 0);
  }
  const BindMesh *mesh() const {
    return GetPointer<const BindMesh *>(VT_MESH);
  }
  const ColorLabel *label_color() const {
    return GetPointer<const ColorLabel *>(VT_LABEL_COLOR);
  }
  KindOperationBlend operation_blend_target() const {
    return static_cast<KindOperationBlend>(GetField<int8_t>(VT_OPERATION_BLEND_TARGET, 0));
  }
  KindCollision shape_collision() const {
    return static_cast<KindCollision>(GetField<uint8_t>(VT_SHAPE_COLLISION, 0));
  }
  float size_collision() const {
    return GetField<float>(VT_SIZE_COLLISION, 0.0f);
  }
  uint16_t index_animation_pack_under_control() const {
    return GetField<uint16_t>(VT_INDEX_ANIMATION_PACK_UNDER_CONTROL, 0);
  }
  uint16_t index_effect_under_control() const {
    return GetField<uint16_t>(VT_INDEX_EFFECT_UNDER_CONTROL, 0);
  }
  const flatbuffers::String *name_animation_under_control() const {
    return GetPointer<const flatbuffers::String *>(VT_NAME_ANIMATION_UNDER_CONTROL);
  }
  bool Verify(flatbuffers::Verifier &verifier) const {
    return VerifyTableStart(verifier) &&
           VerifyOffset(verifier, VT_NAME) &&
           verifier.VerifyString(name()) &&
           VerifyField<int32_t>(verifier, VT_ID) &&
           VerifyField<int32_t>(verifier, VT_ID_PARENT) &&
           VerifyOffset(verifier, VT_TABLE_ID_CHILDREN) &&
           verifier.VerifyVector(table_id_children()) &&
           VerifyField<uint8_t>(verifier, VT_FEATURE) &&
           VerifyField<int32_t>(verifier, VT_COUNT_MESH) &&
           VerifyOffset(verifier, VT_MESH) &&
           verifier.VerifyTable(mesh()) &&
           VerifyOffset(verifier, VT_LABEL_COLOR) &&
           verifier.VerifyTable(label_color()) &&
           VerifyField<int8_t>(verifier, VT_OPERATION_BLEND_TARGET) &&
           VerifyField<uint8_t>(verifier, VT_SHAPE_COLLISION) &&
           VerifyField<float>(verifier, VT_SIZE_COLLISION) &&
           VerifyField<uint16_t>(verifier, VT_INDEX_ANIMATION_PACK_UNDER_CONTROL) &&
           VerifyField<uint16_t>(verifier, VT_INDEX_EFFECT_UNDER_CONTROL) &&
           VerifyOffset(verifier, VT_NAME_ANIMATION_UNDER_CONTROL) &&
           verifier.VerifyString(name_animation_under_control()) &&
           verifier.EndTable();
  }
};

struct DataModelPartsBuilder {
  flatbuffers::FlatBufferBuilder &fbb_;
  flatbuffers::uoffset_t start_;
  void add_name(flatbuffers::Offset<flatbuffers::String> name) {
    fbb_.AddOffset(DataModelParts::VT_NAME, name);
  }
  void add_id(int32_t id) {
    fbb_.AddElement<int32_t>(DataModelParts::VT_ID, id, 0);
  }
  void add_id_parent(int32_t id_parent) {
    fbb_.AddElement<int32_t>(DataModelParts::VT_ID_PARENT, id_parent, 0);
  }
  void add_table_id_children(flatbuffers::Offset<flatbuffers::Vector<int32_t>> table_id_children) {
    fbb_.AddOffset(DataModelParts::VT_TABLE_ID_CHILDREN, table_id_children);
  }
  void add_feature(DataModelPartsKindFeature feature) {
    fbb_.AddElement<uint8_t>(DataModelParts::VT_FEATURE, static_cast<uint8_t>(feature), 0);
  }
  void add_count_mesh(int32_t count_mesh) {
    fbb_.AddElement<int32_t>(DataModelParts::VT_COUNT_MESH, count_mesh, 0);
  }
  void add_mesh(flatbuffers::Offset<BindMesh> mesh) {
    fbb_.AddOffset(DataModelParts::VT_MESH, mesh);
  }
  void add_label_color(flatbuffers::Offset<ColorLabel> label_color) {
    fbb_.AddOffset(DataModelParts::VT_LABEL_COLOR, label_color);
  }
  void add_operation_blend_target(KindOperationBlend operation_blend_target) {
    fbb_.AddElement<int8_t>(DataModelParts::VT_OPERATION_BLEND_TARGET, static_cast<int8_t>(operation_blend_target), 0);
  }
  void add_shape_collision(KindCollision shape_collision) {
    fbb_.AddElement<uint8_t>(DataModelParts::VT_SHAPE_COLLISION, static_cast<uint8_t>(shape_collision), 0);
  }
  void add_size_collision(float size_collision) {
    fbb_.AddElement<float>(DataModelParts::VT_SIZE_COLLISION, size_collision, 0.0f);
  }
  void add_index_animation_pack_under_control(uint16_t index_animation_pack_under_control) {
    fbb_.AddElement<uint16_t>(DataModelParts::VT_INDEX_ANIMATION_PACK_UNDER_CONTROL, index_animation_pack_under_control, 0);
  }
  void add_index_effect_under_control(uint16_t index_effect_under_control) {
    fbb_.AddElement<uint16_t>(DataModelParts::VT_INDEX_EFFECT_UNDER_CONTROL, index_effect_under_control, 0);
  }
  void add_name_animation_under_control(flatbuffers::Offset<flatbuffers::String> name_animation_under_control) {
    fbb_.AddOffset(DataModelParts::VT_NAME_ANIMATION_UNDER_CONTROL, name_animation_under_control);
  }
  explicit DataModelPartsBuilder(flatbuffers::FlatBufferBuilder &_fbb)
        : fbb_(_fbb) {
    start_ = fbb_.StartTable();
  }
  DataModelPartsBuilder &operator=(const DataModelPartsBuilder &);
  flatbuffers::Offset<DataModelParts> Finish() {
    const auto end = fbb_.EndTable(start_);
    auto o = flatbuffers::Offset<DataModelParts>(end);
    return o;
  }
};

inline flatbuffers::Offset<DataModelParts> CreateDataModelParts(
    flatbuffers::FlatBufferBuilder &_fbb,
    flatbuffers::Offset<flatbuffers::String> name = 0,
    int32_t id = 0,
    int32_t id_parent = 0,
    flatbuffers::Offset<flatbuffers::Vector<int32_t>> table_id_children = 0,
    DataModelPartsKindFeature feature = DataModelPartsKindFeature_Root,
    int32_t count_mesh = 0,
    flatbuffers::Offset<BindMesh> mesh = 0,
    flatbuffers::Offset<ColorLabel> label_color = 0,
    KindOperationBlend operation_blend_target = KindOperationBlend_Mix,
    KindCollision shape_collision = KindCollision_Non,
    float size_collision = 0.0f,
    uint16_t index_animation_pack_under_control = 0,
    uint16_t index_effect_under_control = 0,
    flatbuffers::Offset<flatbuffers::String> name_animation_under_control = 0) {
  DataModelPartsBuilder builder_(_fbb);
  builder_.add_name_animation_under_control(name_animation_under_control);
  builder_.add_size_collision(size_collision);
  builder_.add_label_color(label_color);
  builder_.add_mesh(mesh);
  builder_.add_count_mesh(count_mesh);
  builder_.add_table_id_children(table_id_children);
  builder_.add_id_parent(id_parent);
  builder_.add_id(id);
  builder_.add_name(name);
  builder_.add_index_effect_under_control(index_effect_under_control);
  builder_.add_index_animation_pack_under_control(index_animation_pack_under_control);
  builder_.add_shape_collision(shape_collision);
  builder_.add_operation_blend_target(operation_blend_target);
  builder_.add_feature(feature);
  return builder_.Finish();
}

inline flatbuffers::Offset<DataModelParts> CreateDataModelPartsDirect(
    flatbuffers::FlatBufferBuilder &_fbb,
    const char *name = nullptr,
    int32_t id = 0,
    int32_t id_parent = 0,
    const std::vector<int32_t> *table_id_children = nullptr,
    DataModelPartsKindFeature feature = DataModelPartsKindFeature_Root,
    int32_t count_mesh = 0,
    flatbuffers::Offset<BindMesh> mesh = 0,
    flatbuffers::Offset<ColorLabel> label_color = 0,
    KindOperationBlend operation_blend_target = KindOperationBlend_Mix,
    KindCollision shape_collision = KindCollision_Non,
    float size_collision = 0.0f,
    uint16_t index_animation_pack_under_control = 0,
    uint16_t index_effect_under_control = 0,
    const char *name_animation_under_control = nullptr) {
  auto name__ = name ? _fbb.CreateString(name) : 0;
  auto table_id_children__ = table_id_children ? _fbb.CreateVector<int32_t>(*table_id_children) : 0;
  auto name_animation_under_control__ = name_animation_under_control ? _fbb.CreateString(name_animation_under_control) : 0;
  return ss::ssfb2::CreateDataModelParts(
      _fbb,
      name__,
      id,
      id_parent,
      table_id_children__,
      feature,
      count_mesh,
      mesh,
      label_color,
      operation_blend_target,
      shape_collision,
      size_collision,
      index_animation_pack_under_control,
      index_effect_under_control,
      name_animation_under_control__);
}

struct Label FLATBUFFERS_FINAL_CLASS : private flatbuffers::Table {
  enum FlatBuffersVTableOffset FLATBUFFERS_VTABLE_UNDERLYING_TYPE {
    VT_NAME = 4,
    VT_FRAME = 6
  };
  const flatbuffers::String *name() const {
    return GetPointer<const flatbuffers::String *>(VT_NAME);
  }
  uint16_t frame() const {
    return GetField<uint16_t>(VT_FRAME, 0);
  }
  bool Verify(flatbuffers::Verifier &verifier) const {
    return VerifyTableStart(verifier) &&
           VerifyOffset(verifier, VT_NAME) &&
           verifier.VerifyString(name()) &&
           VerifyField<uint16_t>(verifier, VT_FRAME) &&
           verifier.EndTable();
  }
};

struct LabelBuilder {
  flatbuffers::FlatBufferBuilder &fbb_;
  flatbuffers::uoffset_t start_;
  void add_name(flatbuffers::Offset<flatbuffers::String> name) {
    fbb_.AddOffset(Label::VT_NAME, name);
  }
  void add_frame(uint16_t frame) {
    fbb_.AddElement<uint16_t>(Label::VT_FRAME, frame, 0);
  }
  explicit LabelBuilder(flatbuffers::FlatBufferBuilder &_fbb)
        : fbb_(_fbb) {
    start_ = fbb_.StartTable();
  }
  LabelBuilder &operator=(const LabelBuilder &);
  flatbuffers::Offset<Label> Finish() {
    const auto end = fbb_.EndTable(start_);
    auto o = flatbuffers::Offset<Label>(end);
    return o;
  }
};

inline flatbuffers::Offset<Label> CreateLabel(
    flatbuffers::FlatBufferBuilder &_fbb,
    flatbuffers::Offset<flatbuffers::String> name = 0,
    uint16_t frame = 0) {
  LabelBuilder builder_(_fbb);
  builder_.add_name(name);
  builder_.add_frame(frame);
  return builder_.Finish();
}

inline flatbuffers::Offset<Label> CreateLabelDirect(
    flatbuffers::FlatBufferBuilder &_fbb,
    const char *name = nullptr,
    uint16_t frame = 0) {
  auto name__ = name ? _fbb.CreateString(name) : 0;
  return ss::ssfb2::CreateLabel(
      _fbb,
      name__,
      frame);
}

struct RangeFloat FLATBUFFERS_FINAL_CLASS : private flatbuffers::Table {
  enum FlatBuffersVTableOffset FLATBUFFERS_VTABLE_UNDERLYING_TYPE {
    VT_MAIN = 4,
    VT_SUB = 6
  };
  float main() const {
    return GetField<float>(VT_MAIN, 0.0f);
  }
  float sub() const {
    return GetField<float>(VT_SUB, 0.0f);
  }
  bool Verify(flatbuffers::Verifier &verifier) const {
    return VerifyTableStart(verifier) &&
           VerifyField<float>(verifier, VT_MAIN) &&
           VerifyField<float>(verifier, VT_SUB) &&
           verifier.EndTable();
  }
};

struct RangeFloatBuilder {
  flatbuffers::FlatBufferBuilder &fbb_;
  flatbuffers::uoffset_t start_;
  void add_main(float main) {
    fbb_.AddElement<float>(RangeFloat::VT_MAIN, main, 0.0f);
  }
  void add_sub(float sub) {
    fbb_.AddElement<float>(RangeFloat::VT_SUB, sub, 0.0f);
  }
  explicit RangeFloatBuilder(flatbuffers::FlatBufferBuilder &_fbb)
        : fbb_(_fbb) {
    start_ = fbb_.StartTable();
  }
  RangeFloatBuilder &operator=(const RangeFloatBuilder &);
  flatbuffers::Offset<RangeFloat> Finish() {
    const auto end = fbb_.EndTable(start_);
    auto o = flatbuffers::Offset<RangeFloat>(end);
    return o;
  }
};

inline flatbuffers::Offset<RangeFloat> CreateRangeFloat(
    flatbuffers::FlatBufferBuilder &_fbb,
    float main = 0.0f,
    float sub = 0.0f) {
  RangeFloatBuilder builder_(_fbb);
  builder_.add_sub(sub);
  builder_.add_main(main);
  return builder_.Finish();
}

struct RangeVector2 FLATBUFFERS_FINAL_CLASS : private flatbuffers::Table {
  enum FlatBuffersVTableOffset FLATBUFFERS_VTABLE_UNDERLYING_TYPE {
    VT_MAIN = 4,
    VT_SUB = 6
  };
  const Vector2 *main() const {
    return GetPointer<const Vector2 *>(VT_MAIN);
  }
  const Vector2 *sub() const {
    return GetPointer<const Vector2 *>(VT_SUB);
  }
  bool Verify(flatbuffers::Verifier &verifier) const {
    return VerifyTableStart(verifier) &&
           VerifyOffset(verifier, VT_MAIN) &&
           verifier.VerifyTable(main()) &&
           VerifyOffset(verifier, VT_SUB) &&
           verifier.VerifyTable(sub()) &&
           verifier.EndTable();
  }
};

struct RangeVector2Builder {
  flatbuffers::FlatBufferBuilder &fbb_;
  flatbuffers::uoffset_t start_;
  void add_main(flatbuffers::Offset<Vector2> main) {
    fbb_.AddOffset(RangeVector2::VT_MAIN, main);
  }
  void add_sub(flatbuffers::Offset<Vector2> sub) {
    fbb_.AddOffset(RangeVector2::VT_SUB, sub);
  }
  explicit RangeVector2Builder(flatbuffers::FlatBufferBuilder &_fbb)
        : fbb_(_fbb) {
    start_ = fbb_.StartTable();
  }
  RangeVector2Builder &operator=(const RangeVector2Builder &);
  flatbuffers::Offset<RangeVector2> Finish() {
    const auto end = fbb_.EndTable(start_);
    auto o = flatbuffers::Offset<RangeVector2>(end);
    return o;
  }
};

inline flatbuffers::Offset<RangeVector2> CreateRangeVector2(
    flatbuffers::FlatBufferBuilder &_fbb,
    flatbuffers::Offset<Vector2> main = 0,
    flatbuffers::Offset<Vector2> sub = 0) {
  RangeVector2Builder builder_(_fbb);
  builder_.add_sub(sub);
  builder_.add_main(main);
  return builder_.Finish();
}

struct RangeColor FLATBUFFERS_FINAL_CLASS : private flatbuffers::Table {
  enum FlatBuffersVTableOffset FLATBUFFERS_VTABLE_UNDERLYING_TYPE {
    VT_MAIN = 4,
    VT_SUB = 6
  };
  const Color *main() const {
    return GetPointer<const Color *>(VT_MAIN);
  }
  const Color *sub() const {
    return GetPointer<const Color *>(VT_SUB);
  }
  bool Verify(flatbuffers::Verifier &verifier) const {
    return VerifyTableStart(verifier) &&
           VerifyOffset(verifier, VT_MAIN) &&
           verifier.VerifyTable(main()) &&
           VerifyOffset(verifier, VT_SUB) &&
           verifier.VerifyTable(sub()) &&
           verifier.EndTable();
  }
};

struct RangeColorBuilder {
  flatbuffers::FlatBufferBuilder &fbb_;
  flatbuffers::uoffset_t start_;
  void add_main(flatbuffers::Offset<Color> main) {
    fbb_.AddOffset(RangeColor::VT_MAIN, main);
  }
  void add_sub(flatbuffers::Offset<Color> sub) {
    fbb_.AddOffset(RangeColor::VT_SUB, sub);
  }
  explicit RangeColorBuilder(flatbuffers::FlatBufferBuilder &_fbb)
        : fbb_(_fbb) {
    start_ = fbb_.StartTable();
  }
  RangeColorBuilder &operator=(const RangeColorBuilder &);
  flatbuffers::Offset<RangeColor> Finish() {
    const auto end = fbb_.EndTable(start_);
    auto o = flatbuffers::Offset<RangeColor>(end);
    return o;
  }
};

inline flatbuffers::Offset<RangeColor> CreateRangeColor(
    flatbuffers::FlatBufferBuilder &_fbb,
    flatbuffers::Offset<Color> main = 0,
    flatbuffers::Offset<Color> sub = 0) {
  RangeColorBuilder builder_(_fbb);
  builder_.add_sub(sub);
  builder_.add_main(main);
  return builder_.Finish();
}

struct PatternEmit FLATBUFFERS_FINAL_CLASS : private flatbuffers::Table {
  enum FlatBuffersVTableOffset FLATBUFFERS_VTABLE_UNDERLYING_TYPE {
    VT_INDEX_GENERATE = 4,
    VT_DURATION = 6,
    VT_CYCLE = 8
  };
  int32_t index_generate() const {
    return GetField<int32_t>(VT_INDEX_GENERATE, 0);
  }
  int32_t duration() const {
    return GetField<int32_t>(VT_DURATION, 0);
  }
  int32_t cycle() const {
    return GetField<int32_t>(VT_CYCLE, 0);
  }
  bool Verify(flatbuffers::Verifier &verifier) const {
    return VerifyTableStart(verifier) &&
           VerifyField<int32_t>(verifier, VT_INDEX_GENERATE) &&
           VerifyField<int32_t>(verifier, VT_DURATION) &&
           VerifyField<int32_t>(verifier, VT_CYCLE) &&
           verifier.EndTable();
  }
};

struct PatternEmitBuilder {
  flatbuffers::FlatBufferBuilder &fbb_;
  flatbuffers::uoffset_t start_;
  void add_index_generate(int32_t index_generate) {
    fbb_.AddElement<int32_t>(PatternEmit::VT_INDEX_GENERATE, index_generate, 0);
  }
  void add_duration(int32_t duration) {
    fbb_.AddElement<int32_t>(PatternEmit::VT_DURATION, duration, 0);
  }
  void add_cycle(int32_t cycle) {
    fbb_.AddElement<int32_t>(PatternEmit::VT_CYCLE, cycle, 0);
  }
  explicit PatternEmitBuilder(flatbuffers::FlatBufferBuilder &_fbb)
        : fbb_(_fbb) {
    start_ = fbb_.StartTable();
  }
  PatternEmitBuilder &operator=(const PatternEmitBuilder &);
  flatbuffers::Offset<PatternEmit> Finish() {
    const auto end = fbb_.EndTable(start_);
    auto o = flatbuffers::Offset<PatternEmit>(end);
    return o;
  }
};

inline flatbuffers::Offset<PatternEmit> CreatePatternEmit(
    flatbuffers::FlatBufferBuilder &_fbb,
    int32_t index_generate = 0,
    int32_t duration = 0,
    int32_t cycle = 0) {
  PatternEmitBuilder builder_(_fbb);
  builder_.add_cycle(cycle);
  builder_.add_duration(duration);
  builder_.add_index_generate(index_generate);
  return builder_.Finish();
}

struct AnimationAttributeCell FLATBUFFERS_FINAL_CLASS : private flatbuffers::Table {
  enum FlatBuffersVTableOffset FLATBUFFERS_VTABLE_UNDERLYING_TYPE {
    VT_INDEXCELLMAP = 4,
    VT_INDEXCELL = 6
  };
  int32_t IndexCellMap() const {
    return GetField<int32_t>(VT_INDEXCELLMAP, 0);
  }
  int32_t IndexCell() const {
    return GetField<int32_t>(VT_INDEXCELL, 0);
  }
  bool Verify(flatbuffers::Verifier &verifier) const {
    return VerifyTableStart(verifier) &&
           VerifyField<int32_t>(verifier, VT_INDEXCELLMAP) &&
           VerifyField<int32_t>(verifier, VT_INDEXCELL) &&
           verifier.EndTable();
  }
};

struct AnimationAttributeCellBuilder {
  flatbuffers::FlatBufferBuilder &fbb_;
  flatbuffers::uoffset_t start_;
  void add_IndexCellMap(int32_t IndexCellMap) {
    fbb_.AddElement<int32_t>(AnimationAttributeCell::VT_INDEXCELLMAP, IndexCellMap, 0);
  }
  void add_IndexCell(int32_t IndexCell) {
    fbb_.AddElement<int32_t>(AnimationAttributeCell::VT_INDEXCELL, IndexCell, 0);
  }
  explicit AnimationAttributeCellBuilder(flatbuffers::FlatBufferBuilder &_fbb)
        : fbb_(_fbb) {
    start_ = fbb_.StartTable();
  }
  AnimationAttributeCellBuilder &operator=(const AnimationAttributeCellBuilder &);
  flatbuffers::Offset<AnimationAttributeCell> Finish() {
    const auto end = fbb_.EndTable(start_);
    auto o = flatbuffers::Offset<AnimationAttributeCell>(end);
    return o;
  }
};

inline flatbuffers::Offset<AnimationAttributeCell> CreateAnimationAttributeCell(
    flatbuffers::FlatBufferBuilder &_fbb,
    int32_t IndexCellMap = 0,
    int32_t IndexCell = 0) {
  AnimationAttributeCellBuilder builder_(_fbb);
  builder_.add_IndexCell(IndexCell);
  builder_.add_IndexCellMap(IndexCellMap);
  return builder_.Finish();
}

struct AnimationAttributePartsColor FLATBUFFERS_FINAL_CLASS : private flatbuffers::Table {
  enum FlatBuffersVTableOffset FLATBUFFERS_VTABLE_UNDERLYING_TYPE {
    VT_BOUND = 4,
    VT_OPERATION = 6,
    VT_VERTEXCOLOR = 8,
    VT_RATEALPHA = 10
  };
  int16_t Bound() const {
    return GetField<int16_t>(VT_BOUND, 0);
  }
  int16_t Operation() const {
    return GetField<int16_t>(VT_OPERATION, 0);
  }
  const flatbuffers::Vector<flatbuffers::Offset<Color>> *VertexColor() const {
    return GetPointer<const flatbuffers::Vector<flatbuffers::Offset<Color>> *>(VT_VERTEXCOLOR);
  }
  const flatbuffers::Vector<float> *RateAlpha() const {
    return GetPointer<const flatbuffers::Vector<float> *>(VT_RATEALPHA);
  }
  bool Verify(flatbuffers::Verifier &verifier) const {
    return VerifyTableStart(verifier) &&
           VerifyField<int16_t>(verifier, VT_BOUND) &&
           VerifyField<int16_t>(verifier, VT_OPERATION) &&
           VerifyOffset(verifier, VT_VERTEXCOLOR) &&
           verifier.VerifyVector(VertexColor()) &&
           verifier.VerifyVectorOfTables(VertexColor()) &&
           VerifyOffset(verifier, VT_RATEALPHA) &&
           verifier.VerifyVector(RateAlpha()) &&
           verifier.EndTable();
  }
};

struct AnimationAttributePartsColorBuilder {
  flatbuffers::FlatBufferBuilder &fbb_;
  flatbuffers::uoffset_t start_;
  void add_Bound(int16_t Bound) {
    fbb_.AddElement<int16_t>(AnimationAttributePartsColor::VT_BOUND, Bound, 0);
  }
  void add_Operation(int16_t Operation) {
    fbb_.AddElement<int16_t>(AnimationAttributePartsColor::VT_OPERATION, Operation, 0);
  }
  void add_VertexColor(flatbuffers::Offset<flatbuffers::Vector<flatbuffers::Offset<Color>>> VertexColor) {
    fbb_.AddOffset(AnimationAttributePartsColor::VT_VERTEXCOLOR, VertexColor);
  }
  void add_RateAlpha(flatbuffers::Offset<flatbuffers::Vector<float>> RateAlpha) {
    fbb_.AddOffset(AnimationAttributePartsColor::VT_RATEALPHA, RateAlpha);
  }
  explicit AnimationAttributePartsColorBuilder(flatbuffers::FlatBufferBuilder &_fbb)
        : fbb_(_fbb) {
    start_ = fbb_.StartTable();
  }
  AnimationAttributePartsColorBuilder &operator=(const AnimationAttributePartsColorBuilder &);
  flatbuffers::Offset<AnimationAttributePartsColor> Finish() {
    const auto end = fbb_.EndTable(start_);
    auto o = flatbuffers::Offset<AnimationAttributePartsColor>(end);
    return o;
  }
};

inline flatbuffers::Offset<AnimationAttributePartsColor> CreateAnimationAttributePartsColor(
    flatbuffers::FlatBufferBuilder &_fbb,
    int16_t Bound = 0,
    int16_t Operation = 0,
    flatbuffers::Offset<flatbuffers::Vector<flatbuffers::Offset<Color>>> VertexColor = 0,
    flatbuffers::Offset<flatbuffers::Vector<float>> RateAlpha = 0) {
  AnimationAttributePartsColorBuilder builder_(_fbb);
  builder_.add_RateAlpha(RateAlpha);
  builder_.add_VertexColor(VertexColor);
  builder_.add_Operation(Operation);
  builder_.add_Bound(Bound);
  return builder_.Finish();
}

inline flatbuffers::Offset<AnimationAttributePartsColor> CreateAnimationAttributePartsColorDirect(
    flatbuffers::FlatBufferBuilder &_fbb,
    int16_t Bound = 0,
    int16_t Operation = 0,
    const std::vector<flatbuffers::Offset<Color>> *VertexColor = nullptr,
    const std::vector<float> *RateAlpha = nullptr) {
  auto VertexColor__ = VertexColor ? _fbb.CreateVector<flatbuffers::Offset<Color>>(*VertexColor) : 0;
  auto RateAlpha__ = RateAlpha ? _fbb.CreateVector<float>(*RateAlpha) : 0;
  return ss::ssfb2::CreateAnimationAttributePartsColor(
      _fbb,
      Bound,
      Operation,
      VertexColor__,
      RateAlpha__);
}

struct CodeValueContainer FLATBUFFERS_FINAL_CLASS : private flatbuffers::Table {
  enum FlatBuffersVTableOffset FLATBUFFERS_VTABLE_UNDERLYING_TYPE {
    VT_TABLECODE = 4
  };
  const flatbuffers::Vector<int32_t> *TableCode() const {
    return GetPointer<const flatbuffers::Vector<int32_t> *>(VT_TABLECODE);
  }
  bool Verify(flatbuffers::Verifier &verifier) const {
    return VerifyTableStart(verifier) &&
           VerifyOffset(verifier, VT_TABLECODE) &&
           verifier.VerifyVector(TableCode()) &&
           verifier.EndTable();
  }
};

struct CodeValueContainerBuilder {
  flatbuffers::FlatBufferBuilder &fbb_;
  flatbuffers::uoffset_t start_;
  void add_TableCode(flatbuffers::Offset<flatbuffers::Vector<int32_t>> TableCode) {
    fbb_.AddOffset(CodeValueContainer::VT_TABLECODE, TableCode);
  }
  explicit CodeValueContainerBuilder(flatbuffers::FlatBufferBuilder &_fbb)
        : fbb_(_fbb) {
    start_ = fbb_.StartTable();
  }
  CodeValueContainerBuilder &operator=(const CodeValueContainerBuilder &);
  flatbuffers::Offset<CodeValueContainer> Finish() {
    const auto end = fbb_.EndTable(start_);
    auto o = flatbuffers::Offset<CodeValueContainer>(end);
    return o;
  }
};

inline flatbuffers::Offset<CodeValueContainer> CreateCodeValueContainer(
    flatbuffers::FlatBufferBuilder &_fbb,
    flatbuffers::Offset<flatbuffers::Vector<int32_t>> TableCode = 0) {
  CodeValueContainerBuilder builder_(_fbb);
  builder_.add_TableCode(TableCode);
  return builder_.Finish();
}

inline flatbuffers::Offset<CodeValueContainer> CreateCodeValueContainerDirect(
    flatbuffers::FlatBufferBuilder &_fbb,
    const std::vector<int32_t> *TableCode = nullptr) {
  auto TableCode__ = TableCode ? _fbb.CreateVector<int32_t>(*TableCode) : 0;
  return ss::ssfb2::CreateCodeValueContainer(
      _fbb,
      TableCode__);
}

struct ContainerStatus FLATBUFFERS_FINAL_CLASS : private flatbuffers::Table {
  enum FlatBuffersVTableOffset FLATBUFFERS_VTABLE_UNDERLYING_TYPE {
    VT_TYPEPACK = 4,
    VT_TABLECODEVALUE = 6,
    VT_TABLEVALUE = 8
  };
  KindTypePack TypePack() const {
    return static_cast<KindTypePack>(GetField<int16_t>(VT_TYPEPACK, 0));
  }
  const flatbuffers::Vector<flatbuffers::Offset<CodeValueContainer>> *TableCodeValue() const {
    return GetPointer<const flatbuffers::Vector<flatbuffers::Offset<CodeValueContainer>> *>(VT_TABLECODEVALUE);
  }
  const flatbuffers::Vector<int32_t> *TableValue() const {
    return GetPointer<const flatbuffers::Vector<int32_t> *>(VT_TABLEVALUE);
  }
  bool Verify(flatbuffers::Verifier &verifier) const {
    return VerifyTableStart(verifier) &&
           VerifyField<int16_t>(verifier, VT_TYPEPACK) &&
           VerifyOffset(verifier, VT_TABLECODEVALUE) &&
           verifier.VerifyVector(TableCodeValue()) &&
           verifier.VerifyVectorOfTables(TableCodeValue()) &&
           VerifyOffset(verifier, VT_TABLEVALUE) &&
           verifier.VerifyVector(TableValue()) &&
           verifier.EndTable();
  }
};

struct ContainerStatusBuilder {
  flatbuffers::FlatBufferBuilder &fbb_;
  flatbuffers::uoffset_t start_;
  void add_TypePack(KindTypePack TypePack) {
    fbb_.AddElement<int16_t>(ContainerStatus::VT_TYPEPACK, static_cast<int16_t>(TypePack), 0);
  }
  void add_TableCodeValue(flatbuffers::Offset<flatbuffers::Vector<flatbuffers::Offset<CodeValueContainer>>> TableCodeValue) {
    fbb_.AddOffset(ContainerStatus::VT_TABLECODEVALUE, TableCodeValue);
  }
  void add_TableValue(flatbuffers::Offset<flatbuffers::Vector<int32_t>> TableValue) {
    fbb_.AddOffset(ContainerStatus::VT_TABLEVALUE, TableValue);
  }
  explicit ContainerStatusBuilder(flatbuffers::FlatBufferBuilder &_fbb)
        : fbb_(_fbb) {
    start_ = fbb_.StartTable();
  }
  ContainerStatusBuilder &operator=(const ContainerStatusBuilder &);
  flatbuffers::Offset<ContainerStatus> Finish() {
    const auto end = fbb_.EndTable(start_);
    auto o = flatbuffers::Offset<ContainerStatus>(end);
    return o;
  }
};

inline flatbuffers::Offset<ContainerStatus> CreateContainerStatus(
    flatbuffers::FlatBufferBuilder &_fbb,
    KindTypePack TypePack = KindTypePack_STANDARD_UNCOMPRESSED,
    flatbuffers::Offset<flatbuffers::Vector<flatbuffers::Offset<CodeValueContainer>>> TableCodeValue = 0,
    flatbuffers::Offset<flatbuffers::Vector<int32_t>> TableValue = 0) {
  ContainerStatusBuilder builder_(_fbb);
  builder_.add_TableValue(TableValue);
  builder_.add_TableCodeValue(TableCodeValue);
  builder_.add_TypePack(TypePack);
  return builder_.Finish();
}

inline flatbuffers::Offset<ContainerStatus> CreateContainerStatusDirect(
    flatbuffers::FlatBufferBuilder &_fbb,
    KindTypePack TypePack = KindTypePack_STANDARD_UNCOMPRESSED,
    const std::vector<flatbuffers::Offset<CodeValueContainer>> *TableCodeValue = nullptr,
    const std::vector<int32_t> *TableValue = nullptr) {
  auto TableCodeValue__ = TableCodeValue ? _fbb.CreateVector<flatbuffers::Offset<CodeValueContainer>>(*TableCodeValue) : 0;
  auto TableValue__ = TableValue ? _fbb.CreateVector<int32_t>(*TableValue) : 0;
  return ss::ssfb2::CreateContainerStatus(
      _fbb,
      TypePack,
      TableCodeValue__,
      TableValue__);
}

struct ContainerCell FLATBUFFERS_FINAL_CLASS : private flatbuffers::Table {
  enum FlatBuffersVTableOffset FLATBUFFERS_VTABLE_UNDERLYING_TYPE {
    VT_TYPEPACK = 4,
    VT_TABLECODEVALUE = 6,
    VT_TABLEVALUE = 8
  };
  KindTypePack TypePack() const {
    return static_cast<KindTypePack>(GetField<int16_t>(VT_TYPEPACK, 0));
  }
  const flatbuffers::Vector<flatbuffers::Offset<CodeValueContainer>> *TableCodeValue() const {
    return GetPointer<const flatbuffers::Vector<flatbuffers::Offset<CodeValueContainer>> *>(VT_TABLECODEVALUE);
  }
  const flatbuffers::Vector<flatbuffers::Offset<AnimationAttributeCell>> *TableValue() const {
    return GetPointer<const flatbuffers::Vector<flatbuffers::Offset<AnimationAttributeCell>> *>(VT_TABLEVALUE);
  }
  bool Verify(flatbuffers::Verifier &verifier) const {
    return VerifyTableStart(verifier) &&
           VerifyField<int16_t>(verifier, VT_TYPEPACK) &&
           VerifyOffset(verifier, VT_TABLECODEVALUE) &&
           verifier.VerifyVector(TableCodeValue()) &&
           verifier.VerifyVectorOfTables(TableCodeValue()) &&
           VerifyOffset(verifier, VT_TABLEVALUE) &&
           verifier.VerifyVector(TableValue()) &&
           verifier.VerifyVectorOfTables(TableValue()) &&
           verifier.EndTable();
  }
};

struct ContainerCellBuilder {
  flatbuffers::FlatBufferBuilder &fbb_;
  flatbuffers::uoffset_t start_;
  void add_TypePack(KindTypePack TypePack) {
    fbb_.AddElement<int16_t>(ContainerCell::VT_TYPEPACK, static_cast<int16_t>(TypePack), 0);
  }
  void add_TableCodeValue(flatbuffers::Offset<flatbuffers::Vector<flatbuffers::Offset<CodeValueContainer>>> TableCodeValue) {
    fbb_.AddOffset(ContainerCell::VT_TABLECODEVALUE, TableCodeValue);
  }
  void add_TableValue(flatbuffers::Offset<flatbuffers::Vector<flatbuffers::Offset<AnimationAttributeCell>>> TableValue) {
    fbb_.AddOffset(ContainerCell::VT_TABLEVALUE, TableValue);
  }
  explicit ContainerCellBuilder(flatbuffers::FlatBufferBuilder &_fbb)
        : fbb_(_fbb) {
    start_ = fbb_.StartTable();
  }
  ContainerCellBuilder &operator=(const ContainerCellBuilder &);
  flatbuffers::Offset<ContainerCell> Finish() {
    const auto end = fbb_.EndTable(start_);
    auto o = flatbuffers::Offset<ContainerCell>(end);
    return o;
  }
};

inline flatbuffers::Offset<ContainerCell> CreateContainerCell(
    flatbuffers::FlatBufferBuilder &_fbb,
    KindTypePack TypePack = KindTypePack_STANDARD_UNCOMPRESSED,
    flatbuffers::Offset<flatbuffers::Vector<flatbuffers::Offset<CodeValueContainer>>> TableCodeValue = 0,
    flatbuffers::Offset<flatbuffers::Vector<flatbuffers::Offset<AnimationAttributeCell>>> TableValue = 0) {
  ContainerCellBuilder builder_(_fbb);
  builder_.add_TableValue(TableValue);
  builder_.add_TableCodeValue(TableCodeValue);
  builder_.add_TypePack(TypePack);
  return builder_.Finish();
}

inline flatbuffers::Offset<ContainerCell> CreateContainerCellDirect(
    flatbuffers::FlatBufferBuilder &_fbb,
    KindTypePack TypePack = KindTypePack_STANDARD_UNCOMPRESSED,
    const std::vector<flatbuffers::Offset<CodeValueContainer>> *TableCodeValue = nullptr,
    const std::vector<flatbuffers::Offset<AnimationAttributeCell>> *TableValue = nullptr) {
  auto TableCodeValue__ = TableCodeValue ? _fbb.CreateVector<flatbuffers::Offset<CodeValueContainer>>(*TableCodeValue) : 0;
  auto TableValue__ = TableValue ? _fbb.CreateVector<flatbuffers::Offset<AnimationAttributeCell>>(*TableValue) : 0;
  return ss::ssfb2::CreateContainerCell(
      _fbb,
      TypePack,
      TableCodeValue__,
      TableValue__);
}

struct ContainerVector3 FLATBUFFERS_FINAL_CLASS : private flatbuffers::Table {
  enum FlatBuffersVTableOffset FLATBUFFERS_VTABLE_UNDERLYING_TYPE {
    VT_TYPEPACK = 4,
    VT_TABLECODEVALUE = 6,
    VT_TABLEVALUE = 8
  };
  KindTypePack TypePack() const {
    return static_cast<KindTypePack>(GetField<int16_t>(VT_TYPEPACK, 0));
  }
  const flatbuffers::Vector<flatbuffers::Offset<CodeValueContainer>> *TableCodeValue() const {
    return GetPointer<const flatbuffers::Vector<flatbuffers::Offset<CodeValueContainer>> *>(VT_TABLECODEVALUE);
  }
  const flatbuffers::Vector<flatbuffers::Offset<Vector3>> *TableValue() const {
    return GetPointer<const flatbuffers::Vector<flatbuffers::Offset<Vector3>> *>(VT_TABLEVALUE);
  }
  bool Verify(flatbuffers::Verifier &verifier) const {
    return VerifyTableStart(verifier) &&
           VerifyField<int16_t>(verifier, VT_TYPEPACK) &&
           VerifyOffset(verifier, VT_TABLECODEVALUE) &&
           verifier.VerifyVector(TableCodeValue()) &&
           verifier.VerifyVectorOfTables(TableCodeValue()) &&
           VerifyOffset(verifier, VT_TABLEVALUE) &&
           verifier.VerifyVector(TableValue()) &&
           verifier.VerifyVectorOfTables(TableValue()) &&
           verifier.EndTable();
  }
};

struct ContainerVector3Builder {
  flatbuffers::FlatBufferBuilder &fbb_;
  flatbuffers::uoffset_t start_;
  void add_TypePack(KindTypePack TypePack) {
    fbb_.AddElement<int16_t>(ContainerVector3::VT_TYPEPACK, static_cast<int16_t>(TypePack), 0);
  }
  void add_TableCodeValue(flatbuffers::Offset<flatbuffers::Vector<flatbuffers::Offset<CodeValueContainer>>> TableCodeValue) {
    fbb_.AddOffset(ContainerVector3::VT_TABLECODEVALUE, TableCodeValue);
  }
  void add_TableValue(flatbuffers::Offset<flatbuffers::Vector<flatbuffers::Offset<Vector3>>> TableValue) {
    fbb_.AddOffset(ContainerVector3::VT_TABLEVALUE, TableValue);
  }
  explicit ContainerVector3Builder(flatbuffers::FlatBufferBuilder &_fbb)
        : fbb_(_fbb) {
    start_ = fbb_.StartTable();
  }
  ContainerVector3Builder &operator=(const ContainerVector3Builder &);
  flatbuffers::Offset<ContainerVector3> Finish() {
    const auto end = fbb_.EndTable(start_);
    auto o = flatbuffers::Offset<ContainerVector3>(end);
    return o;
  }
};

inline flatbuffers::Offset<ContainerVector3> CreateContainerVector3(
    flatbuffers::FlatBufferBuilder &_fbb,
    KindTypePack TypePack = KindTypePack_STANDARD_UNCOMPRESSED,
    flatbuffers::Offset<flatbuffers::Vector<flatbuffers::Offset<CodeValueContainer>>> TableCodeValue = 0,
    flatbuffers::Offset<flatbuffers::Vector<flatbuffers::Offset<Vector3>>> TableValue = 0) {
  ContainerVector3Builder builder_(_fbb);
  builder_.add_TableValue(TableValue);
  builder_.add_TableCodeValue(TableCodeValue);
  builder_.add_TypePack(TypePack);
  return builder_.Finish();
}

inline flatbuffers::Offset<ContainerVector3> CreateContainerVector3Direct(
    flatbuffers::FlatBufferBuilder &_fbb,
    KindTypePack TypePack = KindTypePack_STANDARD_UNCOMPRESSED,
    const std::vector<flatbuffers::Offset<CodeValueContainer>> *TableCodeValue = nullptr,
    const std::vector<flatbuffers::Offset<Vector3>> *TableValue = nullptr) {
  auto TableCodeValue__ = TableCodeValue ? _fbb.CreateVector<flatbuffers::Offset<CodeValueContainer>>(*TableCodeValue) : 0;
  auto TableValue__ = TableValue ? _fbb.CreateVector<flatbuffers::Offset<Vector3>>(*TableValue) : 0;
  return ss::ssfb2::CreateContainerVector3(
      _fbb,
      TypePack,
      TableCodeValue__,
      TableValue__);
}

struct ContainerVector2 FLATBUFFERS_FINAL_CLASS : private flatbuffers::Table {
  enum FlatBuffersVTableOffset FLATBUFFERS_VTABLE_UNDERLYING_TYPE {
    VT_TYPEPACK = 4,
    VT_TABLECODEVALUE = 6,
    VT_TABLEVALUE = 8
  };
  KindTypePack TypePack() const {
    return static_cast<KindTypePack>(GetField<int16_t>(VT_TYPEPACK, 0));
  }
  const flatbuffers::Vector<flatbuffers::Offset<CodeValueContainer>> *TableCodeValue() const {
    return GetPointer<const flatbuffers::Vector<flatbuffers::Offset<CodeValueContainer>> *>(VT_TABLECODEVALUE);
  }
  const flatbuffers::Vector<flatbuffers::Offset<Vector2>> *TableValue() const {
    return GetPointer<const flatbuffers::Vector<flatbuffers::Offset<Vector2>> *>(VT_TABLEVALUE);
  }
  bool Verify(flatbuffers::Verifier &verifier) const {
    return VerifyTableStart(verifier) &&
           VerifyField<int16_t>(verifier, VT_TYPEPACK) &&
           VerifyOffset(verifier, VT_TABLECODEVALUE) &&
           verifier.VerifyVector(TableCodeValue()) &&
           verifier.VerifyVectorOfTables(TableCodeValue()) &&
           VerifyOffset(verifier, VT_TABLEVALUE) &&
           verifier.VerifyVector(TableValue()) &&
           verifier.VerifyVectorOfTables(TableValue()) &&
           verifier.EndTable();
  }
};

struct ContainerVector2Builder {
  flatbuffers::FlatBufferBuilder &fbb_;
  flatbuffers::uoffset_t start_;
  void add_TypePack(KindTypePack TypePack) {
    fbb_.AddElement<int16_t>(ContainerVector2::VT_TYPEPACK, static_cast<int16_t>(TypePack), 0);
  }
  void add_TableCodeValue(flatbuffers::Offset<flatbuffers::Vector<flatbuffers::Offset<CodeValueContainer>>> TableCodeValue) {
    fbb_.AddOffset(ContainerVector2::VT_TABLECODEVALUE, TableCodeValue);
  }
  void add_TableValue(flatbuffers::Offset<flatbuffers::Vector<flatbuffers::Offset<Vector2>>> TableValue) {
    fbb_.AddOffset(ContainerVector2::VT_TABLEVALUE, TableValue);
  }
  explicit ContainerVector2Builder(flatbuffers::FlatBufferBuilder &_fbb)
        : fbb_(_fbb) {
    start_ = fbb_.StartTable();
  }
  ContainerVector2Builder &operator=(const ContainerVector2Builder &);
  flatbuffers::Offset<ContainerVector2> Finish() {
    const auto end = fbb_.EndTable(start_);
    auto o = flatbuffers::Offset<ContainerVector2>(end);
    return o;
  }
};

inline flatbuffers::Offset<ContainerVector2> CreateContainerVector2(
    flatbuffers::FlatBufferBuilder &_fbb,
    KindTypePack TypePack = KindTypePack_STANDARD_UNCOMPRESSED,
    flatbuffers::Offset<flatbuffers::Vector<flatbuffers::Offset<CodeValueContainer>>> TableCodeValue = 0,
    flatbuffers::Offset<flatbuffers::Vector<flatbuffers::Offset<Vector2>>> TableValue = 0) {
  ContainerVector2Builder builder_(_fbb);
  builder_.add_TableValue(TableValue);
  builder_.add_TableCodeValue(TableCodeValue);
  builder_.add_TypePack(TypePack);
  return builder_.Finish();
}

inline flatbuffers::Offset<ContainerVector2> CreateContainerVector2Direct(
    flatbuffers::FlatBufferBuilder &_fbb,
    KindTypePack TypePack = KindTypePack_STANDARD_UNCOMPRESSED,
    const std::vector<flatbuffers::Offset<CodeValueContainer>> *TableCodeValue = nullptr,
    const std::vector<flatbuffers::Offset<Vector2>> *TableValue = nullptr) {
  auto TableCodeValue__ = TableCodeValue ? _fbb.CreateVector<flatbuffers::Offset<CodeValueContainer>>(*TableCodeValue) : 0;
  auto TableValue__ = TableValue ? _fbb.CreateVector<flatbuffers::Offset<Vector2>>(*TableValue) : 0;
  return ss::ssfb2::CreateContainerVector2(
      _fbb,
      TypePack,
      TableCodeValue__,
      TableValue__);
}

struct ContainerFloat FLATBUFFERS_FINAL_CLASS : private flatbuffers::Table {
  enum FlatBuffersVTableOffset FLATBUFFERS_VTABLE_UNDERLYING_TYPE {
    VT_TYPEPACK = 4,
    VT_TABLECODEVALUE = 6,
    VT_TABLEVALUE = 8
  };
  KindTypePack TypePack() const {
    return static_cast<KindTypePack>(GetField<int16_t>(VT_TYPEPACK, 0));
  }
  const flatbuffers::Vector<flatbuffers::Offset<CodeValueContainer>> *TableCodeValue() const {
    return GetPointer<const flatbuffers::Vector<flatbuffers::Offset<CodeValueContainer>> *>(VT_TABLECODEVALUE);
  }
  const flatbuffers::Vector<float> *TableValue() const {
    return GetPointer<const flatbuffers::Vector<float> *>(VT_TABLEVALUE);
  }
  bool Verify(flatbuffers::Verifier &verifier) const {
    return VerifyTableStart(verifier) &&
           VerifyField<int16_t>(verifier, VT_TYPEPACK) &&
           VerifyOffset(verifier, VT_TABLECODEVALUE) &&
           verifier.VerifyVector(TableCodeValue()) &&
           verifier.VerifyVectorOfTables(TableCodeValue()) &&
           VerifyOffset(verifier, VT_TABLEVALUE) &&
           verifier.VerifyVector(TableValue()) &&
           verifier.EndTable();
  }
};

struct ContainerFloatBuilder {
  flatbuffers::FlatBufferBuilder &fbb_;
  flatbuffers::uoffset_t start_;
  void add_TypePack(KindTypePack TypePack) {
    fbb_.AddElement<int16_t>(ContainerFloat::VT_TYPEPACK, static_cast<int16_t>(TypePack), 0);
  }
  void add_TableCodeValue(flatbuffers::Offset<flatbuffers::Vector<flatbuffers::Offset<CodeValueContainer>>> TableCodeValue) {
    fbb_.AddOffset(ContainerFloat::VT_TABLECODEVALUE, TableCodeValue);
  }
  void add_TableValue(flatbuffers::Offset<flatbuffers::Vector<float>> TableValue) {
    fbb_.AddOffset(ContainerFloat::VT_TABLEVALUE, TableValue);
  }
  explicit ContainerFloatBuilder(flatbuffers::FlatBufferBuilder &_fbb)
        : fbb_(_fbb) {
    start_ = fbb_.StartTable();
  }
  ContainerFloatBuilder &operator=(const ContainerFloatBuilder &);
  flatbuffers::Offset<ContainerFloat> Finish() {
    const auto end = fbb_.EndTable(start_);
    auto o = flatbuffers::Offset<ContainerFloat>(end);
    return o;
  }
};

inline flatbuffers::Offset<ContainerFloat> CreateContainerFloat(
    flatbuffers::FlatBufferBuilder &_fbb,
    KindTypePack TypePack = KindTypePack_STANDARD_UNCOMPRESSED,
    flatbuffers::Offset<flatbuffers::Vector<flatbuffers::Offset<CodeValueContainer>>> TableCodeValue = 0,
    flatbuffers::Offset<flatbuffers::Vector<float>> TableValue = 0) {
  ContainerFloatBuilder builder_(_fbb);
  builder_.add_TableValue(TableValue);
  builder_.add_TableCodeValue(TableCodeValue);
  builder_.add_TypePack(TypePack);
  return builder_.Finish();
}

inline flatbuffers::Offset<ContainerFloat> CreateContainerFloatDirect(
    flatbuffers::FlatBufferBuilder &_fbb,
    KindTypePack TypePack = KindTypePack_STANDARD_UNCOMPRESSED,
    const std::vector<flatbuffers::Offset<CodeValueContainer>> *TableCodeValue = nullptr,
    const std::vector<float> *TableValue = nullptr) {
  auto TableCodeValue__ = TableCodeValue ? _fbb.CreateVector<flatbuffers::Offset<CodeValueContainer>>(*TableCodeValue) : 0;
  auto TableValue__ = TableValue ? _fbb.CreateVector<float>(*TableValue) : 0;
  return ss::ssfb2::CreateContainerFloat(
      _fbb,
      TypePack,
      TableCodeValue__,
      TableValue__);
}

struct ContainerInt FLATBUFFERS_FINAL_CLASS : private flatbuffers::Table {
  enum FlatBuffersVTableOffset FLATBUFFERS_VTABLE_UNDERLYING_TYPE {
    VT_TYPEPACK = 4,
    VT_TABLECODEVALUE = 6,
    VT_TABLEVALUE = 8
  };
  KindTypePack TypePack() const {
    return static_cast<KindTypePack>(GetField<int16_t>(VT_TYPEPACK, 0));
  }
  const flatbuffers::Vector<flatbuffers::Offset<CodeValueContainer>> *TableCodeValue() const {
    return GetPointer<const flatbuffers::Vector<flatbuffers::Offset<CodeValueContainer>> *>(VT_TABLECODEVALUE);
  }
  const flatbuffers::Vector<int32_t> *TableValue() const {
    return GetPointer<const flatbuffers::Vector<int32_t> *>(VT_TABLEVALUE);
  }
  bool Verify(flatbuffers::Verifier &verifier) const {
    return VerifyTableStart(verifier) &&
           VerifyField<int16_t>(verifier, VT_TYPEPACK) &&
           VerifyOffset(verifier, VT_TABLECODEVALUE) &&
           verifier.VerifyVector(TableCodeValue()) &&
           verifier.VerifyVectorOfTables(TableCodeValue()) &&
           VerifyOffset(verifier, VT_TABLEVALUE) &&
           verifier.VerifyVector(TableValue()) &&
           verifier.EndTable();
  }
};

struct ContainerIntBuilder {
  flatbuffers::FlatBufferBuilder &fbb_;
  flatbuffers::uoffset_t start_;
  void add_TypePack(KindTypePack TypePack) {
    fbb_.AddElement<int16_t>(ContainerInt::VT_TYPEPACK, static_cast<int16_t>(TypePack), 0);
  }
  void add_TableCodeValue(flatbuffers::Offset<flatbuffers::Vector<flatbuffers::Offset<CodeValueContainer>>> TableCodeValue) {
    fbb_.AddOffset(ContainerInt::VT_TABLECODEVALUE, TableCodeValue);
  }
  void add_TableValue(flatbuffers::Offset<flatbuffers::Vector<int32_t>> TableValue) {
    fbb_.AddOffset(ContainerInt::VT_TABLEVALUE, TableValue);
  }
  explicit ContainerIntBuilder(flatbuffers::FlatBufferBuilder &_fbb)
        : fbb_(_fbb) {
    start_ = fbb_.StartTable();
  }
  ContainerIntBuilder &operator=(const ContainerIntBuilder &);
  flatbuffers::Offset<ContainerInt> Finish() {
    const auto end = fbb_.EndTable(start_);
    auto o = flatbuffers::Offset<ContainerInt>(end);
    return o;
  }
};

inline flatbuffers::Offset<ContainerInt> CreateContainerInt(
    flatbuffers::FlatBufferBuilder &_fbb,
    KindTypePack TypePack = KindTypePack_STANDARD_UNCOMPRESSED,
    flatbuffers::Offset<flatbuffers::Vector<flatbuffers::Offset<CodeValueContainer>>> TableCodeValue = 0,
    flatbuffers::Offset<flatbuffers::Vector<int32_t>> TableValue = 0) {
  ContainerIntBuilder builder_(_fbb);
  builder_.add_TableValue(TableValue);
  builder_.add_TableCodeValue(TableCodeValue);
  builder_.add_TypePack(TypePack);
  return builder_.Finish();
}

inline flatbuffers::Offset<ContainerInt> CreateContainerIntDirect(
    flatbuffers::FlatBufferBuilder &_fbb,
    KindTypePack TypePack = KindTypePack_STANDARD_UNCOMPRESSED,
    const std::vector<flatbuffers::Offset<CodeValueContainer>> *TableCodeValue = nullptr,
    const std::vector<int32_t> *TableValue = nullptr) {
  auto TableCodeValue__ = TableCodeValue ? _fbb.CreateVector<flatbuffers::Offset<CodeValueContainer>>(*TableCodeValue) : 0;
  auto TableValue__ = TableValue ? _fbb.CreateVector<int32_t>(*TableValue) : 0;
  return ss::ssfb2::CreateContainerInt(
      _fbb,
      TypePack,
      TableCodeValue__,
      TableValue__);
}

struct ContainerPartsColor FLATBUFFERS_FINAL_CLASS : private flatbuffers::Table {
  enum FlatBuffersVTableOffset FLATBUFFERS_VTABLE_UNDERLYING_TYPE {
    VT_TYPEPACK = 4,
    VT_TABLECODEVALUE = 6,
    VT_TABLEVALUE = 8
  };
  KindTypePack TypePack() const {
    return static_cast<KindTypePack>(GetField<int16_t>(VT_TYPEPACK, 0));
  }
  const flatbuffers::Vector<flatbuffers::Offset<CodeValueContainer>> *TableCodeValue() const {
    return GetPointer<const flatbuffers::Vector<flatbuffers::Offset<CodeValueContainer>> *>(VT_TABLECODEVALUE);
  }
  const flatbuffers::Vector<flatbuffers::Offset<AnimationAttributePartsColor>> *TableValue() const {
    return GetPointer<const flatbuffers::Vector<flatbuffers::Offset<AnimationAttributePartsColor>> *>(VT_TABLEVALUE);
  }
  bool Verify(flatbuffers::Verifier &verifier) const {
    return VerifyTableStart(verifier) &&
           VerifyField<int16_t>(verifier, VT_TYPEPACK) &&
           VerifyOffset(verifier, VT_TABLECODEVALUE) &&
           verifier.VerifyVector(TableCodeValue()) &&
           verifier.VerifyVectorOfTables(TableCodeValue()) &&
           VerifyOffset(verifier, VT_TABLEVALUE) &&
           verifier.VerifyVector(TableValue()) &&
           verifier.VerifyVectorOfTables(TableValue()) &&
           verifier.EndTable();
  }
};

struct ContainerPartsColorBuilder {
  flatbuffers::FlatBufferBuilder &fbb_;
  flatbuffers::uoffset_t start_;
  void add_TypePack(KindTypePack TypePack) {
    fbb_.AddElement<int16_t>(ContainerPartsColor::VT_TYPEPACK, static_cast<int16_t>(TypePack), 0);
  }
  void add_TableCodeValue(flatbuffers::Offset<flatbuffers::Vector<flatbuffers::Offset<CodeValueContainer>>> TableCodeValue) {
    fbb_.AddOffset(ContainerPartsColor::VT_TABLECODEVALUE, TableCodeValue);
  }
  void add_TableValue(flatbuffers::Offset<flatbuffers::Vector<flatbuffers::Offset<AnimationAttributePartsColor>>> TableValue) {
    fbb_.AddOffset(ContainerPartsColor::VT_TABLEVALUE, TableValue);
  }
  explicit ContainerPartsColorBuilder(flatbuffers::FlatBufferBuilder &_fbb)
        : fbb_(_fbb) {
    start_ = fbb_.StartTable();
  }
  ContainerPartsColorBuilder &operator=(const ContainerPartsColorBuilder &);
  flatbuffers::Offset<ContainerPartsColor> Finish() {
    const auto end = fbb_.EndTable(start_);
    auto o = flatbuffers::Offset<ContainerPartsColor>(end);
    return o;
  }
};

inline flatbuffers::Offset<ContainerPartsColor> CreateContainerPartsColor(
    flatbuffers::FlatBufferBuilder &_fbb,
    KindTypePack TypePack = KindTypePack_STANDARD_UNCOMPRESSED,
    flatbuffers::Offset<flatbuffers::Vector<flatbuffers::Offset<CodeValueContainer>>> TableCodeValue = 0,
    flatbuffers::Offset<flatbuffers::Vector<flatbuffers::Offset<AnimationAttributePartsColor>>> TableValue = 0) {
  ContainerPartsColorBuilder builder_(_fbb);
  builder_.add_TableValue(TableValue);
  builder_.add_TableCodeValue(TableCodeValue);
  builder_.add_TypePack(TypePack);
  return builder_.Finish();
}

inline flatbuffers::Offset<ContainerPartsColor> CreateContainerPartsColorDirect(
    flatbuffers::FlatBufferBuilder &_fbb,
    KindTypePack TypePack = KindTypePack_STANDARD_UNCOMPRESSED,
    const std::vector<flatbuffers::Offset<CodeValueContainer>> *TableCodeValue = nullptr,
    const std::vector<flatbuffers::Offset<AnimationAttributePartsColor>> *TableValue = nullptr) {
  auto TableCodeValue__ = TableCodeValue ? _fbb.CreateVector<flatbuffers::Offset<CodeValueContainer>>(*TableCodeValue) : 0;
  auto TableValue__ = TableValue ? _fbb.CreateVector<flatbuffers::Offset<AnimationAttributePartsColor>>(*TableValue) : 0;
  return ss::ssfb2::CreateContainerPartsColor(
      _fbb,
      TypePack,
      TableCodeValue__,
      TableValue__);
}

struct VertexCorrection FLATBUFFERS_FINAL_CLASS : private flatbuffers::Table {
  enum FlatBuffersVTableOffset FLATBUFFERS_VTABLE_UNDERLYING_TYPE {
    VT_COORDINATE = 4
  };
  const flatbuffers::Vector<flatbuffers::Offset<Vector2>> *Coordinate() const {
    return GetPointer<const flatbuffers::Vector<flatbuffers::Offset<Vector2>> *>(VT_COORDINATE);
  }
  bool Verify(flatbuffers::Verifier &verifier) const {
    return VerifyTableStart(verifier) &&
           VerifyOffset(verifier, VT_COORDINATE) &&
           verifier.VerifyVector(Coordinate()) &&
           verifier.VerifyVectorOfTables(Coordinate()) &&
           verifier.EndTable();
  }
};

struct VertexCorrectionBuilder {
  flatbuffers::FlatBufferBuilder &fbb_;
  flatbuffers::uoffset_t start_;
  void add_Coordinate(flatbuffers::Offset<flatbuffers::Vector<flatbuffers::Offset<Vector2>>> Coordinate) {
    fbb_.AddOffset(VertexCorrection::VT_COORDINATE, Coordinate);
  }
  explicit VertexCorrectionBuilder(flatbuffers::FlatBufferBuilder &_fbb)
        : fbb_(_fbb) {
    start_ = fbb_.StartTable();
  }
  VertexCorrectionBuilder &operator=(const VertexCorrectionBuilder &);
  flatbuffers::Offset<VertexCorrection> Finish() {
    const auto end = fbb_.EndTable(start_);
    auto o = flatbuffers::Offset<VertexCorrection>(end);
    return o;
  }
};

inline flatbuffers::Offset<VertexCorrection> CreateVertexCorrection(
    flatbuffers::FlatBufferBuilder &_fbb,
    flatbuffers::Offset<flatbuffers::Vector<flatbuffers::Offset<Vector2>>> Coordinate = 0) {
  VertexCorrectionBuilder builder_(_fbb);
  builder_.add_Coordinate(Coordinate);
  return builder_.Finish();
}

inline flatbuffers::Offset<VertexCorrection> CreateVertexCorrectionDirect(
    flatbuffers::FlatBufferBuilder &_fbb,
    const std::vector<flatbuffers::Offset<Vector2>> *Coordinate = nullptr) {
  auto Coordinate__ = Coordinate ? _fbb.CreateVector<flatbuffers::Offset<Vector2>>(*Coordinate) : 0;
  return ss::ssfb2::CreateVertexCorrection(
      _fbb,
      Coordinate__);
}

struct ContainerVertexCorrection FLATBUFFERS_FINAL_CLASS : private flatbuffers::Table {
  enum FlatBuffersVTableOffset FLATBUFFERS_VTABLE_UNDERLYING_TYPE {
    VT_TYPEPACK = 4,
    VT_TABLECODEVALUE = 6,
    VT_TABLEVALUE = 8
  };
  KindTypePack TypePack() const {
    return static_cast<KindTypePack>(GetField<int16_t>(VT_TYPEPACK, 0));
  }
  const flatbuffers::Vector<flatbuffers::Offset<CodeValueContainer>> *TableCodeValue() const {
    return GetPointer<const flatbuffers::Vector<flatbuffers::Offset<CodeValueContainer>> *>(VT_TABLECODEVALUE);
  }
  const flatbuffers::Vector<flatbuffers::Offset<VertexCorrection>> *TableValue() const {
    return GetPointer<const flatbuffers::Vector<flatbuffers::Offset<VertexCorrection>> *>(VT_TABLEVALUE);
  }
  bool Verify(flatbuffers::Verifier &verifier) const {
    return VerifyTableStart(verifier) &&
           VerifyField<int16_t>(verifier, VT_TYPEPACK) &&
           VerifyOffset(verifier, VT_TABLECODEVALUE) &&
           verifier.VerifyVector(TableCodeValue()) &&
           verifier.VerifyVectorOfTables(TableCodeValue()) &&
           VerifyOffset(verifier, VT_TABLEVALUE) &&
           verifier.VerifyVector(TableValue()) &&
           verifier.VerifyVectorOfTables(TableValue()) &&
           verifier.EndTable();
  }
};

struct ContainerVertexCorrectionBuilder {
  flatbuffers::FlatBufferBuilder &fbb_;
  flatbuffers::uoffset_t start_;
  void add_TypePack(KindTypePack TypePack) {
    fbb_.AddElement<int16_t>(ContainerVertexCorrection::VT_TYPEPACK, static_cast<int16_t>(TypePack), 0);
  }
  void add_TableCodeValue(flatbuffers::Offset<flatbuffers::Vector<flatbuffers::Offset<CodeValueContainer>>> TableCodeValue) {
    fbb_.AddOffset(ContainerVertexCorrection::VT_TABLECODEVALUE, TableCodeValue);
  }
  void add_TableValue(flatbuffers::Offset<flatbuffers::Vector<flatbuffers::Offset<VertexCorrection>>> TableValue) {
    fbb_.AddOffset(ContainerVertexCorrection::VT_TABLEVALUE, TableValue);
  }
  explicit ContainerVertexCorrectionBuilder(flatbuffers::FlatBufferBuilder &_fbb)
        : fbb_(_fbb) {
    start_ = fbb_.StartTable();
  }
  ContainerVertexCorrectionBuilder &operator=(const ContainerVertexCorrectionBuilder &);
  flatbuffers::Offset<ContainerVertexCorrection> Finish() {
    const auto end = fbb_.EndTable(start_);
    auto o = flatbuffers::Offset<ContainerVertexCorrection>(end);
    return o;
  }
};

inline flatbuffers::Offset<ContainerVertexCorrection> CreateContainerVertexCorrection(
    flatbuffers::FlatBufferBuilder &_fbb,
    KindTypePack TypePack = KindTypePack_STANDARD_UNCOMPRESSED,
    flatbuffers::Offset<flatbuffers::Vector<flatbuffers::Offset<CodeValueContainer>>> TableCodeValue = 0,
    flatbuffers::Offset<flatbuffers::Vector<flatbuffers::Offset<VertexCorrection>>> TableValue = 0) {
  ContainerVertexCorrectionBuilder builder_(_fbb);
  builder_.add_TableValue(TableValue);
  builder_.add_TableCodeValue(TableCodeValue);
  builder_.add_TypePack(TypePack);
  return builder_.Finish();
}

inline flatbuffers::Offset<ContainerVertexCorrection> CreateContainerVertexCorrectionDirect(
    flatbuffers::FlatBufferBuilder &_fbb,
    KindTypePack TypePack = KindTypePack_STANDARD_UNCOMPRESSED,
    const std::vector<flatbuffers::Offset<CodeValueContainer>> *TableCodeValue = nullptr,
    const std::vector<flatbuffers::Offset<VertexCorrection>> *TableValue = nullptr) {
  auto TableCodeValue__ = TableCodeValue ? _fbb.CreateVector<flatbuffers::Offset<CodeValueContainer>>(*TableCodeValue) : 0;
  auto TableValue__ = TableValue ? _fbb.CreateVector<flatbuffers::Offset<VertexCorrection>>(*TableValue) : 0;
  return ss::ssfb2::CreateContainerVertexCorrection(
      _fbb,
      TypePack,
      TableCodeValue__,
      TableValue__);
}

struct ContainerUserData FLATBUFFERS_FINAL_CLASS : private flatbuffers::Table {
  enum FlatBuffersVTableOffset FLATBUFFERS_VTABLE_UNDERLYING_TYPE {
    VT_TYPEPACK = 4,
    VT_TABLECODEVALUE = 6,
    VT_TABLEVALUE = 8
  };
  KindTypePack TypePack() const {
    return static_cast<KindTypePack>(GetField<int16_t>(VT_TYPEPACK, 0));
  }
  const flatbuffers::Vector<flatbuffers::Offset<CodeValueContainer>> *TableCodeValue() const {
    return GetPointer<const flatbuffers::Vector<flatbuffers::Offset<CodeValueContainer>> *>(VT_TABLECODEVALUE);
  }
  const flatbuffers::Vector<flatbuffers::Offset<UserData>> *TableValue() const {
    return GetPointer<const flatbuffers::Vector<flatbuffers::Offset<UserData>> *>(VT_TABLEVALUE);
  }
  bool Verify(flatbuffers::Verifier &verifier) const {
    return VerifyTableStart(verifier) &&
           VerifyField<int16_t>(verifier, VT_TYPEPACK) &&
           VerifyOffset(verifier, VT_TABLECODEVALUE) &&
           verifier.VerifyVector(TableCodeValue()) &&
           verifier.VerifyVectorOfTables(TableCodeValue()) &&
           VerifyOffset(verifier, VT_TABLEVALUE) &&
           verifier.VerifyVector(TableValue()) &&
           verifier.VerifyVectorOfTables(TableValue()) &&
           verifier.EndTable();
  }
};

struct ContainerUserDataBuilder {
  flatbuffers::FlatBufferBuilder &fbb_;
  flatbuffers::uoffset_t start_;
  void add_TypePack(KindTypePack TypePack) {
    fbb_.AddElement<int16_t>(ContainerUserData::VT_TYPEPACK, static_cast<int16_t>(TypePack), 0);
  }
  void add_TableCodeValue(flatbuffers::Offset<flatbuffers::Vector<flatbuffers::Offset<CodeValueContainer>>> TableCodeValue) {
    fbb_.AddOffset(ContainerUserData::VT_TABLECODEVALUE, TableCodeValue);
  }
  void add_TableValue(flatbuffers::Offset<flatbuffers::Vector<flatbuffers::Offset<UserData>>> TableValue) {
    fbb_.AddOffset(ContainerUserData::VT_TABLEVALUE, TableValue);
  }
  explicit ContainerUserDataBuilder(flatbuffers::FlatBufferBuilder &_fbb)
        : fbb_(_fbb) {
    start_ = fbb_.StartTable();
  }
  ContainerUserDataBuilder &operator=(const ContainerUserDataBuilder &);
  flatbuffers::Offset<ContainerUserData> Finish() {
    const auto end = fbb_.EndTable(start_);
    auto o = flatbuffers::Offset<ContainerUserData>(end);
    return o;
  }
};

inline flatbuffers::Offset<ContainerUserData> CreateContainerUserData(
    flatbuffers::FlatBufferBuilder &_fbb,
    KindTypePack TypePack = KindTypePack_STANDARD_UNCOMPRESSED,
    flatbuffers::Offset<flatbuffers::Vector<flatbuffers::Offset<CodeValueContainer>>> TableCodeValue = 0,
    flatbuffers::Offset<flatbuffers::Vector<flatbuffers::Offset<UserData>>> TableValue = 0) {
  ContainerUserDataBuilder builder_(_fbb);
  builder_.add_TableValue(TableValue);
  builder_.add_TableCodeValue(TableCodeValue);
  builder_.add_TypePack(TypePack);
  return builder_.Finish();
}

inline flatbuffers::Offset<ContainerUserData> CreateContainerUserDataDirect(
    flatbuffers::FlatBufferBuilder &_fbb,
    KindTypePack TypePack = KindTypePack_STANDARD_UNCOMPRESSED,
    const std::vector<flatbuffers::Offset<CodeValueContainer>> *TableCodeValue = nullptr,
    const std::vector<flatbuffers::Offset<UserData>> *TableValue = nullptr) {
  auto TableCodeValue__ = TableCodeValue ? _fbb.CreateVector<flatbuffers::Offset<CodeValueContainer>>(*TableCodeValue) : 0;
  auto TableValue__ = TableValue ? _fbb.CreateVector<flatbuffers::Offset<UserData>>(*TableValue) : 0;
  return ss::ssfb2::CreateContainerUserData(
      _fbb,
      TypePack,
      TableCodeValue__,
      TableValue__);
}

struct AnimationAttributeInstance FLATBUFFERS_FINAL_CLASS : private flatbuffers::Table {
  enum FlatBuffersVTableOffset FLATBUFFERS_VTABLE_UNDERLYING_TYPE {
    VT_FLAGS = 4,
    VT_PLAYCOUNT = 6,
    VT_RATETIME = 8,
    VT_OFFSETSTART = 10,
    VT_OFFSETEND = 12,
    VT_LABELSTART = 14,
    VT_LABELEND = 16
  };
  int32_t Flags() const {
    return GetField<int32_t>(VT_FLAGS, 0);
  }
  int32_t PlayCount() const {
    return GetField<int32_t>(VT_PLAYCOUNT, 0);
  }
  float RateTime() const {
    return GetField<float>(VT_RATETIME, 0.0f);
  }
  int32_t OffsetStart() const {
    return GetField<int32_t>(VT_OFFSETSTART, 0);
  }
  int32_t OffsetEnd() const {
    return GetField<int32_t>(VT_OFFSETEND, 0);
  }
  const flatbuffers::String *LabelStart() const {
    return GetPointer<const flatbuffers::String *>(VT_LABELSTART);
  }
  const flatbuffers::String *LabelEnd() const {
    return GetPointer<const flatbuffers::String *>(VT_LABELEND);
  }
  bool Verify(flatbuffers::Verifier &verifier) const {
    return VerifyTableStart(verifier) &&
           VerifyField<int32_t>(verifier, VT_FLAGS) &&
           VerifyField<int32_t>(verifier, VT_PLAYCOUNT) &&
           VerifyField<float>(verifier, VT_RATETIME) &&
           VerifyField<int32_t>(verifier, VT_OFFSETSTART) &&
           VerifyField<int32_t>(verifier, VT_OFFSETEND) &&
           VerifyOffset(verifier, VT_LABELSTART) &&
           verifier.VerifyString(LabelStart()) &&
           VerifyOffset(verifier, VT_LABELEND) &&
           verifier.VerifyString(LabelEnd()) &&
           verifier.EndTable();
  }
};

struct AnimationAttributeInstanceBuilder {
  flatbuffers::FlatBufferBuilder &fbb_;
  flatbuffers::uoffset_t start_;
  void add_Flags(int32_t Flags) {
    fbb_.AddElement<int32_t>(AnimationAttributeInstance::VT_FLAGS, Flags, 0);
  }
  void add_PlayCount(int32_t PlayCount) {
    fbb_.AddElement<int32_t>(AnimationAttributeInstance::VT_PLAYCOUNT, PlayCount, 0);
  }
  void add_RateTime(float RateTime) {
    fbb_.AddElement<float>(AnimationAttributeInstance::VT_RATETIME, RateTime, 0.0f);
  }
  void add_OffsetStart(int32_t OffsetStart) {
    fbb_.AddElement<int32_t>(AnimationAttributeInstance::VT_OFFSETSTART, OffsetStart, 0);
  }
  void add_OffsetEnd(int32_t OffsetEnd) {
    fbb_.AddElement<int32_t>(AnimationAttributeInstance::VT_OFFSETEND, OffsetEnd, 0);
  }
  void add_LabelStart(flatbuffers::Offset<flatbuffers::String> LabelStart) {
    fbb_.AddOffset(AnimationAttributeInstance::VT_LABELSTART, LabelStart);
  }
  void add_LabelEnd(flatbuffers::Offset<flatbuffers::String> LabelEnd) {
    fbb_.AddOffset(AnimationAttributeInstance::VT_LABELEND, LabelEnd);
  }
  explicit AnimationAttributeInstanceBuilder(flatbuffers::FlatBufferBuilder &_fbb)
        : fbb_(_fbb) {
    start_ = fbb_.StartTable();
  }
  AnimationAttributeInstanceBuilder &operator=(const AnimationAttributeInstanceBuilder &);
  flatbuffers::Offset<AnimationAttributeInstance> Finish() {
    const auto end = fbb_.EndTable(start_);
    auto o = flatbuffers::Offset<AnimationAttributeInstance>(end);
    return o;
  }
};

inline flatbuffers::Offset<AnimationAttributeInstance> CreateAnimationAttributeInstance(
    flatbuffers::FlatBufferBuilder &_fbb,
    int32_t Flags = 0,
    int32_t PlayCount = 0,
    float RateTime = 0.0f,
    int32_t OffsetStart = 0,
    int32_t OffsetEnd = 0,
    flatbuffers::Offset<flatbuffers::String> LabelStart = 0,
    flatbuffers::Offset<flatbuffers::String> LabelEnd = 0) {
  AnimationAttributeInstanceBuilder builder_(_fbb);
  builder_.add_LabelEnd(LabelEnd);
  builder_.add_LabelStart(LabelStart);
  builder_.add_OffsetEnd(OffsetEnd);
  builder_.add_OffsetStart(OffsetStart);
  builder_.add_RateTime(RateTime);
  builder_.add_PlayCount(PlayCount);
  builder_.add_Flags(Flags);
  return builder_.Finish();
}

inline flatbuffers::Offset<AnimationAttributeInstance> CreateAnimationAttributeInstanceDirect(
    flatbuffers::FlatBufferBuilder &_fbb,
    int32_t Flags = 0,
    int32_t PlayCount = 0,
    float RateTime = 0.0f,
    int32_t OffsetStart = 0,
    int32_t OffsetEnd = 0,
    const char *LabelStart = nullptr,
    const char *LabelEnd = nullptr) {
  auto LabelStart__ = LabelStart ? _fbb.CreateString(LabelStart) : 0;
  auto LabelEnd__ = LabelEnd ? _fbb.CreateString(LabelEnd) : 0;
  return ss::ssfb2::CreateAnimationAttributeInstance(
      _fbb,
      Flags,
      PlayCount,
      RateTime,
      OffsetStart,
      OffsetEnd,
      LabelStart__,
      LabelEnd__);
}

struct ContainerInstance FLATBUFFERS_FINAL_CLASS : private flatbuffers::Table {
  enum FlatBuffersVTableOffset FLATBUFFERS_VTABLE_UNDERLYING_TYPE {
    VT_TYPEPACK = 4,
    VT_TABLECODEVALUE = 6,
    VT_TABLEVALUE = 8
  };
  KindTypePack TypePack() const {
    return static_cast<KindTypePack>(GetField<int16_t>(VT_TYPEPACK, 0));
  }
  const flatbuffers::Vector<flatbuffers::Offset<CodeValueContainer>> *TableCodeValue() const {
    return GetPointer<const flatbuffers::Vector<flatbuffers::Offset<CodeValueContainer>> *>(VT_TABLECODEVALUE);
  }
  const flatbuffers::Vector<flatbuffers::Offset<AnimationAttributeInstance>> *TableValue() const {
    return GetPointer<const flatbuffers::Vector<flatbuffers::Offset<AnimationAttributeInstance>> *>(VT_TABLEVALUE);
  }
  bool Verify(flatbuffers::Verifier &verifier) const {
    return VerifyTableStart(verifier) &&
           VerifyField<int16_t>(verifier, VT_TYPEPACK) &&
           VerifyOffset(verifier, VT_TABLECODEVALUE) &&
           verifier.VerifyVector(TableCodeValue()) &&
           verifier.VerifyVectorOfTables(TableCodeValue()) &&
           VerifyOffset(verifier, VT_TABLEVALUE) &&
           verifier.VerifyVector(TableValue()) &&
           verifier.VerifyVectorOfTables(TableValue()) &&
           verifier.EndTable();
  }
};

struct ContainerInstanceBuilder {
  flatbuffers::FlatBufferBuilder &fbb_;
  flatbuffers::uoffset_t start_;
  void add_TypePack(KindTypePack TypePack) {
    fbb_.AddElement<int16_t>(ContainerInstance::VT_TYPEPACK, static_cast<int16_t>(TypePack), 0);
  }
  void add_TableCodeValue(flatbuffers::Offset<flatbuffers::Vector<flatbuffers::Offset<CodeValueContainer>>> TableCodeValue) {
    fbb_.AddOffset(ContainerInstance::VT_TABLECODEVALUE, TableCodeValue);
  }
  void add_TableValue(flatbuffers::Offset<flatbuffers::Vector<flatbuffers::Offset<AnimationAttributeInstance>>> TableValue) {
    fbb_.AddOffset(ContainerInstance::VT_TABLEVALUE, TableValue);
  }
  explicit ContainerInstanceBuilder(flatbuffers::FlatBufferBuilder &_fbb)
        : fbb_(_fbb) {
    start_ = fbb_.StartTable();
  }
  ContainerInstanceBuilder &operator=(const ContainerInstanceBuilder &);
  flatbuffers::Offset<ContainerInstance> Finish() {
    const auto end = fbb_.EndTable(start_);
    auto o = flatbuffers::Offset<ContainerInstance>(end);
    return o;
  }
};

inline flatbuffers::Offset<ContainerInstance> CreateContainerInstance(
    flatbuffers::FlatBufferBuilder &_fbb,
    KindTypePack TypePack = KindTypePack_STANDARD_UNCOMPRESSED,
    flatbuffers::Offset<flatbuffers::Vector<flatbuffers::Offset<CodeValueContainer>>> TableCodeValue = 0,
    flatbuffers::Offset<flatbuffers::Vector<flatbuffers::Offset<AnimationAttributeInstance>>> TableValue = 0) {
  ContainerInstanceBuilder builder_(_fbb);
  builder_.add_TableValue(TableValue);
  builder_.add_TableCodeValue(TableCodeValue);
  builder_.add_TypePack(TypePack);
  return builder_.Finish();
}

inline flatbuffers::Offset<ContainerInstance> CreateContainerInstanceDirect(
    flatbuffers::FlatBufferBuilder &_fbb,
    KindTypePack TypePack = KindTypePack_STANDARD_UNCOMPRESSED,
    const std::vector<flatbuffers::Offset<CodeValueContainer>> *TableCodeValue = nullptr,
    const std::vector<flatbuffers::Offset<AnimationAttributeInstance>> *TableValue = nullptr) {
  auto TableCodeValue__ = TableCodeValue ? _fbb.CreateVector<flatbuffers::Offset<CodeValueContainer>>(*TableCodeValue) : 0;
  auto TableValue__ = TableValue ? _fbb.CreateVector<flatbuffers::Offset<AnimationAttributeInstance>>(*TableValue) : 0;
  return ss::ssfb2::CreateContainerInstance(
      _fbb,
      TypePack,
      TableCodeValue__,
      TableValue__);
}

struct AnimationAttributeEffect FLATBUFFERS_FINAL_CLASS : private flatbuffers::Table {
  enum FlatBuffersVTableOffset FLATBUFFERS_VTABLE_UNDERLYING_TYPE {
    VT_FLAGS = 4,
    VT_FRAMESTART = 6,
    VT_RATETIME = 8
  };
  int32_t Flags() const {
    return GetField<int32_t>(VT_FLAGS, 0);
  }
  int32_t FrameStart() const {
    return GetField<int32_t>(VT_FRAMESTART, 0);
  }
  float RateTime() const {
    return GetField<float>(VT_RATETIME, 0.0f);
  }
  bool Verify(flatbuffers::Verifier &verifier) const {
    return VerifyTableStart(verifier) &&
           VerifyField<int32_t>(verifier, VT_FLAGS) &&
           VerifyField<int32_t>(verifier, VT_FRAMESTART) &&
           VerifyField<float>(verifier, VT_RATETIME) &&
           verifier.EndTable();
  }
};

struct AnimationAttributeEffectBuilder {
  flatbuffers::FlatBufferBuilder &fbb_;
  flatbuffers::uoffset_t start_;
  void add_Flags(int32_t Flags) {
    fbb_.AddElement<int32_t>(AnimationAttributeEffect::VT_FLAGS, Flags, 0);
  }
  void add_FrameStart(int32_t FrameStart) {
    fbb_.AddElement<int32_t>(AnimationAttributeEffect::VT_FRAMESTART, FrameStart, 0);
  }
  void add_RateTime(float RateTime) {
    fbb_.AddElement<float>(AnimationAttributeEffect::VT_RATETIME, RateTime, 0.0f);
  }
  explicit AnimationAttributeEffectBuilder(flatbuffers::FlatBufferBuilder &_fbb)
        : fbb_(_fbb) {
    start_ = fbb_.StartTable();
  }
  AnimationAttributeEffectBuilder &operator=(const AnimationAttributeEffectBuilder &);
  flatbuffers::Offset<AnimationAttributeEffect> Finish() {
    const auto end = fbb_.EndTable(start_);
    auto o = flatbuffers::Offset<AnimationAttributeEffect>(end);
    return o;
  }
};

inline flatbuffers::Offset<AnimationAttributeEffect> CreateAnimationAttributeEffect(
    flatbuffers::FlatBufferBuilder &_fbb,
    int32_t Flags = 0,
    int32_t FrameStart = 0,
    float RateTime = 0.0f) {
  AnimationAttributeEffectBuilder builder_(_fbb);
  builder_.add_RateTime(RateTime);
  builder_.add_FrameStart(FrameStart);
  builder_.add_Flags(Flags);
  return builder_.Finish();
}

struct ContainerEffect FLATBUFFERS_FINAL_CLASS : private flatbuffers::Table {
  enum FlatBuffersVTableOffset FLATBUFFERS_VTABLE_UNDERLYING_TYPE {
    VT_TYPEPACK = 4,
    VT_TABLECODEVALUE = 6,
    VT_TABLEVALUE = 8
  };
  KindTypePack TypePack() const {
    return static_cast<KindTypePack>(GetField<int16_t>(VT_TYPEPACK, 0));
  }
  const flatbuffers::Vector<flatbuffers::Offset<CodeValueContainer>> *TableCodeValue() const {
    return GetPointer<const flatbuffers::Vector<flatbuffers::Offset<CodeValueContainer>> *>(VT_TABLECODEVALUE);
  }
  const flatbuffers::Vector<flatbuffers::Offset<AnimationAttributeEffect>> *TableValue() const {
    return GetPointer<const flatbuffers::Vector<flatbuffers::Offset<AnimationAttributeEffect>> *>(VT_TABLEVALUE);
  }
  bool Verify(flatbuffers::Verifier &verifier) const {
    return VerifyTableStart(verifier) &&
           VerifyField<int16_t>(verifier, VT_TYPEPACK) &&
           VerifyOffset(verifier, VT_TABLECODEVALUE) &&
           verifier.VerifyVector(TableCodeValue()) &&
           verifier.VerifyVectorOfTables(TableCodeValue()) &&
           VerifyOffset(verifier, VT_TABLEVALUE) &&
           verifier.VerifyVector(TableValue()) &&
           verifier.VerifyVectorOfTables(TableValue()) &&
           verifier.EndTable();
  }
};

struct ContainerEffectBuilder {
  flatbuffers::FlatBufferBuilder &fbb_;
  flatbuffers::uoffset_t start_;
  void add_TypePack(KindTypePack TypePack) {
    fbb_.AddElement<int16_t>(ContainerEffect::VT_TYPEPACK, static_cast<int16_t>(TypePack), 0);
  }
  void add_TableCodeValue(flatbuffers::Offset<flatbuffers::Vector<flatbuffers::Offset<CodeValueContainer>>> TableCodeValue) {
    fbb_.AddOffset(ContainerEffect::VT_TABLECODEVALUE, TableCodeValue);
  }
  void add_TableValue(flatbuffers::Offset<flatbuffers::Vector<flatbuffers::Offset<AnimationAttributeEffect>>> TableValue) {
    fbb_.AddOffset(ContainerEffect::VT_TABLEVALUE, TableValue);
  }
  explicit ContainerEffectBuilder(flatbuffers::FlatBufferBuilder &_fbb)
        : fbb_(_fbb) {
    start_ = fbb_.StartTable();
  }
  ContainerEffectBuilder &operator=(const ContainerEffectBuilder &);
  flatbuffers::Offset<ContainerEffect> Finish() {
    const auto end = fbb_.EndTable(start_);
    auto o = flatbuffers::Offset<ContainerEffect>(end);
    return o;
  }
};

inline flatbuffers::Offset<ContainerEffect> CreateContainerEffect(
    flatbuffers::FlatBufferBuilder &_fbb,
    KindTypePack TypePack = KindTypePack_STANDARD_UNCOMPRESSED,
    flatbuffers::Offset<flatbuffers::Vector<flatbuffers::Offset<CodeValueContainer>>> TableCodeValue = 0,
    flatbuffers::Offset<flatbuffers::Vector<flatbuffers::Offset<AnimationAttributeEffect>>> TableValue = 0) {
  ContainerEffectBuilder builder_(_fbb);
  builder_.add_TableValue(TableValue);
  builder_.add_TableCodeValue(TableCodeValue);
  builder_.add_TypePack(TypePack);
  return builder_.Finish();
}

inline flatbuffers::Offset<ContainerEffect> CreateContainerEffectDirect(
    flatbuffers::FlatBufferBuilder &_fbb,
    KindTypePack TypePack = KindTypePack_STANDARD_UNCOMPRESSED,
    const std::vector<flatbuffers::Offset<CodeValueContainer>> *TableCodeValue = nullptr,
    const std::vector<flatbuffers::Offset<AnimationAttributeEffect>> *TableValue = nullptr) {
  auto TableCodeValue__ = TableCodeValue ? _fbb.CreateVector<flatbuffers::Offset<CodeValueContainer>>(*TableCodeValue) : 0;
  auto TableValue__ = TableValue ? _fbb.CreateVector<flatbuffers::Offset<AnimationAttributeEffect>>(*TableValue) : 0;
  return ss::ssfb2::CreateContainerEffect(
      _fbb,
      TypePack,
      TableCodeValue__,
      TableValue__);
}

struct AnimationAttributeDeform FLATBUFFERS_FINAL_CLASS : private flatbuffers::Table {
  enum FlatBuffersVTableOffset FLATBUFFERS_VTABLE_UNDERLYING_TYPE {
    VT_TABLECOORDINATE = 4
  };
  const flatbuffers::Vector<flatbuffers::Offset<Vector2>> *TableCoordinate() const {
    return GetPointer<const flatbuffers::Vector<flatbuffers::Offset<Vector2>> *>(VT_TABLECOORDINATE);
  }
  bool Verify(flatbuffers::Verifier &verifier) const {
    return VerifyTableStart(verifier) &&
           VerifyOffset(verifier, VT_TABLECOORDINATE) &&
           verifier.VerifyVector(TableCoordinate()) &&
           verifier.VerifyVectorOfTables(TableCoordinate()) &&
           verifier.EndTable();
  }
};

struct AnimationAttributeDeformBuilder {
  flatbuffers::FlatBufferBuilder &fbb_;
  flatbuffers::uoffset_t start_;
  void add_TableCoordinate(flatbuffers::Offset<flatbuffers::Vector<flatbuffers::Offset<Vector2>>> TableCoordinate) {
    fbb_.AddOffset(AnimationAttributeDeform::VT_TABLECOORDINATE, TableCoordinate);
  }
  explicit AnimationAttributeDeformBuilder(flatbuffers::FlatBufferBuilder &_fbb)
        : fbb_(_fbb) {
    start_ = fbb_.StartTable();
  }
  AnimationAttributeDeformBuilder &operator=(const AnimationAttributeDeformBuilder &);
  flatbuffers::Offset<AnimationAttributeDeform> Finish() {
    const auto end = fbb_.EndTable(start_);
    auto o = flatbuffers::Offset<AnimationAttributeDeform>(end);
    return o;
  }
};

inline flatbuffers::Offset<AnimationAttributeDeform> CreateAnimationAttributeDeform(
    flatbuffers::FlatBufferBuilder &_fbb,
    flatbuffers::Offset<flatbuffers::Vector<flatbuffers::Offset<Vector2>>> TableCoordinate = 0) {
  AnimationAttributeDeformBuilder builder_(_fbb);
  builder_.add_TableCoordinate(TableCoordinate);
  return builder_.Finish();
}

inline flatbuffers::Offset<AnimationAttributeDeform> CreateAnimationAttributeDeformDirect(
    flatbuffers::FlatBufferBuilder &_fbb,
    const std::vector<flatbuffers::Offset<Vector2>> *TableCoordinate = nullptr) {
  auto TableCoordinate__ = TableCoordinate ? _fbb.CreateVector<flatbuffers::Offset<Vector2>>(*TableCoordinate) : 0;
  return ss::ssfb2::CreateAnimationAttributeDeform(
      _fbb,
      TableCoordinate__);
}

struct ContainerDeform FLATBUFFERS_FINAL_CLASS : private flatbuffers::Table {
  enum FlatBuffersVTableOffset FLATBUFFERS_VTABLE_UNDERLYING_TYPE {
    VT_TYPEPACK = 4,
    VT_TABLECODEVALUE = 6,
    VT_TABLEVALUE = 8
  };
  KindTypePack TypePack() const {
    return static_cast<KindTypePack>(GetField<int16_t>(VT_TYPEPACK, 0));
  }
  const flatbuffers::Vector<flatbuffers::Offset<CodeValueContainer>> *TableCodeValue() const {
    return GetPointer<const flatbuffers::Vector<flatbuffers::Offset<CodeValueContainer>> *>(VT_TABLECODEVALUE);
  }
  const flatbuffers::Vector<flatbuffers::Offset<AnimationAttributeDeform>> *TableValue() const {
    return GetPointer<const flatbuffers::Vector<flatbuffers::Offset<AnimationAttributeDeform>> *>(VT_TABLEVALUE);
  }
  bool Verify(flatbuffers::Verifier &verifier) const {
    return VerifyTableStart(verifier) &&
           VerifyField<int16_t>(verifier, VT_TYPEPACK) &&
           VerifyOffset(verifier, VT_TABLECODEVALUE) &&
           verifier.VerifyVector(TableCodeValue()) &&
           verifier.VerifyVectorOfTables(TableCodeValue()) &&
           VerifyOffset(verifier, VT_TABLEVALUE) &&
           verifier.VerifyVector(TableValue()) &&
           verifier.VerifyVectorOfTables(TableValue()) &&
           verifier.EndTable();
  }
};

struct ContainerDeformBuilder {
  flatbuffers::FlatBufferBuilder &fbb_;
  flatbuffers::uoffset_t start_;
  void add_TypePack(KindTypePack TypePack) {
    fbb_.AddElement<int16_t>(ContainerDeform::VT_TYPEPACK, static_cast<int16_t>(TypePack), 0);
  }
  void add_TableCodeValue(flatbuffers::Offset<flatbuffers::Vector<flatbuffers::Offset<CodeValueContainer>>> TableCodeValue) {
    fbb_.AddOffset(ContainerDeform::VT_TABLECODEVALUE, TableCodeValue);
  }
  void add_TableValue(flatbuffers::Offset<flatbuffers::Vector<flatbuffers::Offset<AnimationAttributeDeform>>> TableValue) {
    fbb_.AddOffset(ContainerDeform::VT_TABLEVALUE, TableValue);
  }
  explicit ContainerDeformBuilder(flatbuffers::FlatBufferBuilder &_fbb)
        : fbb_(_fbb) {
    start_ = fbb_.StartTable();
  }
  ContainerDeformBuilder &operator=(const ContainerDeformBuilder &);
  flatbuffers::Offset<ContainerDeform> Finish() {
    const auto end = fbb_.EndTable(start_);
    auto o = flatbuffers::Offset<ContainerDeform>(end);
    return o;
  }
};

inline flatbuffers::Offset<ContainerDeform> CreateContainerDeform(
    flatbuffers::FlatBufferBuilder &_fbb,
    KindTypePack TypePack = KindTypePack_STANDARD_UNCOMPRESSED,
    flatbuffers::Offset<flatbuffers::Vector<flatbuffers::Offset<CodeValueContainer>>> TableCodeValue = 0,
    flatbuffers::Offset<flatbuffers::Vector<flatbuffers::Offset<AnimationAttributeDeform>>> TableValue = 0) {
  ContainerDeformBuilder builder_(_fbb);
  builder_.add_TableValue(TableValue);
  builder_.add_TableCodeValue(TableCodeValue);
  builder_.add_TypePack(TypePack);
  return builder_.Finish();
}

inline flatbuffers::Offset<ContainerDeform> CreateContainerDeformDirect(
    flatbuffers::FlatBufferBuilder &_fbb,
    KindTypePack TypePack = KindTypePack_STANDARD_UNCOMPRESSED,
    const std::vector<flatbuffers::Offset<CodeValueContainer>> *TableCodeValue = nullptr,
    const std::vector<flatbuffers::Offset<AnimationAttributeDeform>> *TableValue = nullptr) {
  auto TableCodeValue__ = TableCodeValue ? _fbb.CreateVector<flatbuffers::Offset<CodeValueContainer>>(*TableCodeValue) : 0;
  auto TableValue__ = TableValue ? _fbb.CreateVector<flatbuffers::Offset<AnimationAttributeDeform>>(*TableValue) : 0;
  return ss::ssfb2::CreateContainerDeform(
      _fbb,
      TypePack,
      TableCodeValue__,
      TableValue__);
}

struct DataAnimationParts FLATBUFFERS_FINAL_CLASS : private flatbuffers::Table {
  enum FlatBuffersVTableOffset FLATBUFFERS_VTABLE_UNDERLYING_TYPE {
    VT_STATUS_PARTS = 4,
    VT_STATUS = 6,
    VT_CELL = 8,
    VT_POSITION = 10,
    VT_ROTATION = 12,
    VT_SCALING = 14,
    VT_SCALINGLOCAL = 16,
    VT_RATEOPACITY = 18,
    VT_PRIORITY = 20,
    VT_PARTSCOLOR = 22,
    VT_VERTEXCORRECTION = 24,
    VT_OFFSETPIVOT = 26,
    VT_POSITIONANCHOR = 28,
    VT_SIZEFORCE = 30,
    VT_POSITIONTEXTURE = 32,
    VT_ROTATIONTEXTURE = 34,
    VT_SCALINGTEXTURE = 36,
    VT_RADIUSCOLLISION = 38,
    VT_USER_DATA = 40,
    VT_INSTANCE = 42,
    VT_EFFECT = 44,
    VT_DEFORM = 46
  };
  DataAnimationPartsFlagBitStatus status_parts() const {
    return static_cast<DataAnimationPartsFlagBitStatus>(GetField<uint32_t>(VT_STATUS_PARTS, 0));
  }
  const ContainerStatus *status() const {
    return GetPointer<const ContainerStatus *>(VT_STATUS);
  }
  const ContainerCell *cell() const {
    return GetPointer<const ContainerCell *>(VT_CELL);
  }
  const ContainerVector3 *position() const {
    return GetPointer<const ContainerVector3 *>(VT_POSITION);
  }
  const ContainerVector3 *rotation() const {
    return GetPointer<const ContainerVector3 *>(VT_ROTATION);
  }
  const ContainerVector2 *scaling() const {
    return GetPointer<const ContainerVector2 *>(VT_SCALING);
  }
  const ContainerVector2 *scalingLocal() const {
    return GetPointer<const ContainerVector2 *>(VT_SCALINGLOCAL);
  }
  const ContainerFloat *rateOpacity() const {
    return GetPointer<const ContainerFloat *>(VT_RATEOPACITY);
  }
  const ContainerInt *priority() const {
    return GetPointer<const ContainerInt *>(VT_PRIORITY);
  }
  const ContainerPartsColor *partsColor() const {
    return GetPointer<const ContainerPartsColor *>(VT_PARTSCOLOR);
  }
  const ContainerVertexCorrection *vertexCorrection() const {
    return GetPointer<const ContainerVertexCorrection *>(VT_VERTEXCORRECTION);
  }
  const ContainerVector2 *offsetPivot() const {
    return GetPointer<const ContainerVector2 *>(VT_OFFSETPIVOT);
  }
  const ContainerVector2 *positionAnchor() const {
    return GetPointer<const ContainerVector2 *>(VT_POSITIONANCHOR);
  }
  const ContainerVector2 *sizeForce() const {
    return GetPointer<const ContainerVector2 *>(VT_SIZEFORCE);
  }
  const ContainerVector2 *positionTexture() const {
    return GetPointer<const ContainerVector2 *>(VT_POSITIONTEXTURE);
  }
  const ContainerFloat *rotationTexture() const {
    return GetPointer<const ContainerFloat *>(VT_ROTATIONTEXTURE);
  }
  const ContainerVector2 *scalingTexture() const {
    return GetPointer<const ContainerVector2 *>(VT_SCALINGTEXTURE);
  }
  const ContainerFloat *radiusCollision() const {
    return GetPointer<const ContainerFloat *>(VT_RADIUSCOLLISION);
  }
  const ContainerUserData *user_data() const {
    return GetPointer<const ContainerUserData *>(VT_USER_DATA);
  }
  const ContainerInstance *instance() const {
    return GetPointer<const ContainerInstance *>(VT_INSTANCE);
  }
  const ContainerEffect *effect() const {
    return GetPointer<const ContainerEffect *>(VT_EFFECT);
  }
  const ContainerDeform *deform() const {
    return GetPointer<const ContainerDeform *>(VT_DEFORM);
  }
  bool Verify(flatbuffers::Verifier &verifier) const {
    return VerifyTableStart(verifier) &&
           VerifyField<uint32_t>(verifier, VT_STATUS_PARTS) &&
           VerifyOffset(verifier, VT_STATUS) &&
           verifier.VerifyTable(status()) &&
           VerifyOffset(verifier, VT_CELL) &&
           verifier.VerifyTable(cell()) &&
           VerifyOffset(verifier, VT_POSITION) &&
           verifier.VerifyTable(position()) &&
           VerifyOffset(verifier, VT_ROTATION) &&
           verifier.VerifyTable(rotation()) &&
           VerifyOffset(verifier, VT_SCALING) &&
           verifier.VerifyTable(scaling()) &&
           VerifyOffset(verifier, VT_SCALINGLOCAL) &&
           verifier.VerifyTable(scalingLocal()) &&
           VerifyOffset(verifier, VT_RATEOPACITY) &&
           verifier.VerifyTable(rateOpacity()) &&
           VerifyOffset(verifier, VT_PRIORITY) &&
           verifier.VerifyTable(priority()) &&
           VerifyOffset(verifier, VT_PARTSCOLOR) &&
           verifier.VerifyTable(partsColor()) &&
           VerifyOffset(verifier, VT_VERTEXCORRECTION) &&
           verifier.VerifyTable(vertexCorrection()) &&
           VerifyOffset(verifier, VT_OFFSETPIVOT) &&
           verifier.VerifyTable(offsetPivot()) &&
           VerifyOffset(verifier, VT_POSITIONANCHOR) &&
           verifier.VerifyTable(positionAnchor()) &&
           VerifyOffset(verifier, VT_SIZEFORCE) &&
           verifier.VerifyTable(sizeForce()) &&
           VerifyOffset(verifier, VT_POSITIONTEXTURE) &&
           verifier.VerifyTable(positionTexture()) &&
           VerifyOffset(verifier, VT_ROTATIONTEXTURE) &&
           verifier.VerifyTable(rotationTexture()) &&
           VerifyOffset(verifier, VT_SCALINGTEXTURE) &&
           verifier.VerifyTable(scalingTexture()) &&
           VerifyOffset(verifier, VT_RADIUSCOLLISION) &&
           verifier.VerifyTable(radiusCollision()) &&
           VerifyOffset(verifier, VT_USER_DATA) &&
           verifier.VerifyTable(user_data()) &&
           VerifyOffset(verifier, VT_INSTANCE) &&
           verifier.VerifyTable(instance()) &&
           VerifyOffset(verifier, VT_EFFECT) &&
           verifier.VerifyTable(effect()) &&
           VerifyOffset(verifier, VT_DEFORM) &&
           verifier.VerifyTable(deform()) &&
           verifier.EndTable();
  }
};

struct DataAnimationPartsBuilder {
  flatbuffers::FlatBufferBuilder &fbb_;
  flatbuffers::uoffset_t start_;
  void add_status_parts(DataAnimationPartsFlagBitStatus status_parts) {
    fbb_.AddElement<uint32_t>(DataAnimationParts::VT_STATUS_PARTS, static_cast<uint32_t>(status_parts), 0);
  }
  void add_status(flatbuffers::Offset<ContainerStatus> status) {
    fbb_.AddOffset(DataAnimationParts::VT_STATUS, status);
  }
  void add_cell(flatbuffers::Offset<ContainerCell> cell) {
    fbb_.AddOffset(DataAnimationParts::VT_CELL, cell);
  }
  void add_position(flatbuffers::Offset<ContainerVector3> position) {
    fbb_.AddOffset(DataAnimationParts::VT_POSITION, position);
  }
  void add_rotation(flatbuffers::Offset<ContainerVector3> rotation) {
    fbb_.AddOffset(DataAnimationParts::VT_ROTATION, rotation);
  }
  void add_scaling(flatbuffers::Offset<ContainerVector2> scaling) {
    fbb_.AddOffset(DataAnimationParts::VT_SCALING, scaling);
  }
  void add_scalingLocal(flatbuffers::Offset<ContainerVector2> scalingLocal) {
    fbb_.AddOffset(DataAnimationParts::VT_SCALINGLOCAL, scalingLocal);
  }
  void add_rateOpacity(flatbuffers::Offset<ContainerFloat> rateOpacity) {
    fbb_.AddOffset(DataAnimationParts::VT_RATEOPACITY, rateOpacity);
  }
  void add_priority(flatbuffers::Offset<ContainerInt> priority) {
    fbb_.AddOffset(DataAnimationParts::VT_PRIORITY, priority);
  }
  void add_partsColor(flatbuffers::Offset<ContainerPartsColor> partsColor) {
    fbb_.AddOffset(DataAnimationParts::VT_PARTSCOLOR, partsColor);
  }
  void add_vertexCorrection(flatbuffers::Offset<ContainerVertexCorrection> vertexCorrection) {
    fbb_.AddOffset(DataAnimationParts::VT_VERTEXCORRECTION, vertexCorrection);
  }
  void add_offsetPivot(flatbuffers::Offset<ContainerVector2> offsetPivot) {
    fbb_.AddOffset(DataAnimationParts::VT_OFFSETPIVOT, offsetPivot);
  }
  void add_positionAnchor(flatbuffers::Offset<ContainerVector2> positionAnchor) {
    fbb_.AddOffset(DataAnimationParts::VT_POSITIONANCHOR, positionAnchor);
  }
  void add_sizeForce(flatbuffers::Offset<ContainerVector2> sizeForce) {
    fbb_.AddOffset(DataAnimationParts::VT_SIZEFORCE, sizeForce);
  }
  void add_positionTexture(flatbuffers::Offset<ContainerVector2> positionTexture) {
    fbb_.AddOffset(DataAnimationParts::VT_POSITIONTEXTURE, positionTexture);
  }
  void add_rotationTexture(flatbuffers::Offset<ContainerFloat> rotationTexture) {
    fbb_.AddOffset(DataAnimationParts::VT_ROTATIONTEXTURE, rotationTexture);
  }
  void add_scalingTexture(flatbuffers::Offset<ContainerVector2> scalingTexture) {
    fbb_.AddOffset(DataAnimationParts::VT_SCALINGTEXTURE, scalingTexture);
  }
  void add_radiusCollision(flatbuffers::Offset<ContainerFloat> radiusCollision) {
    fbb_.AddOffset(DataAnimationParts::VT_RADIUSCOLLISION, radiusCollision);
  }
  void add_user_data(flatbuffers::Offset<ContainerUserData> user_data) {
    fbb_.AddOffset(DataAnimationParts::VT_USER_DATA, user_data);
  }
  void add_instance(flatbuffers::Offset<ContainerInstance> instance) {
    fbb_.AddOffset(DataAnimationParts::VT_INSTANCE, instance);
  }
  void add_effect(flatbuffers::Offset<ContainerEffect> effect) {
    fbb_.AddOffset(DataAnimationParts::VT_EFFECT, effect);
  }
  void add_deform(flatbuffers::Offset<ContainerDeform> deform) {
    fbb_.AddOffset(DataAnimationParts::VT_DEFORM, deform);
  }
  explicit DataAnimationPartsBuilder(flatbuffers::FlatBufferBuilder &_fbb)
        : fbb_(_fbb) {
    start_ = fbb_.StartTable();
  }
  DataAnimationPartsBuilder &operator=(const DataAnimationPartsBuilder &);
  flatbuffers::Offset<DataAnimationParts> Finish() {
    const auto end = fbb_.EndTable(start_);
    auto o = flatbuffers::Offset<DataAnimationParts>(end);
    return o;
  }
};

inline flatbuffers::Offset<DataAnimationParts> CreateDataAnimationParts(
    flatbuffers::FlatBufferBuilder &_fbb,
    DataAnimationPartsFlagBitStatus status_parts = DataAnimationPartsFlagBitStatus_Clear,
    flatbuffers::Offset<ContainerStatus> status = 0,
    flatbuffers::Offset<ContainerCell> cell = 0,
    flatbuffers::Offset<ContainerVector3> position = 0,
    flatbuffers::Offset<ContainerVector3> rotation = 0,
    flatbuffers::Offset<ContainerVector2> scaling = 0,
    flatbuffers::Offset<ContainerVector2> scalingLocal = 0,
    flatbuffers::Offset<ContainerFloat> rateOpacity = 0,
    flatbuffers::Offset<ContainerInt> priority = 0,
    flatbuffers::Offset<ContainerPartsColor> partsColor = 0,
    flatbuffers::Offset<ContainerVertexCorrection> vertexCorrection = 0,
    flatbuffers::Offset<ContainerVector2> offsetPivot = 0,
    flatbuffers::Offset<ContainerVector2> positionAnchor = 0,
    flatbuffers::Offset<ContainerVector2> sizeForce = 0,
    flatbuffers::Offset<ContainerVector2> positionTexture = 0,
    flatbuffers::Offset<ContainerFloat> rotationTexture = 0,
    flatbuffers::Offset<ContainerVector2> scalingTexture = 0,
    flatbuffers::Offset<ContainerFloat> radiusCollision = 0,
    flatbuffers::Offset<ContainerUserData> user_data = 0,
    flatbuffers::Offset<ContainerInstance> instance = 0,
    flatbuffers::Offset<ContainerEffect> effect = 0,
    flatbuffers::Offset<ContainerDeform> deform = 0) {
  DataAnimationPartsBuilder builder_(_fbb);
  builder_.add_deform(deform);
  builder_.add_effect(effect);
  builder_.add_instance(instance);
  builder_.add_user_data(user_data);
  builder_.add_radiusCollision(radiusCollision);
  builder_.add_scalingTexture(scalingTexture);
  builder_.add_rotationTexture(rotationTexture);
  builder_.add_positionTexture(positionTexture);
  builder_.add_sizeForce(sizeForce);
  builder_.add_positionAnchor(positionAnchor);
  builder_.add_offsetPivot(offsetPivot);
  builder_.add_vertexCorrection(vertexCorrection);
  builder_.add_partsColor(partsColor);
  builder_.add_priority(priority);
  builder_.add_rateOpacity(rateOpacity);
  builder_.add_scalingLocal(scalingLocal);
  builder_.add_scaling(scaling);
  builder_.add_rotation(rotation);
  builder_.add_position(position);
  builder_.add_cell(cell);
  builder_.add_status(status);
  builder_.add_status_parts(status_parts);
  return builder_.Finish();
}

struct LibraryDataAnimation FLATBUFFERS_FINAL_CLASS : private flatbuffers::Table {
  enum FlatBuffersVTableOffset FLATBUFFERS_VTABLE_UNDERLYING_TYPE {
    VT_NAME = 4,
    VT_FRAME_PER_SECOND = 6,
    VT_COUNT_FRAME = 8,
    VT_SIZE_CANVAS_X = 10,
    VT_SIZE_CANVAS_Y = 12,
    VT_FRAME_VALID_START = 14,
    VT_FRAME_VALID_END = 16,
    VT_COUNT_FRAME_VALID = 18,
    VT_DEPTH_IK = 20,
    VT_MODE_SORT = 22,
    VT_TABLE_LABEL = 24,
    VT_TABLE_PARTS = 26
  };
  const flatbuffers::String *name() const {
    return GetPointer<const flatbuffers::String *>(VT_NAME);
  }
  int32_t frame_per_second() const {
    return GetField<int32_t>(VT_FRAME_PER_SECOND, 0);
  }
  int32_t count_frame() const {
    return GetField<int32_t>(VT_COUNT_FRAME, 0);
  }
  int32_t size_canvas_x() const {
    return GetField<int32_t>(VT_SIZE_CANVAS_X, 0);
  }
  int32_t size_canvas_y() const {
    return GetField<int32_t>(VT_SIZE_CANVAS_Y, 0);
  }
  int32_t frame_valid_start() const {
    return GetField<int32_t>(VT_FRAME_VALID_START, 0);
  }
  int32_t frame_valid_end() const {
    return GetField<int32_t>(VT_FRAME_VALID_END, 0);
  }
  int32_t count_frame_valid() const {
    return GetField<int32_t>(VT_COUNT_FRAME_VALID, 0);
  }
  int32_t depth_ik() const {
    return GetField<int32_t>(VT_DEPTH_IK, 0);
  }
  KindModeSort mode_sort() const {
    return static_cast<KindModeSort>(GetField<uint8_t>(VT_MODE_SORT, 0));
  }
  const flatbuffers::Vector<flatbuffers::Offset<Label>> *table_label() const {
    return GetPointer<const flatbuffers::Vector<flatbuffers::Offset<Label>> *>(VT_TABLE_LABEL);
  }
  const flatbuffers::Vector<flatbuffers::Offset<DataAnimationParts>> *table_parts() const {
    return GetPointer<const flatbuffers::Vector<flatbuffers::Offset<DataAnimationParts>> *>(VT_TABLE_PARTS);
  }
  bool Verify(flatbuffers::Verifier &verifier) const {
    return VerifyTableStart(verifier) &&
           VerifyOffset(verifier, VT_NAME) &&
           verifier.VerifyString(name()) &&
           VerifyField<int32_t>(verifier, VT_FRAME_PER_SECOND) &&
           VerifyField<int32_t>(verifier, VT_COUNT_FRAME) &&
           VerifyField<int32_t>(verifier, VT_SIZE_CANVAS_X) &&
           VerifyField<int32_t>(verifier, VT_SIZE_CANVAS_Y) &&
           VerifyField<int32_t>(verifier, VT_FRAME_VALID_START) &&
           VerifyField<int32_t>(verifier, VT_FRAME_VALID_END) &&
           VerifyField<int32_t>(verifier, VT_COUNT_FRAME_VALID) &&
           VerifyField<int32_t>(verifier, VT_DEPTH_IK) &&
           VerifyField<uint8_t>(verifier, VT_MODE_SORT) &&
           VerifyOffset(verifier, VT_TABLE_LABEL) &&
           verifier.VerifyVector(table_label()) &&
           verifier.VerifyVectorOfTables(table_label()) &&
           VerifyOffset(verifier, VT_TABLE_PARTS) &&
           verifier.VerifyVector(table_parts()) &&
           verifier.VerifyVectorOfTables(table_parts()) &&
           verifier.EndTable();
  }
};

struct LibraryDataAnimationBuilder {
  flatbuffers::FlatBufferBuilder &fbb_;
  flatbuffers::uoffset_t start_;
  void add_name(flatbuffers::Offset<flatbuffers::String> name) {
    fbb_.AddOffset(LibraryDataAnimation::VT_NAME, name);
  }
  void add_frame_per_second(int32_t frame_per_second) {
    fbb_.AddElement<int32_t>(LibraryDataAnimation::VT_FRAME_PER_SECOND, frame_per_second, 0);
  }
  void add_count_frame(int32_t count_frame) {
    fbb_.AddElement<int32_t>(LibraryDataAnimation::VT_COUNT_FRAME, count_frame, 0);
  }
  void add_size_canvas_x(int32_t size_canvas_x) {
    fbb_.AddElement<int32_t>(LibraryDataAnimation::VT_SIZE_CANVAS_X, size_canvas_x, 0);
  }
  void add_size_canvas_y(int32_t size_canvas_y) {
    fbb_.AddElement<int32_t>(LibraryDataAnimation::VT_SIZE_CANVAS_Y, size_canvas_y, 0);
  }
  void add_frame_valid_start(int32_t frame_valid_start) {
    fbb_.AddElement<int32_t>(LibraryDataAnimation::VT_FRAME_VALID_START, frame_valid_start, 0);
  }
  void add_frame_valid_end(int32_t frame_valid_end) {
    fbb_.AddElement<int32_t>(LibraryDataAnimation::VT_FRAME_VALID_END, frame_valid_end, 0);
  }
  void add_count_frame_valid(int32_t count_frame_valid) {
    fbb_.AddElement<int32_t>(LibraryDataAnimation::VT_COUNT_FRAME_VALID, count_frame_valid, 0);
  }
  void add_depth_ik(int32_t depth_ik) {
    fbb_.AddElement<int32_t>(LibraryDataAnimation::VT_DEPTH_IK, depth_ik, 0);
  }
  void add_mode_sort(KindModeSort mode_sort) {
    fbb_.AddElement<uint8_t>(LibraryDataAnimation::VT_MODE_SORT, static_cast<uint8_t>(mode_sort), 0);
  }
  void add_table_label(flatbuffers::Offset<flatbuffers::Vector<flatbuffers::Offset<Label>>> table_label) {
    fbb_.AddOffset(LibraryDataAnimation::VT_TABLE_LABEL, table_label);
  }
  void add_table_parts(flatbuffers::Offset<flatbuffers::Vector<flatbuffers::Offset<DataAnimationParts>>> table_parts) {
    fbb_.AddOffset(LibraryDataAnimation::VT_TABLE_PARTS, table_parts);
  }
  explicit LibraryDataAnimationBuilder(flatbuffers::FlatBufferBuilder &_fbb)
        : fbb_(_fbb) {
    start_ = fbb_.StartTable();
  }
  LibraryDataAnimationBuilder &operator=(const LibraryDataAnimationBuilder &);
  flatbuffers::Offset<LibraryDataAnimation> Finish() {
    const auto end = fbb_.EndTable(start_);
    auto o = flatbuffers::Offset<LibraryDataAnimation>(end);
    return o;
  }
};

inline flatbuffers::Offset<LibraryDataAnimation> CreateLibraryDataAnimation(
    flatbuffers::FlatBufferBuilder &_fbb,
    flatbuffers::Offset<flatbuffers::String> name = 0,
    int32_t frame_per_second = 0,
    int32_t count_frame = 0,
    int32_t size_canvas_x = 0,
    int32_t size_canvas_y = 0,
    int32_t frame_valid_start = 0,
    int32_t frame_valid_end = 0,
    int32_t count_frame_valid = 0,
    int32_t depth_ik = 0,
    KindModeSort mode_sort = KindModeSort_Priority,
    flatbuffers::Offset<flatbuffers::Vector<flatbuffers::Offset<Label>>> table_label = 0,
    flatbuffers::Offset<flatbuffers::Vector<flatbuffers::Offset<DataAnimationParts>>> table_parts = 0) {
  LibraryDataAnimationBuilder builder_(_fbb);
  builder_.add_table_parts(table_parts);
  builder_.add_table_label(table_label);
  builder_.add_depth_ik(depth_ik);
  builder_.add_count_frame_valid(count_frame_valid);
  builder_.add_frame_valid_end(frame_valid_end);
  builder_.add_frame_valid_start(frame_valid_start);
  builder_.add_size_canvas_y(size_canvas_y);
  builder_.add_size_canvas_x(size_canvas_x);
  builder_.add_count_frame(count_frame);
  builder_.add_frame_per_second(frame_per_second);
  builder_.add_name(name);
  builder_.add_mode_sort(mode_sort);
  return builder_.Finish();
}

inline flatbuffers::Offset<LibraryDataAnimation> CreateLibraryDataAnimationDirect(
    flatbuffers::FlatBufferBuilder &_fbb,
    const char *name = nullptr,
    int32_t frame_per_second = 0,
    int32_t count_frame = 0,
    int32_t size_canvas_x = 0,
    int32_t size_canvas_y = 0,
    int32_t frame_valid_start = 0,
    int32_t frame_valid_end = 0,
    int32_t count_frame_valid = 0,
    int32_t depth_ik = 0,
    KindModeSort mode_sort = KindModeSort_Priority,
    const std::vector<flatbuffers::Offset<Label>> *table_label = nullptr,
    const std::vector<flatbuffers::Offset<DataAnimationParts>> *table_parts = nullptr) {
  auto name__ = name ? _fbb.CreateString(name) : 0;
  auto table_label__ = table_label ? _fbb.CreateVector<flatbuffers::Offset<Label>>(*table_label) : 0;
  auto table_parts__ = table_parts ? _fbb.CreateVector<flatbuffers::Offset<DataAnimationParts>>(*table_parts) : 0;
  return ss::ssfb2::CreateLibraryDataAnimation(
      _fbb,
      name__,
      frame_per_second,
      count_frame,
      size_canvas_x,
      size_canvas_y,
      frame_valid_start,
      frame_valid_end,
      count_frame_valid,
      depth_ik,
      mode_sort,
      table_label__,
      table_parts__);
}

struct UserData FLATBUFFERS_FINAL_CLASS : private flatbuffers::Table {
  enum FlatBuffersVTableOffset FLATBUFFERS_VTABLE_UNDERLYING_TYPE {
    VT_FLAGS = 4,
    VT_NUMBER_INT = 6,
    VT_RECTANGLE = 8,
    VT_COORDINATE = 10,
    VT_TEXT = 12
  };
  UserDataFlagBit flags() const {
    return static_cast<UserDataFlagBit>(GetField<uint32_t>(VT_FLAGS, 0));
  }
  int32_t number_int() const {
    return GetField<int32_t>(VT_NUMBER_INT, 0);
  }
  const Rect *rectangle() const {
    return GetPointer<const Rect *>(VT_RECTANGLE);
  }
  const Vector2 *coordinate() const {
    return GetPointer<const Vector2 *>(VT_COORDINATE);
  }
  const flatbuffers::String *text() const {
    return GetPointer<const flatbuffers::String *>(VT_TEXT);
  }
  bool Verify(flatbuffers::Verifier &verifier) const {
    return VerifyTableStart(verifier) &&
           VerifyField<uint32_t>(verifier, VT_FLAGS) &&
           VerifyField<int32_t>(verifier, VT_NUMBER_INT) &&
           VerifyOffset(verifier, VT_RECTANGLE) &&
           verifier.VerifyTable(rectangle()) &&
           VerifyOffset(verifier, VT_COORDINATE) &&
           verifier.VerifyTable(coordinate()) &&
           VerifyOffset(verifier, VT_TEXT) &&
           verifier.VerifyString(text()) &&
           verifier.EndTable();
  }
};

struct UserDataBuilder {
  flatbuffers::FlatBufferBuilder &fbb_;
  flatbuffers::uoffset_t start_;
  void add_flags(UserDataFlagBit flags) {
    fbb_.AddElement<uint32_t>(UserData::VT_FLAGS, static_cast<uint32_t>(flags), 0);
  }
  void add_number_int(int32_t number_int) {
    fbb_.AddElement<int32_t>(UserData::VT_NUMBER_INT, number_int, 0);
  }
  void add_rectangle(flatbuffers::Offset<Rect> rectangle) {
    fbb_.AddOffset(UserData::VT_RECTANGLE, rectangle);
  }
  void add_coordinate(flatbuffers::Offset<Vector2> coordinate) {
    fbb_.AddOffset(UserData::VT_COORDINATE, coordinate);
  }
  void add_text(flatbuffers::Offset<flatbuffers::String> text) {
    fbb_.AddOffset(UserData::VT_TEXT, text);
  }
  explicit UserDataBuilder(flatbuffers::FlatBufferBuilder &_fbb)
        : fbb_(_fbb) {
    start_ = fbb_.StartTable();
  }
  UserDataBuilder &operator=(const UserDataBuilder &);
  flatbuffers::Offset<UserData> Finish() {
    const auto end = fbb_.EndTable(start_);
    auto o = flatbuffers::Offset<UserData>(end);
    return o;
  }
};

inline flatbuffers::Offset<UserData> CreateUserData(
    flatbuffers::FlatBufferBuilder &_fbb,
    UserDataFlagBit flags = UserDataFlagBit_CLEAR,
    int32_t number_int = 0,
    flatbuffers::Offset<Rect> rectangle = 0,
    flatbuffers::Offset<Vector2> coordinate = 0,
    flatbuffers::Offset<flatbuffers::String> text = 0) {
  UserDataBuilder builder_(_fbb);
  builder_.add_text(text);
  builder_.add_coordinate(coordinate);
  builder_.add_rectangle(rectangle);
  builder_.add_number_int(number_int);
  builder_.add_flags(flags);
  return builder_.Finish();
}

inline flatbuffers::Offset<UserData> CreateUserDataDirect(
    flatbuffers::FlatBufferBuilder &_fbb,
    UserDataFlagBit flags = UserDataFlagBit_CLEAR,
    int32_t number_int = 0,
    flatbuffers::Offset<Rect> rectangle = 0,
    flatbuffers::Offset<Vector2> coordinate = 0,
    const char *text = nullptr) {
  auto text__ = text ? _fbb.CreateString(text) : 0;
  return ss::ssfb2::CreateUserData(
      _fbb,
      flags,
      number_int,
      rectangle,
      coordinate,
      text__);
}

struct DataSetup FLATBUFFERS_FINAL_CLASS : private flatbuffers::Table {
  enum FlatBuffersVTableOffset FLATBUFFERS_VTABLE_UNDERLYING_TYPE {
    VT_USER_DATA = 4
  };
  const UserData *user_data() const {
    return GetPointer<const UserData *>(VT_USER_DATA);
  }
  bool Verify(flatbuffers::Verifier &verifier) const {
    return VerifyTableStart(verifier) &&
           VerifyOffset(verifier, VT_USER_DATA) &&
           verifier.VerifyTable(user_data()) &&
           verifier.EndTable();
  }
};

struct DataSetupBuilder {
  flatbuffers::FlatBufferBuilder &fbb_;
  flatbuffers::uoffset_t start_;
  void add_user_data(flatbuffers::Offset<UserData> user_data) {
    fbb_.AddOffset(DataSetup::VT_USER_DATA, user_data);
  }
  explicit DataSetupBuilder(flatbuffers::FlatBufferBuilder &_fbb)
        : fbb_(_fbb) {
    start_ = fbb_.StartTable();
  }
  DataSetupBuilder &operator=(const DataSetupBuilder &);
  flatbuffers::Offset<DataSetup> Finish() {
    const auto end = fbb_.EndTable(start_);
    auto o = flatbuffers::Offset<DataSetup>(end);
    return o;
  }
};

inline flatbuffers::Offset<DataSetup> CreateDataSetup(
    flatbuffers::FlatBufferBuilder &_fbb,
    flatbuffers::Offset<UserData> user_data = 0) {
  DataSetupBuilder builder_(_fbb);
  builder_.add_user_data(user_data);
  return builder_.Finish();
}

struct DataAnimation FLATBUFFERS_FINAL_CLASS : private flatbuffers::Table {
  enum FlatBuffersVTableOffset FLATBUFFERS_VTABLE_UNDERLYING_TYPE {
    VT_VERSION = 4,
    VT_TABLE_PARTS = 6,
    VT_CATALOG_PARTS = 8,
    VT_TABLE_ANIMATION = 10,
    VT_TABLE_ANIMATION_PARTS_SETUP = 12
  };
  uint32_t version() const {
    return GetField<uint32_t>(VT_VERSION, 0);
  }
  const flatbuffers::Vector<flatbuffers::Offset<DataModelParts>> *table_parts() const {
    return GetPointer<const flatbuffers::Vector<flatbuffers::Offset<DataModelParts>> *>(VT_TABLE_PARTS);
  }
  const Catalog *catalog_parts() const {
    return GetPointer<const Catalog *>(VT_CATALOG_PARTS);
  }
  const flatbuffers::Vector<flatbuffers::Offset<LibraryDataAnimation>> *table_animation() const {
    return GetPointer<const flatbuffers::Vector<flatbuffers::Offset<LibraryDataAnimation>> *>(VT_TABLE_ANIMATION);
  }
  const flatbuffers::Vector<flatbuffers::Offset<DataSetup>> *table_animation_parts_setup() const {
    return GetPointer<const flatbuffers::Vector<flatbuffers::Offset<DataSetup>> *>(VT_TABLE_ANIMATION_PARTS_SETUP);
  }
  bool Verify(flatbuffers::Verifier &verifier) const {
    return VerifyTableStart(verifier) &&
           VerifyField<uint32_t>(verifier, VT_VERSION) &&
           VerifyOffset(verifier, VT_TABLE_PARTS) &&
           verifier.VerifyVector(table_parts()) &&
           verifier.VerifyVectorOfTables(table_parts()) &&
           VerifyOffset(verifier, VT_CATALOG_PARTS) &&
           verifier.VerifyTable(catalog_parts()) &&
           VerifyOffset(verifier, VT_TABLE_ANIMATION) &&
           verifier.VerifyVector(table_animation()) &&
           verifier.VerifyVectorOfTables(table_animation()) &&
           VerifyOffset(verifier, VT_TABLE_ANIMATION_PARTS_SETUP) &&
           verifier.VerifyVector(table_animation_parts_setup()) &&
           verifier.VerifyVectorOfTables(table_animation_parts_setup()) &&
           verifier.EndTable();
  }
};

struct DataAnimationBuilder {
  flatbuffers::FlatBufferBuilder &fbb_;
  flatbuffers::uoffset_t start_;
  void add_version(uint32_t version) {
    fbb_.AddElement<uint32_t>(DataAnimation::VT_VERSION, version, 0);
  }
  void add_table_parts(flatbuffers::Offset<flatbuffers::Vector<flatbuffers::Offset<DataModelParts>>> table_parts) {
    fbb_.AddOffset(DataAnimation::VT_TABLE_PARTS, table_parts);
  }
  void add_catalog_parts(flatbuffers::Offset<Catalog> catalog_parts) {
    fbb_.AddOffset(DataAnimation::VT_CATALOG_PARTS, catalog_parts);
  }
  void add_table_animation(flatbuffers::Offset<flatbuffers::Vector<flatbuffers::Offset<LibraryDataAnimation>>> table_animation) {
    fbb_.AddOffset(DataAnimation::VT_TABLE_ANIMATION, table_animation);
  }
  void add_table_animation_parts_setup(flatbuffers::Offset<flatbuffers::Vector<flatbuffers::Offset<DataSetup>>> table_animation_parts_setup) {
    fbb_.AddOffset(DataAnimation::VT_TABLE_ANIMATION_PARTS_SETUP, table_animation_parts_setup);
  }
  explicit DataAnimationBuilder(flatbuffers::FlatBufferBuilder &_fbb)
        : fbb_(_fbb) {
    start_ = fbb_.StartTable();
  }
  DataAnimationBuilder &operator=(const DataAnimationBuilder &);
  flatbuffers::Offset<DataAnimation> Finish() {
    const auto end = fbb_.EndTable(start_);
    auto o = flatbuffers::Offset<DataAnimation>(end);
    return o;
  }
};

inline flatbuffers::Offset<DataAnimation> CreateDataAnimation(
    flatbuffers::FlatBufferBuilder &_fbb,
    uint32_t version = 0,
    flatbuffers::Offset<flatbuffers::Vector<flatbuffers::Offset<DataModelParts>>> table_parts = 0,
    flatbuffers::Offset<Catalog> catalog_parts = 0,
    flatbuffers::Offset<flatbuffers::Vector<flatbuffers::Offset<LibraryDataAnimation>>> table_animation = 0,
    flatbuffers::Offset<flatbuffers::Vector<flatbuffers::Offset<DataSetup>>> table_animation_parts_setup = 0) {
  DataAnimationBuilder builder_(_fbb);
  builder_.add_table_animation_parts_setup(table_animation_parts_setup);
  builder_.add_table_animation(table_animation);
  builder_.add_catalog_parts(catalog_parts);
  builder_.add_table_parts(table_parts);
  builder_.add_version(version);
  return builder_.Finish();
}

inline flatbuffers::Offset<DataAnimation> CreateDataAnimationDirect(
    flatbuffers::FlatBufferBuilder &_fbb,
    uint32_t version = 0,
    const std::vector<flatbuffers::Offset<DataModelParts>> *table_parts = nullptr,
    flatbuffers::Offset<Catalog> catalog_parts = 0,
    const std::vector<flatbuffers::Offset<LibraryDataAnimation>> *table_animation = nullptr,
    const std::vector<flatbuffers::Offset<DataSetup>> *table_animation_parts_setup = nullptr) {
  auto table_parts__ = table_parts ? _fbb.CreateVector<flatbuffers::Offset<DataModelParts>>(*table_parts) : 0;
  auto table_animation__ = table_animation ? _fbb.CreateVector<flatbuffers::Offset<LibraryDataAnimation>>(*table_animation) : 0;
  auto table_animation_parts_setup__ = table_animation_parts_setup ? _fbb.CreateVector<flatbuffers::Offset<DataSetup>>(*table_animation_parts_setup) : 0;
  return ss::ssfb2::CreateDataAnimation(
      _fbb,
      version,
      table_parts__,
      catalog_parts,
      table_animation__,
      table_animation_parts_setup__);
}

struct DataEffectParts FLATBUFFERS_FINAL_CLASS : private flatbuffers::Table {
  enum FlatBuffersVTableOffset FLATBUFFERS_VTABLE_UNDERLYING_TYPE {
    VT_NAME = 4,
    VT_ID = 6,
    VT_ID_PARENT = 8,
    VT_TABLE_ID_CHILD = 10,
    VT_FEATURE = 12,
    VT_INDEX_EMITTER = 14
  };
  const flatbuffers::String *name() const {
    return GetPointer<const flatbuffers::String *>(VT_NAME);
  }
  uint16_t id() const {
    return GetField<uint16_t>(VT_ID, 0);
  }
  uint16_t id_parent() const {
    return GetField<uint16_t>(VT_ID_PARENT, 0);
  }
  const flatbuffers::Vector<int32_t> *table_id_child() const {
    return GetPointer<const flatbuffers::Vector<int32_t> *>(VT_TABLE_ID_CHILD);
  }
  uint16_t feature() const {
    return GetField<uint16_t>(VT_FEATURE, 0);
  }
  uint16_t index_emitter() const {
    return GetField<uint16_t>(VT_INDEX_EMITTER, 0);
  }
  bool Verify(flatbuffers::Verifier &verifier) const {
    return VerifyTableStart(verifier) &&
           VerifyOffset(verifier, VT_NAME) &&
           verifier.VerifyString(name()) &&
           VerifyField<uint16_t>(verifier, VT_ID) &&
           VerifyField<uint16_t>(verifier, VT_ID_PARENT) &&
           VerifyOffset(verifier, VT_TABLE_ID_CHILD) &&
           verifier.VerifyVector(table_id_child()) &&
           VerifyField<uint16_t>(verifier, VT_FEATURE) &&
           VerifyField<uint16_t>(verifier, VT_INDEX_EMITTER) &&
           verifier.EndTable();
  }
};

struct DataEffectPartsBuilder {
  flatbuffers::FlatBufferBuilder &fbb_;
  flatbuffers::uoffset_t start_;
  void add_name(flatbuffers::Offset<flatbuffers::String> name) {
    fbb_.AddOffset(DataEffectParts::VT_NAME, name);
  }
  void add_id(uint16_t id) {
    fbb_.AddElement<uint16_t>(DataEffectParts::VT_ID, id, 0);
  }
  void add_id_parent(uint16_t id_parent) {
    fbb_.AddElement<uint16_t>(DataEffectParts::VT_ID_PARENT, id_parent, 0);
  }
  void add_table_id_child(flatbuffers::Offset<flatbuffers::Vector<int32_t>> table_id_child) {
    fbb_.AddOffset(DataEffectParts::VT_TABLE_ID_CHILD, table_id_child);
  }
  void add_feature(uint16_t feature) {
    fbb_.AddElement<uint16_t>(DataEffectParts::VT_FEATURE, feature, 0);
  }
  void add_index_emitter(uint16_t index_emitter) {
    fbb_.AddElement<uint16_t>(DataEffectParts::VT_INDEX_EMITTER, index_emitter, 0);
  }
  explicit DataEffectPartsBuilder(flatbuffers::FlatBufferBuilder &_fbb)
        : fbb_(_fbb) {
    start_ = fbb_.StartTable();
  }
  DataEffectPartsBuilder &operator=(const DataEffectPartsBuilder &);
  flatbuffers::Offset<DataEffectParts> Finish() {
    const auto end = fbb_.EndTable(start_);
    auto o = flatbuffers::Offset<DataEffectParts>(end);
    return o;
  }
};

inline flatbuffers::Offset<DataEffectParts> CreateDataEffectParts(
    flatbuffers::FlatBufferBuilder &_fbb,
    flatbuffers::Offset<flatbuffers::String> name = 0,
    uint16_t id = 0,
    uint16_t id_parent = 0,
    flatbuffers::Offset<flatbuffers::Vector<int32_t>> table_id_child = 0,
    uint16_t feature = 0,
    uint16_t index_emitter = 0) {
  DataEffectPartsBuilder builder_(_fbb);
  builder_.add_table_id_child(table_id_child);
  builder_.add_name(name);
  builder_.add_index_emitter(index_emitter);
  builder_.add_feature(feature);
  builder_.add_id_parent(id_parent);
  builder_.add_id(id);
  return builder_.Finish();
}

inline flatbuffers::Offset<DataEffectParts> CreateDataEffectPartsDirect(
    flatbuffers::FlatBufferBuilder &_fbb,
    const char *name = nullptr,
    uint16_t id = 0,
    uint16_t id_parent = 0,
    const std::vector<int32_t> *table_id_child = nullptr,
    uint16_t feature = 0,
    uint16_t index_emitter = 0) {
  auto name__ = name ? _fbb.CreateString(name) : 0;
  auto table_id_child__ = table_id_child ? _fbb.CreateVector<int32_t>(*table_id_child) : 0;
  return ss::ssfb2::CreateDataEffectParts(
      _fbb,
      name__,
      id,
      id_parent,
      table_id_child__,
      feature,
      index_emitter);
}

struct DataEffectEmitter FLATBUFFERS_FINAL_CLASS : private flatbuffers::Table {
  enum FlatBuffersVTableOffset FLATBUFFERS_VTABLE_UNDERLYING_TYPE {
    VT_FLAG_DATA = 4,
    VT_OPERATION_BLEND_TARGET = 6,
    VT_INDEX_CELL_MAP = 8,
    VT_INDEX_CELL = 10,
    VT_ANGLE = 12,
    VT_GRAVITY_DIRECTIONAL = 14,
    VT_GRAVITY_POINT_POSITION = 16,
    VT_GRAVITY_POINT_POWER = 18,
    VT_POSITION = 20,
    VT_ROTATION = 22,
    VT_ROTATION_FLUCTUATION = 24,
    VT_ROTATION_FLUCTUATION_RATE = 26,
    VT_ROTATION_FLUCTUATION_RATE_TIME = 28,
    VT_RATE_TANGENTIAL_ACCELERATION = 30,
    VT_SCALE_START = 32,
    VT_SCALE_RATE_START = 34,
    VT_SCALE_END = 36,
    VT_SCALE_RATE_END = 38,
    VT_DELAY = 40,
    VT_COLOR_VERTEX = 42,
    VT_COLOR_VERTEX_FLUCTUATION = 44,
    VT_ALPHA_FADE_START = 46,
    VT_ALPHA_FADE_END = 48,
    VT_SPEED = 50,
    VT_SPEED_FLUCTUATION = 52,
    VT_TURN_DIRECTION_FLUCTUATION = 54,
    VT_SEED_RANDOM = 56,
    VT_DURATION_EMITTER = 58,
    VT_INTERVAL = 60,
    VT_DURATION_PARTICLE = 62,
    VT_COUNT_PARTICLE_MAX = 64,
    VT_COUNT_PARTICLE_EMIT = 66,
    VT_COUNT_PARTS_MAXIMUM = 68,
    VT_TABLE_PATTERN_EMIT = 70,
    VT_TABLE_PATTERN_OFFSET = 72,
    VT_TABLE_SEED_PARTICLE = 74
  };
  uint32_t flag_data() const {
    return GetField<uint32_t>(VT_FLAG_DATA, 0);
  }
  uint32_t operation_blend_target() const {
    return GetField<uint32_t>(VT_OPERATION_BLEND_TARGET, 0);
  }
  uint16_t index_cell_map() const {
    return GetField<uint16_t>(VT_INDEX_CELL_MAP, 0);
  }
  uint16_t index_cell() const {
    return GetField<uint16_t>(VT_INDEX_CELL, 0);
  }
  const RangeFloat *angle() const {
    return GetPointer<const RangeFloat *>(VT_ANGLE);
  }
  const Vector2 *gravity_directional() const {
    return GetPointer<const Vector2 *>(VT_GRAVITY_DIRECTIONAL);
  }
  const Vector2 *gravity_point_position() const {
    return GetPointer<const Vector2 *>(VT_GRAVITY_POINT_POSITION);
  }
  float gravity_point_power() const {
    return GetField<float>(VT_GRAVITY_POINT_POWER, 0.0f);
  }
  const RangeVector2 *position() const {
    return GetPointer<const RangeVector2 *>(VT_POSITION);
  }
  const RangeFloat *rotation() const {
    return GetPointer<const RangeFloat *>(VT_ROTATION);
  }
  const RangeFloat *rotation_fluctuation() const {
    return GetPointer<const RangeFloat *>(VT_ROTATION_FLUCTUATION);
  }
  float rotation_fluctuation_rate() const {
    return GetField<float>(VT_ROTATION_FLUCTUATION_RATE, 0.0f);
  }
  float rotation_fluctuation_rate_time() const {
    return GetField<float>(VT_ROTATION_FLUCTUATION_RATE_TIME, 0.0f);
  }
  const RangeFloat *rate_tangential_acceleration() const {
    return GetPointer<const RangeFloat *>(VT_RATE_TANGENTIAL_ACCELERATION);
  }
  const RangeVector2 *scale_start() const {
    return GetPointer<const RangeVector2 *>(VT_SCALE_START);
  }
  const RangeFloat *scale_rate_start() const {
    return GetPointer<const RangeFloat *>(VT_SCALE_RATE_START);
  }
  const RangeVector2 *scale_end() const {
    return GetPointer<const RangeVector2 *>(VT_SCALE_END);
  }
  const RangeFloat *scale_rate_end() const {
    return GetPointer<const RangeFloat *>(VT_SCALE_RATE_END);
  }
  int32_t delay() const {
    return GetField<int32_t>(VT_DELAY, 0);
  }
  const RangeColor *color_vertex() const {
    return GetPointer<const RangeColor *>(VT_COLOR_VERTEX);
  }
  const RangeColor *color_vertex_fluctuation() const {
    return GetPointer<const RangeColor *>(VT_COLOR_VERTEX_FLUCTUATION);
  }
  float alpha_fade_start() const {
    return GetField<float>(VT_ALPHA_FADE_START, 0.0f);
  }
  float alpha_fade_end() const {
    return GetField<float>(VT_ALPHA_FADE_END, 0.0f);
  }
  const RangeFloat *speed() const {
    return GetPointer<const RangeFloat *>(VT_SPEED);
  }
  const RangeFloat *speed_fluctuation() const {
    return GetPointer<const RangeFloat *>(VT_SPEED_FLUCTUATION);
  }
  float turn_direction_fluctuation() const {
    return GetField<float>(VT_TURN_DIRECTION_FLUCTUATION, 0.0f);
  }
  int64_t seed_random() const {
    return GetField<int64_t>(VT_SEED_RANDOM, 0);
  }
  int32_t duration_emitter() const {
    return GetField<int32_t>(VT_DURATION_EMITTER, 0);
  }
  int32_t interval() const {
    return GetField<int32_t>(VT_INTERVAL, 0);
  }
  const RangeFloat *duration_particle() const {
    return GetPointer<const RangeFloat *>(VT_DURATION_PARTICLE);
  }
  int32_t count_particle_max() const {
    return GetField<int32_t>(VT_COUNT_PARTICLE_MAX, 0);
  }
  int32_t count_particle_emit() const {
    return GetField<int32_t>(VT_COUNT_PARTICLE_EMIT, 0);
  }
  int32_t count_parts_maximum() const {
    return GetField<int32_t>(VT_COUNT_PARTS_MAXIMUM, 0);
  }
  const flatbuffers::Vector<flatbuffers::Offset<PatternEmit>> *table_pattern_emit() const {
    return GetPointer<const flatbuffers::Vector<flatbuffers::Offset<PatternEmit>> *>(VT_TABLE_PATTERN_EMIT);
  }
  const flatbuffers::Vector<int32_t> *table_pattern_offset() const {
    return GetPointer<const flatbuffers::Vector<int32_t> *>(VT_TABLE_PATTERN_OFFSET);
  }
  const flatbuffers::Vector<int64_t> *table_seed_particle() const {
    return GetPointer<const flatbuffers::Vector<int64_t> *>(VT_TABLE_SEED_PARTICLE);
  }
  bool Verify(flatbuffers::Verifier &verifier) const {
    return VerifyTableStart(verifier) &&
           VerifyField<uint32_t>(verifier, VT_FLAG_DATA) &&
           VerifyField<uint32_t>(verifier, VT_OPERATION_BLEND_TARGET) &&
           VerifyField<uint16_t>(verifier, VT_INDEX_CELL_MAP) &&
           VerifyField<uint16_t>(verifier, VT_INDEX_CELL) &&
           VerifyOffset(verifier, VT_ANGLE) &&
           verifier.VerifyTable(angle()) &&
           VerifyOffset(verifier, VT_GRAVITY_DIRECTIONAL) &&
           verifier.VerifyTable(gravity_directional()) &&
           VerifyOffset(verifier, VT_GRAVITY_POINT_POSITION) &&
           verifier.VerifyTable(gravity_point_position()) &&
           VerifyField<float>(verifier, VT_GRAVITY_POINT_POWER) &&
           VerifyOffset(verifier, VT_POSITION) &&
           verifier.VerifyTable(position()) &&
           VerifyOffset(verifier, VT_ROTATION) &&
           verifier.VerifyTable(rotation()) &&
           VerifyOffset(verifier, VT_ROTATION_FLUCTUATION) &&
           verifier.VerifyTable(rotation_fluctuation()) &&
           VerifyField<float>(verifier, VT_ROTATION_FLUCTUATION_RATE) &&
           VerifyField<float>(verifier, VT_ROTATION_FLUCTUATION_RATE_TIME) &&
           VerifyOffset(verifier, VT_RATE_TANGENTIAL_ACCELERATION) &&
           verifier.VerifyTable(rate_tangential_acceleration()) &&
           VerifyOffset(verifier, VT_SCALE_START) &&
           verifier.VerifyTable(scale_start()) &&
           VerifyOffset(verifier, VT_SCALE_RATE_START) &&
           verifier.VerifyTable(scale_rate_start()) &&
           VerifyOffset(verifier, VT_SCALE_END) &&
           verifier.VerifyTable(scale_end()) &&
           VerifyOffset(verifier, VT_SCALE_RATE_END) &&
           verifier.VerifyTable(scale_rate_end()) &&
           VerifyField<int32_t>(verifier, VT_DELAY) &&
           VerifyOffset(verifier, VT_COLOR_VERTEX) &&
           verifier.VerifyTable(color_vertex()) &&
           VerifyOffset(verifier, VT_COLOR_VERTEX_FLUCTUATION) &&
           verifier.VerifyTable(color_vertex_fluctuation()) &&
           VerifyField<float>(verifier, VT_ALPHA_FADE_START) &&
           VerifyField<float>(verifier, VT_ALPHA_FADE_END) &&
           VerifyOffset(verifier, VT_SPEED) &&
           verifier.VerifyTable(speed()) &&
           VerifyOffset(verifier, VT_SPEED_FLUCTUATION) &&
           verifier.VerifyTable(speed_fluctuation()) &&
           VerifyField<float>(verifier, VT_TURN_DIRECTION_FLUCTUATION) &&
           VerifyField<int64_t>(verifier, VT_SEED_RANDOM) &&
           VerifyField<int32_t>(verifier, VT_DURATION_EMITTER) &&
           VerifyField<int32_t>(verifier, VT_INTERVAL) &&
           VerifyOffset(verifier, VT_DURATION_PARTICLE) &&
           verifier.VerifyTable(duration_particle()) &&
           VerifyField<int32_t>(verifier, VT_COUNT_PARTICLE_MAX) &&
           VerifyField<int32_t>(verifier, VT_COUNT_PARTICLE_EMIT) &&
           VerifyField<int32_t>(verifier, VT_COUNT_PARTS_MAXIMUM) &&
           VerifyOffset(verifier, VT_TABLE_PATTERN_EMIT) &&
           verifier.VerifyVector(table_pattern_emit()) &&
           verifier.VerifyVectorOfTables(table_pattern_emit()) &&
           VerifyOffset(verifier, VT_TABLE_PATTERN_OFFSET) &&
           verifier.VerifyVector(table_pattern_offset()) &&
           VerifyOffset(verifier, VT_TABLE_SEED_PARTICLE) &&
           verifier.VerifyVector(table_seed_particle()) &&
           verifier.EndTable();
  }
};

struct DataEffectEmitterBuilder {
  flatbuffers::FlatBufferBuilder &fbb_;
  flatbuffers::uoffset_t start_;
  void add_flag_data(uint32_t flag_data) {
    fbb_.AddElement<uint32_t>(DataEffectEmitter::VT_FLAG_DATA, flag_data, 0);
  }
  void add_operation_blend_target(uint32_t operation_blend_target) {
    fbb_.AddElement<uint32_t>(DataEffectEmitter::VT_OPERATION_BLEND_TARGET, operation_blend_target, 0);
  }
  void add_index_cell_map(uint16_t index_cell_map) {
    fbb_.AddElement<uint16_t>(DataEffectEmitter::VT_INDEX_CELL_MAP, index_cell_map, 0);
  }
  void add_index_cell(uint16_t index_cell) {
    fbb_.AddElement<uint16_t>(DataEffectEmitter::VT_INDEX_CELL, index_cell, 0);
  }
  void add_angle(flatbuffers::Offset<RangeFloat> angle) {
    fbb_.AddOffset(DataEffectEmitter::VT_ANGLE, angle);
  }
  void add_gravity_directional(flatbuffers::Offset<Vector2> gravity_directional) {
    fbb_.AddOffset(DataEffectEmitter::VT_GRAVITY_DIRECTIONAL, gravity_directional);
  }
  void add_gravity_point_position(flatbuffers::Offset<Vector2> gravity_point_position) {
    fbb_.AddOffset(DataEffectEmitter::VT_GRAVITY_POINT_POSITION, gravity_point_position);
  }
  void add_gravity_point_power(float gravity_point_power) {
    fbb_.AddElement<float>(DataEffectEmitter::VT_GRAVITY_POINT_POWER, gravity_point_power, 0.0f);
  }
  void add_position(flatbuffers::Offset<RangeVector2> position) {
    fbb_.AddOffset(DataEffectEmitter::VT_POSITION, position);
  }
  void add_rotation(flatbuffers::Offset<RangeFloat> rotation) {
    fbb_.AddOffset(DataEffectEmitter::VT_ROTATION, rotation);
  }
  void add_rotation_fluctuation(flatbuffers::Offset<RangeFloat> rotation_fluctuation) {
    fbb_.AddOffset(DataEffectEmitter::VT_ROTATION_FLUCTUATION, rotation_fluctuation);
  }
  void add_rotation_fluctuation_rate(float rotation_fluctuation_rate) {
    fbb_.AddElement<float>(DataEffectEmitter::VT_ROTATION_FLUCTUATION_RATE, rotation_fluctuation_rate, 0.0f);
  }
  void add_rotation_fluctuation_rate_time(float rotation_fluctuation_rate_time) {
    fbb_.AddElement<float>(DataEffectEmitter::VT_ROTATION_FLUCTUATION_RATE_TIME, rotation_fluctuation_rate_time, 0.0f);
  }
  void add_rate_tangential_acceleration(flatbuffers::Offset<RangeFloat> rate_tangential_acceleration) {
    fbb_.AddOffset(DataEffectEmitter::VT_RATE_TANGENTIAL_ACCELERATION, rate_tangential_acceleration);
  }
  void add_scale_start(flatbuffers::Offset<RangeVector2> scale_start) {
    fbb_.AddOffset(DataEffectEmitter::VT_SCALE_START, scale_start);
  }
  void add_scale_rate_start(flatbuffers::Offset<RangeFloat> scale_rate_start) {
    fbb_.AddOffset(DataEffectEmitter::VT_SCALE_RATE_START, scale_rate_start);
  }
  void add_scale_end(flatbuffers::Offset<RangeVector2> scale_end) {
    fbb_.AddOffset(DataEffectEmitter::VT_SCALE_END, scale_end);
  }
  void add_scale_rate_end(flatbuffers::Offset<RangeFloat> scale_rate_end) {
    fbb_.AddOffset(DataEffectEmitter::VT_SCALE_RATE_END, scale_rate_end);
  }
  void add_delay(int32_t delay) {
    fbb_.AddElement<int32_t>(DataEffectEmitter::VT_DELAY, delay, 0);
  }
  void add_color_vertex(flatbuffers::Offset<RangeColor> color_vertex) {
    fbb_.AddOffset(DataEffectEmitter::VT_COLOR_VERTEX, color_vertex);
  }
  void add_color_vertex_fluctuation(flatbuffers::Offset<RangeColor> color_vertex_fluctuation) {
    fbb_.AddOffset(DataEffectEmitter::VT_COLOR_VERTEX_FLUCTUATION, color_vertex_fluctuation);
  }
  void add_alpha_fade_start(float alpha_fade_start) {
    fbb_.AddElement<float>(DataEffectEmitter::VT_ALPHA_FADE_START, alpha_fade_start, 0.0f);
  }
  void add_alpha_fade_end(float alpha_fade_end) {
    fbb_.AddElement<float>(DataEffectEmitter::VT_ALPHA_FADE_END, alpha_fade_end, 0.0f);
  }
  void add_speed(flatbuffers::Offset<RangeFloat> speed) {
    fbb_.AddOffset(DataEffectEmitter::VT_SPEED, speed);
  }
  void add_speed_fluctuation(flatbuffers::Offset<RangeFloat> speed_fluctuation) {
    fbb_.AddOffset(DataEffectEmitter::VT_SPEED_FLUCTUATION, speed_fluctuation);
  }
  void add_turn_direction_fluctuation(float turn_direction_fluctuation) {
    fbb_.AddElement<float>(DataEffectEmitter::VT_TURN_DIRECTION_FLUCTUATION, turn_direction_fluctuation, 0.0f);
  }
  void add_seed_random(int64_t seed_random) {
    fbb_.AddElement<int64_t>(DataEffectEmitter::VT_SEED_RANDOM, seed_random, 0);
  }
  void add_duration_emitter(int32_t duration_emitter) {
    fbb_.AddElement<int32_t>(DataEffectEmitter::VT_DURATION_EMITTER, duration_emitter, 0);
  }
  void add_interval(int32_t interval) {
    fbb_.AddElement<int32_t>(DataEffectEmitter::VT_INTERVAL, interval, 0);
  }
  void add_duration_particle(flatbuffers::Offset<RangeFloat> duration_particle) {
    fbb_.AddOffset(DataEffectEmitter::VT_DURATION_PARTICLE, duration_particle);
  }
  void add_count_particle_max(int32_t count_particle_max) {
    fbb_.AddElement<int32_t>(DataEffectEmitter::VT_COUNT_PARTICLE_MAX, count_particle_max, 0);
  }
  void add_count_particle_emit(int32_t count_particle_emit) {
    fbb_.AddElement<int32_t>(DataEffectEmitter::VT_COUNT_PARTICLE_EMIT, count_particle_emit, 0);
  }
  void add_count_parts_maximum(int32_t count_parts_maximum) {
    fbb_.AddElement<int32_t>(DataEffectEmitter::VT_COUNT_PARTS_MAXIMUM, count_parts_maximum, 0);
  }
  void add_table_pattern_emit(flatbuffers::Offset<flatbuffers::Vector<flatbuffers::Offset<PatternEmit>>> table_pattern_emit) {
    fbb_.AddOffset(DataEffectEmitter::VT_TABLE_PATTERN_EMIT, table_pattern_emit);
  }
  void add_table_pattern_offset(flatbuffers::Offset<flatbuffers::Vector<int32_t>> table_pattern_offset) {
    fbb_.AddOffset(DataEffectEmitter::VT_TABLE_PATTERN_OFFSET, table_pattern_offset);
  }
  void add_table_seed_particle(flatbuffers::Offset<flatbuffers::Vector<int64_t>> table_seed_particle) {
    fbb_.AddOffset(DataEffectEmitter::VT_TABLE_SEED_PARTICLE, table_seed_particle);
  }
  explicit DataEffectEmitterBuilder(flatbuffers::FlatBufferBuilder &_fbb)
        : fbb_(_fbb) {
    start_ = fbb_.StartTable();
  }
  DataEffectEmitterBuilder &operator=(const DataEffectEmitterBuilder &);
  flatbuffers::Offset<DataEffectEmitter> Finish() {
    const auto end = fbb_.EndTable(start_);
    auto o = flatbuffers::Offset<DataEffectEmitter>(end);
    return o;
  }
};

inline flatbuffers::Offset<DataEffectEmitter> CreateDataEffectEmitter(
    flatbuffers::FlatBufferBuilder &_fbb,
    uint32_t flag_data = 0,
    uint32_t operation_blend_target = 0,
    uint16_t index_cell_map = 0,
    uint16_t index_cell = 0,
    flatbuffers::Offset<RangeFloat> angle = 0,
    flatbuffers::Offset<Vector2> gravity_directional = 0,
    flatbuffers::Offset<Vector2> gravity_point_position = 0,
    float gravity_point_power = 0.0f,
    flatbuffers::Offset<RangeVector2> position = 0,
    flatbuffers::Offset<RangeFloat> rotation = 0,
    flatbuffers::Offset<RangeFloat> rotation_fluctuation = 0,
    float rotation_fluctuation_rate = 0.0f,
    float rotation_fluctuation_rate_time = 0.0f,
    flatbuffers::Offset<RangeFloat> rate_tangential_acceleration = 0,
    flatbuffers::Offset<RangeVector2> scale_start = 0,
    flatbuffers::Offset<RangeFloat> scale_rate_start = 0,
    flatbuffers::Offset<RangeVector2> scale_end = 0,
    flatbuffers::Offset<RangeFloat> scale_rate_end = 0,
    int32_t delay = 0,
    flatbuffers::Offset<RangeColor> color_vertex = 0,
    flatbuffers::Offset<RangeColor> color_vertex_fluctuation = 0,
    float alpha_fade_start = 0.0f,
    float alpha_fade_end = 0.0f,
    flatbuffers::Offset<RangeFloat> speed = 0,
    flatbuffers::Offset<RangeFloat> speed_fluctuation = 0,
    float turn_direction_fluctuation = 0.0f,
    int64_t seed_random = 0,
    int32_t duration_emitter = 0,
    int32_t interval = 0,
    flatbuffers::Offset<RangeFloat> duration_particle = 0,
    int32_t count_particle_max = 0,
    int32_t count_particle_emit = 0,
    int32_t count_parts_maximum = 0,
    flatbuffers::Offset<flatbuffers::Vector<flatbuffers::Offset<PatternEmit>>> table_pattern_emit = 0,
    flatbuffers::Offset<flatbuffers::Vector<int32_t>> table_pattern_offset = 0,
    flatbuffers::Offset<flatbuffers::Vector<int64_t>> table_seed_particle = 0) {
  DataEffectEmitterBuilder builder_(_fbb);
  builder_.add_seed_random(seed_random);
  builder_.add_table_seed_particle(table_seed_particle);
  builder_.add_table_pattern_offset(table_pattern_offset);
  builder_.add_table_pattern_emit(table_pattern_emit);
  builder_.add_count_parts_maximum(count_parts_maximum);
  builder_.add_count_particle_emit(count_particle_emit);
  builder_.add_count_particle_max(count_particle_max);
  builder_.add_duration_particle(duration_particle);
  builder_.add_interval(interval);
  builder_.add_duration_emitter(duration_emitter);
  builder_.add_turn_direction_fluctuation(turn_direction_fluctuation);
  builder_.add_speed_fluctuation(speed_fluctuation);
  builder_.add_speed(speed);
  builder_.add_alpha_fade_end(alpha_fade_end);
  builder_.add_alpha_fade_start(alpha_fade_start);
  builder_.add_color_vertex_fluctuation(color_vertex_fluctuation);
  builder_.add_color_vertex(color_vertex);
  builder_.add_delay(delay);
  builder_.add_scale_rate_end(scale_rate_end);
  builder_.add_scale_end(scale_end);
  builder_.add_scale_rate_start(scale_rate_start);
  builder_.add_scale_start(scale_start);
  builder_.add_rate_tangential_acceleration(rate_tangential_acceleration);
  builder_.add_rotation_fluctuation_rate_time(rotation_fluctuation_rate_time);
  builder_.add_rotation_fluctuation_rate(rotation_fluctuation_rate);
  builder_.add_rotation_fluctuation(rotation_fluctuation);
  builder_.add_rotation(rotation);
  builder_.add_position(position);
  builder_.add_gravity_point_power(gravity_point_power);
  builder_.add_gravity_point_position(gravity_point_position);
  builder_.add_gravity_directional(gravity_directional);
  builder_.add_angle(angle);
  builder_.add_operation_blend_target(operation_blend_target);
  builder_.add_flag_data(flag_data);
  builder_.add_index_cell(index_cell);
  builder_.add_index_cell_map(index_cell_map);
  return builder_.Finish();
}

inline flatbuffers::Offset<DataEffectEmitter> CreateDataEffectEmitterDirect(
    flatbuffers::FlatBufferBuilder &_fbb,
    uint32_t flag_data = 0,
    uint32_t operation_blend_target = 0,
    uint16_t index_cell_map = 0,
    uint16_t index_cell = 0,
    flatbuffers::Offset<RangeFloat> angle = 0,
    flatbuffers::Offset<Vector2> gravity_directional = 0,
    flatbuffers::Offset<Vector2> gravity_point_position = 0,
    float gravity_point_power = 0.0f,
    flatbuffers::Offset<RangeVector2> position = 0,
    flatbuffers::Offset<RangeFloat> rotation = 0,
    flatbuffers::Offset<RangeFloat> rotation_fluctuation = 0,
    float rotation_fluctuation_rate = 0.0f,
    float rotation_fluctuation_rate_time = 0.0f,
    flatbuffers::Offset<RangeFloat> rate_tangential_acceleration = 0,
    flatbuffers::Offset<RangeVector2> scale_start = 0,
    flatbuffers::Offset<RangeFloat> scale_rate_start = 0,
    flatbuffers::Offset<RangeVector2> scale_end = 0,
    flatbuffers::Offset<RangeFloat> scale_rate_end = 0,
    int32_t delay = 0,
    flatbuffers::Offset<RangeColor> color_vertex = 0,
    flatbuffers::Offset<RangeColor> color_vertex_fluctuation = 0,
    float alpha_fade_start = 0.0f,
    float alpha_fade_end = 0.0f,
    flatbuffers::Offset<RangeFloat> speed = 0,
    flatbuffers::Offset<RangeFloat> speed_fluctuation = 0,
    float turn_direction_fluctuation = 0.0f,
    int64_t seed_random = 0,
    int32_t duration_emitter = 0,
    int32_t interval = 0,
    flatbuffers::Offset<RangeFloat> duration_particle = 0,
    int32_t count_particle_max = 0,
    int32_t count_particle_emit = 0,
    int32_t count_parts_maximum = 0,
    const std::vector<flatbuffers::Offset<PatternEmit>> *table_pattern_emit = nullptr,
    const std::vector<int32_t> *table_pattern_offset = nullptr,
    const std::vector<int64_t> *table_seed_particle = nullptr) {
  auto table_pattern_emit__ = table_pattern_emit ? _fbb.CreateVector<flatbuffers::Offset<PatternEmit>>(*table_pattern_emit) : 0;
  auto table_pattern_offset__ = table_pattern_offset ? _fbb.CreateVector<int32_t>(*table_pattern_offset) : 0;
  auto table_seed_particle__ = table_seed_particle ? _fbb.CreateVector<int64_t>(*table_seed_particle) : 0;
  return ss::ssfb2::CreateDataEffectEmitter(
      _fbb,
      flag_data,
      operation_blend_target,
      index_cell_map,
      index_cell,
      angle,
      gravity_directional,
      gravity_point_position,
      gravity_point_power,
      position,
      rotation,
      rotation_fluctuation,
      rotation_fluctuation_rate,
      rotation_fluctuation_rate_time,
      rate_tangential_acceleration,
      scale_start,
      scale_rate_start,
      scale_end,
      scale_rate_end,
      delay,
      color_vertex,
      color_vertex_fluctuation,
      alpha_fade_start,
      alpha_fade_end,
      speed,
      speed_fluctuation,
      turn_direction_fluctuation,
      seed_random,
      duration_emitter,
      interval,
      duration_particle,
      count_particle_max,
      count_particle_emit,
      count_parts_maximum,
      table_pattern_emit__,
      table_pattern_offset__,
      table_seed_particle__);
}

struct DataEffect FLATBUFFERS_FINAL_CLASS : private flatbuffers::Table {
  enum FlatBuffersVTableOffset FLATBUFFERS_VTABLE_UNDERLYING_TYPE {
    VT_VERSION = 4,
    VT_FLAG_DATA = 6,
    VT_SEED_RANDOM = 8,
    VT_VERSION_RENDERER = 10,
    VT_COUNT_MAX_PARTICLE = 12,
    VT_COUNT_FRAME_PER_SECOND = 14,
    VT_SCALE_LAYOUT = 16,
    VT_TABLE_PARTS = 18,
    VT_TABLE_EMITTER = 20,
    VT_TABLE_INDEX_EMITTER_ORDER_DRAW = 22
  };
  uint32_t version() const {
    return GetField<uint32_t>(VT_VERSION, 0);
  }
  int32_t flag_data() const {
    return GetField<int32_t>(VT_FLAG_DATA, 0);
  }
  int32_t seed_random() const {
    return GetField<int32_t>(VT_SEED_RANDOM, 0);
  }
  int32_t version_renderer() const {
    return GetField<int32_t>(VT_VERSION_RENDERER, 0);
  }
  int32_t count_max_particle() const {
    return GetField<int32_t>(VT_COUNT_MAX_PARTICLE, 0);
  }
  int32_t count_frame_per_second() const {
    return GetField<int32_t>(VT_COUNT_FRAME_PER_SECOND, 0);
  }
  const Vector2 *scale_layout() const {
    return GetPointer<const Vector2 *>(VT_SCALE_LAYOUT);
  }
  const flatbuffers::Vector<flatbuffers::Offset<DataEffectParts>> *table_parts() const {
    return GetPointer<const flatbuffers::Vector<flatbuffers::Offset<DataEffectParts>> *>(VT_TABLE_PARTS);
  }
  const flatbuffers::Vector<flatbuffers::Offset<DataEffectEmitter>> *table_emitter() const {
    return GetPointer<const flatbuffers::Vector<flatbuffers::Offset<DataEffectEmitter>> *>(VT_TABLE_EMITTER);
  }
  const flatbuffers::Vector<int32_t> *table_index_emitter_order_draw() const {
    return GetPointer<const flatbuffers::Vector<int32_t> *>(VT_TABLE_INDEX_EMITTER_ORDER_DRAW);
  }
  bool Verify(flatbuffers::Verifier &verifier) const {
    return VerifyTableStart(verifier) &&
           VerifyField<uint32_t>(verifier, VT_VERSION) &&
           VerifyField<int32_t>(verifier, VT_FLAG_DATA) &&
           VerifyField<int32_t>(verifier, VT_SEED_RANDOM) &&
           VerifyField<int32_t>(verifier, VT_VERSION_RENDERER) &&
           VerifyField<int32_t>(verifier, VT_COUNT_MAX_PARTICLE) &&
           VerifyField<int32_t>(verifier, VT_COUNT_FRAME_PER_SECOND) &&
           VerifyOffset(verifier, VT_SCALE_LAYOUT) &&
           verifier.VerifyTable(scale_layout()) &&
           VerifyOffset(verifier, VT_TABLE_PARTS) &&
           verifier.VerifyVector(table_parts()) &&
           verifier.VerifyVectorOfTables(table_parts()) &&
           VerifyOffset(verifier, VT_TABLE_EMITTER) &&
           verifier.VerifyVector(table_emitter()) &&
           verifier.VerifyVectorOfTables(table_emitter()) &&
           VerifyOffset(verifier, VT_TABLE_INDEX_EMITTER_ORDER_DRAW) &&
           verifier.VerifyVector(table_index_emitter_order_draw()) &&
           verifier.EndTable();
  }
};

struct DataEffectBuilder {
  flatbuffers::FlatBufferBuilder &fbb_;
  flatbuffers::uoffset_t start_;
  void add_version(uint32_t version) {
    fbb_.AddElement<uint32_t>(DataEffect::VT_VERSION, version, 0);
  }
  void add_flag_data(int32_t flag_data) {
    fbb_.AddElement<int32_t>(DataEffect::VT_FLAG_DATA, flag_data, 0);
  }
  void add_seed_random(int32_t seed_random) {
    fbb_.AddElement<int32_t>(DataEffect::VT_SEED_RANDOM, seed_random, 0);
  }
  void add_version_renderer(int32_t version_renderer) {
    fbb_.AddElement<int32_t>(DataEffect::VT_VERSION_RENDERER, version_renderer, 0);
  }
  void add_count_max_particle(int32_t count_max_particle) {
    fbb_.AddElement<int32_t>(DataEffect::VT_COUNT_MAX_PARTICLE, count_max_particle, 0);
  }
  void add_count_frame_per_second(int32_t count_frame_per_second) {
    fbb_.AddElement<int32_t>(DataEffect::VT_COUNT_FRAME_PER_SECOND, count_frame_per_second, 0);
  }
  void add_scale_layout(flatbuffers::Offset<Vector2> scale_layout) {
    fbb_.AddOffset(DataEffect::VT_SCALE_LAYOUT, scale_layout);
  }
  void add_table_parts(flatbuffers::Offset<flatbuffers::Vector<flatbuffers::Offset<DataEffectParts>>> table_parts) {
    fbb_.AddOffset(DataEffect::VT_TABLE_PARTS, table_parts);
  }
  void add_table_emitter(flatbuffers::Offset<flatbuffers::Vector<flatbuffers::Offset<DataEffectEmitter>>> table_emitter) {
    fbb_.AddOffset(DataEffect::VT_TABLE_EMITTER, table_emitter);
  }
  void add_table_index_emitter_order_draw(flatbuffers::Offset<flatbuffers::Vector<int32_t>> table_index_emitter_order_draw) {
    fbb_.AddOffset(DataEffect::VT_TABLE_INDEX_EMITTER_ORDER_DRAW, table_index_emitter_order_draw);
  }
  explicit DataEffectBuilder(flatbuffers::FlatBufferBuilder &_fbb)
        : fbb_(_fbb) {
    start_ = fbb_.StartTable();
  }
  DataEffectBuilder &operator=(const DataEffectBuilder &);
  flatbuffers::Offset<DataEffect> Finish() {
    const auto end = fbb_.EndTable(start_);
    auto o = flatbuffers::Offset<DataEffect>(end);
    return o;
  }
};

inline flatbuffers::Offset<DataEffect> CreateDataEffect(
    flatbuffers::FlatBufferBuilder &_fbb,
    uint32_t version = 0,
    int32_t flag_data = 0,
    int32_t seed_random = 0,
    int32_t version_renderer = 0,
    int32_t count_max_particle = 0,
    int32_t count_frame_per_second = 0,
    flatbuffers::Offset<Vector2> scale_layout = 0,
    flatbuffers::Offset<flatbuffers::Vector<flatbuffers::Offset<DataEffectParts>>> table_parts = 0,
    flatbuffers::Offset<flatbuffers::Vector<flatbuffers::Offset<DataEffectEmitter>>> table_emitter = 0,
    flatbuffers::Offset<flatbuffers::Vector<int32_t>> table_index_emitter_order_draw = 0) {
  DataEffectBuilder builder_(_fbb);
  builder_.add_table_index_emitter_order_draw(table_index_emitter_order_draw);
  builder_.add_table_emitter(table_emitter);
  builder_.add_table_parts(table_parts);
  builder_.add_scale_layout(scale_layout);
  builder_.add_count_frame_per_second(count_frame_per_second);
  builder_.add_count_max_particle(count_max_particle);
  builder_.add_version_renderer(version_renderer);
  builder_.add_seed_random(seed_random);
  builder_.add_flag_data(flag_data);
  builder_.add_version(version);
  return builder_.Finish();
}

inline flatbuffers::Offset<DataEffect> CreateDataEffectDirect(
    flatbuffers::FlatBufferBuilder &_fbb,
    uint32_t version = 0,
    int32_t flag_data = 0,
    int32_t seed_random = 0,
    int32_t version_renderer = 0,
    int32_t count_max_particle = 0,
    int32_t count_frame_per_second = 0,
    flatbuffers::Offset<Vector2> scale_layout = 0,
    const std::vector<flatbuffers::Offset<DataEffectParts>> *table_parts = nullptr,
    const std::vector<flatbuffers::Offset<DataEffectEmitter>> *table_emitter = nullptr,
    const std::vector<int32_t> *table_index_emitter_order_draw = nullptr) {
  auto table_parts__ = table_parts ? _fbb.CreateVector<flatbuffers::Offset<DataEffectParts>>(*table_parts) : 0;
  auto table_emitter__ = table_emitter ? _fbb.CreateVector<flatbuffers::Offset<DataEffectEmitter>>(*table_emitter) : 0;
  auto table_index_emitter_order_draw__ = table_index_emitter_order_draw ? _fbb.CreateVector<int32_t>(*table_index_emitter_order_draw) : 0;
  return ss::ssfb2::CreateDataEffect(
      _fbb,
      version,
      flag_data,
      seed_random,
      version_renderer,
      count_max_particle,
      count_frame_per_second,
      scale_layout,
      table_parts__,
      table_emitter__,
      table_index_emitter_order_draw__);
}

struct ProjectData FLATBUFFERS_FINAL_CLASS : private flatbuffers::Table {
  enum FlatBuffersVTableOffset FLATBUFFERS_VTABLE_UNDERLYING_TYPE {
    VT_VERSION = 4,
    VT_CELL_MAP = 6,
    VT_ANIMATION = 8,
    VT_EFFECT = 10
  };
  uint32_t version() const {
    return GetField<uint32_t>(VT_VERSION, 0);
  }
  const DataCellMap *cell_map() const {
    return GetPointer<const DataCellMap *>(VT_CELL_MAP);
  }
  const flatbuffers::Vector<flatbuffers::Offset<DataAnimation>> *animation() const {
    return GetPointer<const flatbuffers::Vector<flatbuffers::Offset<DataAnimation>> *>(VT_ANIMATION);
  }
  const flatbuffers::Vector<flatbuffers::Offset<DataEffect>> *effect() const {
    return GetPointer<const flatbuffers::Vector<flatbuffers::Offset<DataEffect>> *>(VT_EFFECT);
  }
  bool Verify(flatbuffers::Verifier &verifier) const {
    return VerifyTableStart(verifier) &&
           VerifyField<uint32_t>(verifier, VT_VERSION) &&
           VerifyOffset(verifier, VT_CELL_MAP) &&
           verifier.VerifyTable(cell_map()) &&
           VerifyOffset(verifier, VT_ANIMATION) &&
           verifier.VerifyVector(animation()) &&
           verifier.VerifyVectorOfTables(animation()) &&
           VerifyOffset(verifier, VT_EFFECT) &&
           verifier.VerifyVector(effect()) &&
           verifier.VerifyVectorOfTables(effect()) &&
           verifier.EndTable();
  }
};

struct ProjectDataBuilder {
  flatbuffers::FlatBufferBuilder &fbb_;
  flatbuffers::uoffset_t start_;
  void add_version(uint32_t version) {
    fbb_.AddElement<uint32_t>(ProjectData::VT_VERSION, version, 0);
  }
  void add_cell_map(flatbuffers::Offset<DataCellMap> cell_map) {
    fbb_.AddOffset(ProjectData::VT_CELL_MAP, cell_map);
  }
  void add_animation(flatbuffers::Offset<flatbuffers::Vector<flatbuffers::Offset<DataAnimation>>> animation) {
    fbb_.AddOffset(ProjectData::VT_ANIMATION, animation);
  }
  void add_effect(flatbuffers::Offset<flatbuffers::Vector<flatbuffers::Offset<DataEffect>>> effect) {
    fbb_.AddOffset(ProjectData::VT_EFFECT, effect);
  }
  explicit ProjectDataBuilder(flatbuffers::FlatBufferBuilder &_fbb)
        : fbb_(_fbb) {
    start_ = fbb_.StartTable();
  }
  ProjectDataBuilder &operator=(const ProjectDataBuilder &);
  flatbuffers::Offset<ProjectData> Finish() {
    const auto end = fbb_.EndTable(start_);
    auto o = flatbuffers::Offset<ProjectData>(end);
    return o;
  }
};

inline flatbuffers::Offset<ProjectData> CreateProjectData(
    flatbuffers::FlatBufferBuilder &_fbb,
    uint32_t version = 0,
    flatbuffers::Offset<DataCellMap> cell_map = 0,
    flatbuffers::Offset<flatbuffers::Vector<flatbuffers::Offset<DataAnimation>>> animation = 0,
    flatbuffers::Offset<flatbuffers::Vector<flatbuffers::Offset<DataEffect>>> effect = 0) {
  ProjectDataBuilder builder_(_fbb);
  builder_.add_effect(effect);
  builder_.add_animation(animation);
  builder_.add_cell_map(cell_map);
  builder_.add_version(version);
  return builder_.Finish();
}

inline flatbuffers::Offset<ProjectData> CreateProjectDataDirect(
    flatbuffers::FlatBufferBuilder &_fbb,
    uint32_t version = 0,
    flatbuffers::Offset<DataCellMap> cell_map = 0,
    const std::vector<flatbuffers::Offset<DataAnimation>> *animation = nullptr,
    const std::vector<flatbuffers::Offset<DataEffect>> *effect = nullptr) {
  auto animation__ = animation ? _fbb.CreateVector<flatbuffers::Offset<DataAnimation>>(*animation) : 0;
  auto effect__ = effect ? _fbb.CreateVector<flatbuffers::Offset<DataEffect>>(*effect) : 0;
  return ss::ssfb2::CreateProjectData(
      _fbb,
      version,
      cell_map,
      animation__,
      effect__);
}

inline const ss::ssfb2::ProjectData *GetProjectData(const void *buf) {
  return flatbuffers::GetRoot<ss::ssfb2::ProjectData>(buf);
}

inline const ss::ssfb2::ProjectData *GetSizePrefixedProjectData(const void *buf) {
  return flatbuffers::GetSizePrefixedRoot<ss::ssfb2::ProjectData>(buf);
}

inline const char *ProjectDataIdentifier() {
  return "SFB2";
}

inline bool ProjectDataBufferHasIdentifier(const void *buf) {
  return flatbuffers::BufferHasIdentifier(
      buf, ProjectDataIdentifier());
}

inline bool VerifyProjectDataBuffer(
    flatbuffers::Verifier &verifier) {
  return verifier.VerifyBuffer<ss::ssfb2::ProjectData>(ProjectDataIdentifier());
}

inline bool VerifySizePrefixedProjectDataBuffer(
    flatbuffers::Verifier &verifier) {
  return verifier.VerifySizePrefixedBuffer<ss::ssfb2::ProjectData>(ProjectDataIdentifier());
}

inline void FinishProjectDataBuffer(
    flatbuffers::FlatBufferBuilder &fbb,
    flatbuffers::Offset<ss::ssfb2::ProjectData> root) {
  fbb.Finish(root, ProjectDataIdentifier());
}

inline void FinishSizePrefixedProjectDataBuffer(
    flatbuffers::FlatBufferBuilder &fbb,
    flatbuffers::Offset<ss::ssfb2::ProjectData> root) {
  fbb.FinishSizePrefixed(root, ProjectDataIdentifier());
}

}  // namespace ssfb2
}  // namespace ss

#endif  // FLATBUFFERS_GENERATED_SSFB2_SS_SSFB2_H_
