// automatically generated by the FlatBuffers compiler, do not modify


#ifndef FLATBUFFERS_GENERATED_SSFB_SS_SSFB_H_
#define FLATBUFFERS_GENERATED_SSFB_SS_SSFB_H_

#include "flatbuffers/flatbuffers.h"

namespace ss {
namespace ssfb {

struct EffectParticleElementBasic;

struct EffectNode;
struct EffectNodeBuilder;
struct EffectNodeT;

struct EffectFile;
struct EffectFileBuilder;
struct EffectFileT;

struct CellMap;
struct CellMapBuilder;
struct CellMapT;

struct Cell;
struct CellBuilder;
struct CellT;

struct MeshDataUV;
struct MeshDataUVBuilder;
struct MeshDataUVT;

struct MeshDataIndices;
struct MeshDataIndicesBuilder;
struct MeshDataIndicesT;

struct PartState;
struct PartStateBuilder;
struct PartStateT;

struct FrameDataIndex;
struct FrameDataIndexBuilder;
struct FrameDataIndexT;

struct UserDataItem;
struct UserDataItemBuilder;
struct UserDataItemT;

struct UserDataPerFrame;
struct UserDataPerFrameBuilder;
struct UserDataPerFrameT;

struct LabelDataItem;
struct LabelDataItemBuilder;
struct LabelDataItemT;

struct AnimationData;
struct AnimationDataBuilder;
struct AnimationDataT;

struct AnimationInitialData;
struct AnimationInitialDataBuilder;
struct AnimationInitialDataT;

struct PartData;
struct PartDataBuilder;
struct PartDataT;

struct AnimePackData;
struct AnimePackDataBuilder;
struct AnimePackDataT;

struct ProjectData;
struct ProjectDataBuilder;
struct ProjectDataT;

bool operator==(const EffectParticleElementBasic &lhs, const EffectParticleElementBasic &rhs);
bool operator!=(const EffectParticleElementBasic &lhs, const EffectParticleElementBasic &rhs);
bool operator==(const EffectNodeT &lhs, const EffectNodeT &rhs);
bool operator!=(const EffectNodeT &lhs, const EffectNodeT &rhs);
bool operator==(const EffectFileT &lhs, const EffectFileT &rhs);
bool operator!=(const EffectFileT &lhs, const EffectFileT &rhs);
bool operator==(const CellMapT &lhs, const CellMapT &rhs);
bool operator!=(const CellMapT &lhs, const CellMapT &rhs);
bool operator==(const CellT &lhs, const CellT &rhs);
bool operator!=(const CellT &lhs, const CellT &rhs);
bool operator==(const MeshDataUVT &lhs, const MeshDataUVT &rhs);
bool operator!=(const MeshDataUVT &lhs, const MeshDataUVT &rhs);
bool operator==(const MeshDataIndicesT &lhs, const MeshDataIndicesT &rhs);
bool operator!=(const MeshDataIndicesT &lhs, const MeshDataIndicesT &rhs);
bool operator==(const PartStateT &lhs, const PartStateT &rhs);
bool operator!=(const PartStateT &lhs, const PartStateT &rhs);
bool operator==(const FrameDataIndexT &lhs, const FrameDataIndexT &rhs);
bool operator!=(const FrameDataIndexT &lhs, const FrameDataIndexT &rhs);
bool operator==(const UserDataItemT &lhs, const UserDataItemT &rhs);
bool operator!=(const UserDataItemT &lhs, const UserDataItemT &rhs);
bool operator==(const UserDataPerFrameT &lhs, const UserDataPerFrameT &rhs);
bool operator!=(const UserDataPerFrameT &lhs, const UserDataPerFrameT &rhs);
bool operator==(const LabelDataItemT &lhs, const LabelDataItemT &rhs);
bool operator!=(const LabelDataItemT &lhs, const LabelDataItemT &rhs);
bool operator==(const AnimationDataT &lhs, const AnimationDataT &rhs);
bool operator!=(const AnimationDataT &lhs, const AnimationDataT &rhs);
bool operator==(const AnimationInitialDataT &lhs, const AnimationInitialDataT &rhs);
bool operator!=(const AnimationInitialDataT &lhs, const AnimationInitialDataT &rhs);
bool operator==(const PartDataT &lhs, const PartDataT &rhs);
bool operator!=(const PartDataT &lhs, const PartDataT &rhs);
bool operator==(const AnimePackDataT &lhs, const AnimePackDataT &rhs);
bool operator!=(const AnimePackDataT &lhs, const AnimePackDataT &rhs);
bool operator==(const ProjectDataT &lhs, const ProjectDataT &rhs);
bool operator!=(const ProjectDataT &lhs, const ProjectDataT &rhs);

enum SsPartType : int8_t {
  SsPartType_Invalid = -1,
  SsPartType_Nulltype = 0,
  SsPartType_Normal = 1,
  SsPartType_Text = 2,
  SsPartType_Instance = 3,
  SsPartType_Armature = 4,
  SsPartType_Effect = 5,
  SsPartType_Mesh = 6,
  SsPartType_Movenode = 7,
  SsPartType_Constraint = 8,
  SsPartType_Mask = 9,
  SsPartType_Joint = 10,
  SsPartType_Bonepoint = 11,
  SsPartType_MIN = SsPartType_Invalid,
  SsPartType_MAX = SsPartType_Bonepoint
};

inline const SsPartType (&EnumValuesSsPartType())[13] {
  static const SsPartType values[] = {
    SsPartType_Invalid,
    SsPartType_Nulltype,
    SsPartType_Normal,
    SsPartType_Text,
    SsPartType_Instance,
    SsPartType_Armature,
    SsPartType_Effect,
    SsPartType_Mesh,
    SsPartType_Movenode,
    SsPartType_Constraint,
    SsPartType_Mask,
    SsPartType_Joint,
    SsPartType_Bonepoint
  };
  return values;
}

inline const char * const *EnumNamesSsPartType() {
  static const char * const names[14] = {
    "Invalid",
    "Nulltype",
    "Normal",
    "Text",
    "Instance",
    "Armature",
    "Effect",
    "Mesh",
    "Movenode",
    "Constraint",
    "Mask",
    "Joint",
    "Bonepoint",
    nullptr
  };
  return names;
}

inline const char *EnumNameSsPartType(SsPartType e) {
  if (flatbuffers::IsOutRange(e, SsPartType_Invalid, SsPartType_Bonepoint)) return "";
  const size_t index = static_cast<size_t>(e) - static_cast<size_t>(SsPartType_Invalid);
  return EnumNamesSsPartType()[index];
}

enum PartFlag : uint32_t {
  PartFlag_Invisible = 1,
  PartFlag_FlipH = 2,
  PartFlag_FlipV = 4,
  PartFlag_CellIndex = 8,
  PartFlag_PositionX = 16,
  PartFlag_PositionY = 32,
  PartFlag_PositionZ = 64,
  PartFlag_PivotX = 128,
  PartFlag_PivotY = 256,
  PartFlag_RotationX = 512,
  PartFlag_RotationY = 1024,
  PartFlag_RotationnZ = 2048,
  PartFlag_ScaleX = 4096,
  PartFlag_ScaleY = 8192,
  PartFlag_LocalScaleX = 16384,
  PartFlag_LocalScaleY = 32768,
  PartFlag_Opacity = 65536,
  PartFlag_LocalOpacity = 131072,
  PartFlag_PartsColor = 262144,
  PartFlag_VertexTransform = 524288,
  PartFlag_SizeX = 1048576,
  PartFlag_SizeY = 2097152,
  PartFlag_UMove = 4194304,
  PartFlag_VMove = 8388608,
  PartFlag_UvRotation = 16777216,
  PartFlag_UScale = 33554432,
  PartFlag_VScale = 67108864,
  PartFlag_BoundingRadius = 134217728,
  PartFlag_Mask = 268435456,
  PartFlag_Priority = 536870912,
  PartFlag_InstanceKeyframe = 1073741824,
  PartFlag_EffectKeyframe = 2147483648,
  PartFlag_NONE = 0,
  PartFlag_ANY = 4294967295
};

inline const PartFlag (&EnumValuesPartFlag())[32] {
  static const PartFlag values[] = {
    PartFlag_Invisible,
    PartFlag_FlipH,
    PartFlag_FlipV,
    PartFlag_CellIndex,
    PartFlag_PositionX,
    PartFlag_PositionY,
    PartFlag_PositionZ,
    PartFlag_PivotX,
    PartFlag_PivotY,
    PartFlag_RotationX,
    PartFlag_RotationY,
    PartFlag_RotationnZ,
    PartFlag_ScaleX,
    PartFlag_ScaleY,
    PartFlag_LocalScaleX,
    PartFlag_LocalScaleY,
    PartFlag_Opacity,
    PartFlag_LocalOpacity,
    PartFlag_PartsColor,
    PartFlag_VertexTransform,
    PartFlag_SizeX,
    PartFlag_SizeY,
    PartFlag_UMove,
    PartFlag_VMove,
    PartFlag_UvRotation,
    PartFlag_UScale,
    PartFlag_VScale,
    PartFlag_BoundingRadius,
    PartFlag_Mask,
    PartFlag_Priority,
    PartFlag_InstanceKeyframe,
    PartFlag_EffectKeyframe
  };
  return values;
}

inline const char *EnumNamePartFlag(PartFlag e) {
  switch (e) {
    case PartFlag_Invisible: return "Invisible";
    case PartFlag_FlipH: return "FlipH";
    case PartFlag_FlipV: return "FlipV";
    case PartFlag_CellIndex: return "CellIndex";
    case PartFlag_PositionX: return "PositionX";
    case PartFlag_PositionY: return "PositionY";
    case PartFlag_PositionZ: return "PositionZ";
    case PartFlag_PivotX: return "PivotX";
    case PartFlag_PivotY: return "PivotY";
    case PartFlag_RotationX: return "RotationX";
    case PartFlag_RotationY: return "RotationY";
    case PartFlag_RotationnZ: return "RotationnZ";
    case PartFlag_ScaleX: return "ScaleX";
    case PartFlag_ScaleY: return "ScaleY";
    case PartFlag_LocalScaleX: return "LocalScaleX";
    case PartFlag_LocalScaleY: return "LocalScaleY";
    case PartFlag_Opacity: return "Opacity";
    case PartFlag_LocalOpacity: return "LocalOpacity";
    case PartFlag_PartsColor: return "PartsColor";
    case PartFlag_VertexTransform: return "VertexTransform";
    case PartFlag_SizeX: return "SizeX";
    case PartFlag_SizeY: return "SizeY";
    case PartFlag_UMove: return "UMove";
    case PartFlag_VMove: return "VMove";
    case PartFlag_UvRotation: return "UvRotation";
    case PartFlag_UScale: return "UScale";
    case PartFlag_VScale: return "VScale";
    case PartFlag_BoundingRadius: return "BoundingRadius";
    case PartFlag_Mask: return "Mask";
    case PartFlag_Priority: return "Priority";
    case PartFlag_InstanceKeyframe: return "InstanceKeyframe";
    case PartFlag_EffectKeyframe: return "EffectKeyframe";
    default: return "";
  }
}

enum PartFlag2 : uint32_t {
  PartFlag2_MeshData = 1,
  PartFlag2_NONE = 0,
  PartFlag2_ANY = 1
};

inline const PartFlag2 (&EnumValuesPartFlag2())[1] {
  static const PartFlag2 values[] = {
    PartFlag2_MeshData
  };
  return values;
}

inline const char * const *EnumNamesPartFlag2() {
  static const char * const names[2] = {
    "MeshData",
    nullptr
  };
  return names;
}

inline const char *EnumNamePartFlag2(PartFlag2 e) {
  if (flatbuffers::IsOutRange(e, PartFlag2_MeshData, PartFlag2_MeshData)) return "";
  const size_t index = static_cast<size_t>(e) - static_cast<size_t>(PartFlag2_MeshData);
  return EnumNamesPartFlag2()[index];
}

enum VertexFlag : uint8_t {
  VertexFlag_LT = 1,
  VertexFlag_RT = 2,
  VertexFlag_LB = 4,
  VertexFlag_RB = 8,
  VertexFlag_ONE = 16,
  VertexFlag_NONE = 0,
  VertexFlag_ANY = 31
};

inline const VertexFlag (&EnumValuesVertexFlag())[5] {
  static const VertexFlag values[] = {
    VertexFlag_LT,
    VertexFlag_RT,
    VertexFlag_LB,
    VertexFlag_RB,
    VertexFlag_ONE
  };
  return values;
}

inline const char * const *EnumNamesVertexFlag() {
  static const char * const names[17] = {
    "LT",
    "RT",
    "",
    "LB",
    "",
    "",
    "",
    "RB",
    "",
    "",
    "",
    "",
    "",
    "",
    "",
    "ONE",
    nullptr
  };
  return names;
}

inline const char *EnumNameVertexFlag(VertexFlag e) {
  if (flatbuffers::IsOutRange(e, VertexFlag_LT, VertexFlag_ONE)) return "";
  const size_t index = static_cast<size_t>(e) - static_cast<size_t>(VertexFlag_LT);
  return EnumNamesVertexFlag()[index];
}

enum InstanceLoopFlag : uint8_t {
  InstanceLoopFlag_Infinity = 1,
  InstanceLoopFlag_Reverse = 2,
  InstanceLoopFlag_PingPong = 4,
  InstanceLoopFlag_Independent = 8,
  InstanceLoopFlag_NONE = 0,
  InstanceLoopFlag_ANY = 15
};

inline const InstanceLoopFlag (&EnumValuesInstanceLoopFlag())[4] {
  static const InstanceLoopFlag values[] = {
    InstanceLoopFlag_Infinity,
    InstanceLoopFlag_Reverse,
    InstanceLoopFlag_PingPong,
    InstanceLoopFlag_Independent
  };
  return values;
}

inline const char * const *EnumNamesInstanceLoopFlag() {
  static const char * const names[9] = {
    "Infinity",
    "Reverse",
    "",
    "PingPong",
    "",
    "",
    "",
    "Independent",
    nullptr
  };
  return names;
}

inline const char *EnumNameInstanceLoopFlag(InstanceLoopFlag e) {
  if (flatbuffers::IsOutRange(e, InstanceLoopFlag_Infinity, InstanceLoopFlag_Independent)) return "";
  const size_t index = static_cast<size_t>(e) - static_cast<size_t>(InstanceLoopFlag_Infinity);
  return EnumNamesInstanceLoopFlag()[index];
}

enum UserDataFlag : uint8_t {
  UserDataFlag_Integer = 1,
  UserDataFlag_Rect = 2,
  UserDataFlag_Point = 4,
  UserDataFlag_String = 8,
  UserDataFlag_NONE = 0,
  UserDataFlag_ANY = 15
};

inline const UserDataFlag (&EnumValuesUserDataFlag())[4] {
  static const UserDataFlag values[] = {
    UserDataFlag_Integer,
    UserDataFlag_Rect,
    UserDataFlag_Point,
    UserDataFlag_String
  };
  return values;
}

inline const char * const *EnumNamesUserDataFlag() {
  static const char * const names[9] = {
    "Integer",
    "Rect",
    "",
    "Point",
    "",
    "",
    "",
    "String",
    nullptr
  };
  return names;
}

inline const char *EnumNameUserDataFlag(UserDataFlag e) {
  if (flatbuffers::IsOutRange(e, UserDataFlag_Integer, UserDataFlag_String)) return "";
  const size_t index = static_cast<size_t>(e) - static_cast<size_t>(UserDataFlag_Integer);
  return EnumNamesUserDataFlag()[index];
}

enum SsEffectFunctionType : uint8_t {
  SsEffectFunctionType_Base = 0,
  SsEffectFunctionType_Basic = 1,
  SsEffectFunctionType_RndSeedChange = 2,
  SsEffectFunctionType_Delay = 3,
  SsEffectFunctionType_Gravity = 4,
  SsEffectFunctionType_Position = 5,
  SsEffectFunctionType_Rotation = 6,
  SsEffectFunctionType_TransRotation = 7,
  SsEffectFunctionType_TransSpeed = 8,
  SsEffectFunctionType_TangentialAcceleration = 9,
  SsEffectFunctionType_InitColor = 10,
  SsEffectFunctionType_TransColor = 11,
  SsEffectFunctionType_AlphaFade = 12,
  SsEffectFunctionType_Size = 13,
  SsEffectFunctionType_TransSize = 14,
  SsEffectFunctionType_PointGravity = 15,
  SsEffectFunctionType_TurnToDirectionEnabled = 16,
  SsEffectFunctionType_InfiniteEmitEnabled = 17,
  SsEffectFunctionType_MIN = SsEffectFunctionType_Base,
  SsEffectFunctionType_MAX = SsEffectFunctionType_InfiniteEmitEnabled
};

inline const SsEffectFunctionType (&EnumValuesSsEffectFunctionType())[18] {
  static const SsEffectFunctionType values[] = {
    SsEffectFunctionType_Base,
    SsEffectFunctionType_Basic,
    SsEffectFunctionType_RndSeedChange,
    SsEffectFunctionType_Delay,
    SsEffectFunctionType_Gravity,
    SsEffectFunctionType_Position,
    SsEffectFunctionType_Rotation,
    SsEffectFunctionType_TransRotation,
    SsEffectFunctionType_TransSpeed,
    SsEffectFunctionType_TangentialAcceleration,
    SsEffectFunctionType_InitColor,
    SsEffectFunctionType_TransColor,
    SsEffectFunctionType_AlphaFade,
    SsEffectFunctionType_Size,
    SsEffectFunctionType_TransSize,
    SsEffectFunctionType_PointGravity,
    SsEffectFunctionType_TurnToDirectionEnabled,
    SsEffectFunctionType_InfiniteEmitEnabled
  };
  return values;
}

inline const char * const *EnumNamesSsEffectFunctionType() {
  static const char * const names[19] = {
    "Base",
    "Basic",
    "RndSeedChange",
    "Delay",
    "Gravity",
    "Position",
    "Rotation",
    "TransRotation",
    "TransSpeed",
    "TangentialAcceleration",
    "InitColor",
    "TransColor",
    "AlphaFade",
    "Size",
    "TransSize",
    "PointGravity",
    "TurnToDirectionEnabled",
    "InfiniteEmitEnabled",
    nullptr
  };
  return names;
}

inline const char *EnumNameSsEffectFunctionType(SsEffectFunctionType e) {
  if (flatbuffers::IsOutRange(e, SsEffectFunctionType_Base, SsEffectFunctionType_InfiniteEmitEnabled)) return "";
  const size_t index = static_cast<size_t>(e);
  return EnumNamesSsEffectFunctionType()[index];
}

enum EffectBehaviorFlags : uint32_t {
  EffectBehaviorFlags_Base = 1,
  EffectBehaviorFlags_Basic = 2,
  EffectBehaviorFlags_RndSeedChange = 4,
  EffectBehaviorFlags_Delay = 8,
  EffectBehaviorFlags_Gravity = 16,
  EffectBehaviorFlags_Position = 32,
  EffectBehaviorFlags_Rotation = 64,
  EffectBehaviorFlags_TransRotation = 128,
  EffectBehaviorFlags_TransSpeed = 256,
  EffectBehaviorFlags_TangentialAcceleration = 512,
  EffectBehaviorFlags_InitColor = 1024,
  EffectBehaviorFlags_TransColor = 2048,
  EffectBehaviorFlags_AlphaFade = 4096,
  EffectBehaviorFlags_Size = 8192,
  EffectBehaviorFlags_TransSize = 16384,
  EffectBehaviorFlags_PointGravity = 32768,
  EffectBehaviorFlags_TurnToDirectionEnabled = 65536,
  EffectBehaviorFlags_InfiniteEmitEnabled = 131072,
  EffectBehaviorFlags_NONE = 0,
  EffectBehaviorFlags_ANY = 262143
};

inline const EffectBehaviorFlags (&EnumValuesEffectBehaviorFlags())[18] {
  static const EffectBehaviorFlags values[] = {
    EffectBehaviorFlags_Base,
    EffectBehaviorFlags_Basic,
    EffectBehaviorFlags_RndSeedChange,
    EffectBehaviorFlags_Delay,
    EffectBehaviorFlags_Gravity,
    EffectBehaviorFlags_Position,
    EffectBehaviorFlags_Rotation,
    EffectBehaviorFlags_TransRotation,
    EffectBehaviorFlags_TransSpeed,
    EffectBehaviorFlags_TangentialAcceleration,
    EffectBehaviorFlags_InitColor,
    EffectBehaviorFlags_TransColor,
    EffectBehaviorFlags_AlphaFade,
    EffectBehaviorFlags_Size,
    EffectBehaviorFlags_TransSize,
    EffectBehaviorFlags_PointGravity,
    EffectBehaviorFlags_TurnToDirectionEnabled,
    EffectBehaviorFlags_InfiniteEmitEnabled
  };
  return values;
}

inline const char *EnumNameEffectBehaviorFlags(EffectBehaviorFlags e) {
  switch (e) {
    case EffectBehaviorFlags_Base: return "Base";
    case EffectBehaviorFlags_Basic: return "Basic";
    case EffectBehaviorFlags_RndSeedChange: return "RndSeedChange";
    case EffectBehaviorFlags_Delay: return "Delay";
    case EffectBehaviorFlags_Gravity: return "Gravity";
    case EffectBehaviorFlags_Position: return "Position";
    case EffectBehaviorFlags_Rotation: return "Rotation";
    case EffectBehaviorFlags_TransRotation: return "TransRotation";
    case EffectBehaviorFlags_TransSpeed: return "TransSpeed";
    case EffectBehaviorFlags_TangentialAcceleration: return "TangentialAcceleration";
    case EffectBehaviorFlags_InitColor: return "InitColor";
    case EffectBehaviorFlags_TransColor: return "TransColor";
    case EffectBehaviorFlags_AlphaFade: return "AlphaFade";
    case EffectBehaviorFlags_Size: return "Size";
    case EffectBehaviorFlags_TransSize: return "TransSize";
    case EffectBehaviorFlags_PointGravity: return "PointGravity";
    case EffectBehaviorFlags_TurnToDirectionEnabled: return "TurnToDirectionEnabled";
    case EffectBehaviorFlags_InfiniteEmitEnabled: return "InfiniteEmitEnabled";
    default: return "";
  }
}

enum EffectNodeType : int8_t {
  EffectNodeType_Invalid = -1,
  EffectNodeType_Root = 0,
  EffectNodeType_Emitter = 1,
  EffectNodeType_Particle = 2,
  EffectNodeType_MIN = EffectNodeType_Invalid,
  EffectNodeType_MAX = EffectNodeType_Particle
};

inline const EffectNodeType (&EnumValuesEffectNodeType())[4] {
  static const EffectNodeType values[] = {
    EffectNodeType_Invalid,
    EffectNodeType_Root,
    EffectNodeType_Emitter,
    EffectNodeType_Particle
  };
  return values;
}

inline const char * const *EnumNamesEffectNodeType() {
  static const char * const names[5] = {
    "Invalid",
    "Root",
    "Emitter",
    "Particle",
    nullptr
  };
  return names;
}

inline const char *EnumNameEffectNodeType(EffectNodeType e) {
  if (flatbuffers::IsOutRange(e, EffectNodeType_Invalid, EffectNodeType_Particle)) return "";
  const size_t index = static_cast<size_t>(e) - static_cast<size_t>(EffectNodeType_Invalid);
  return EnumNamesEffectNodeType()[index];
}

enum EffectRenderBlendType : int8_t {
  EffectRenderBlendType_Invalid = -1,
  EffectRenderBlendType_Mix = 0,
  EffectRenderBlendType_Add = 1,
  EffectRenderBlendType_MIN = EffectRenderBlendType_Invalid,
  EffectRenderBlendType_MAX = EffectRenderBlendType_Add
};

inline const EffectRenderBlendType (&EnumValuesEffectRenderBlendType())[3] {
  static const EffectRenderBlendType values[] = {
    EffectRenderBlendType_Invalid,
    EffectRenderBlendType_Mix,
    EffectRenderBlendType_Add
  };
  return values;
}

inline const char * const *EnumNamesEffectRenderBlendType() {
  static const char * const names[4] = {
    "Invalid",
    "Mix",
    "Add",
    nullptr
  };
  return names;
}

inline const char *EnumNameEffectRenderBlendType(EffectRenderBlendType e) {
  if (flatbuffers::IsOutRange(e, EffectRenderBlendType_Invalid, EffectRenderBlendType_Add)) return "";
  const size_t index = static_cast<size_t>(e) - static_cast<size_t>(EffectRenderBlendType_Invalid);
  return EnumNamesEffectRenderBlendType()[index];
}

FLATBUFFERS_MANUALLY_ALIGNED_STRUCT(4) EffectParticleElementBasic FLATBUFFERS_FINAL_CLASS {
 private:
  int32_t ss_effect_function_type_;
  int32_t priority_;
  int32_t maximum_particle_;
  int32_t attime_create_;
  int32_t interval_;
  int32_t lifetime_;
  float speed_min_value_;
  float speed_max_value_;
  int32_t lifespan_min_value_;
  int32_t lifespan_max_value_;
  float angle_;
  float angle_variance_;

 public:
  EffectParticleElementBasic()
      : ss_effect_function_type_(0),
        priority_(0),
        maximum_particle_(0),
        attime_create_(0),
        interval_(0),
        lifetime_(0),
        speed_min_value_(0),
        speed_max_value_(0),
        lifespan_min_value_(0),
        lifespan_max_value_(0),
        angle_(0),
        angle_variance_(0) {
  }
  EffectParticleElementBasic(int32_t _ss_effect_function_type, int32_t _priority, int32_t _maximum_particle, int32_t _attime_create, int32_t _interval, int32_t _lifetime, float _speed_min_value, float _speed_max_value, int32_t _lifespan_min_value, int32_t _lifespan_max_value, float _angle, float _angle_variance)
      : ss_effect_function_type_(flatbuffers::EndianScalar(_ss_effect_function_type)),
        priority_(flatbuffers::EndianScalar(_priority)),
        maximum_particle_(flatbuffers::EndianScalar(_maximum_particle)),
        attime_create_(flatbuffers::EndianScalar(_attime_create)),
        interval_(flatbuffers::EndianScalar(_interval)),
        lifetime_(flatbuffers::EndianScalar(_lifetime)),
        speed_min_value_(flatbuffers::EndianScalar(_speed_min_value)),
        speed_max_value_(flatbuffers::EndianScalar(_speed_max_value)),
        lifespan_min_value_(flatbuffers::EndianScalar(_lifespan_min_value)),
        lifespan_max_value_(flatbuffers::EndianScalar(_lifespan_max_value)),
        angle_(flatbuffers::EndianScalar(_angle)),
        angle_variance_(flatbuffers::EndianScalar(_angle_variance)) {
  }
  int32_t ss_effect_function_type() const {
    return flatbuffers::EndianScalar(ss_effect_function_type_);
  }
  int32_t priority() const {
    return flatbuffers::EndianScalar(priority_);
  }
  int32_t maximum_particle() const {
    return flatbuffers::EndianScalar(maximum_particle_);
  }
  int32_t attime_create() const {
    return flatbuffers::EndianScalar(attime_create_);
  }
  int32_t interval() const {
    return flatbuffers::EndianScalar(interval_);
  }
  int32_t lifetime() const {
    return flatbuffers::EndianScalar(lifetime_);
  }
  float speed_min_value() const {
    return flatbuffers::EndianScalar(speed_min_value_);
  }
  float speed_max_value() const {
    return flatbuffers::EndianScalar(speed_max_value_);
  }
  int32_t lifespan_min_value() const {
    return flatbuffers::EndianScalar(lifespan_min_value_);
  }
  int32_t lifespan_max_value() const {
    return flatbuffers::EndianScalar(lifespan_max_value_);
  }
  float angle() const {
    return flatbuffers::EndianScalar(angle_);
  }
  float angle_variance() const {
    return flatbuffers::EndianScalar(angle_variance_);
  }
};
FLATBUFFERS_STRUCT_END(EffectParticleElementBasic, 48);

inline bool operator==(const EffectParticleElementBasic &lhs, const EffectParticleElementBasic &rhs) {
  return
      (lhs.ss_effect_function_type() == rhs.ss_effect_function_type()) &&
      (lhs.priority() == rhs.priority()) &&
      (lhs.maximum_particle() == rhs.maximum_particle()) &&
      (lhs.attime_create() == rhs.attime_create()) &&
      (lhs.interval() == rhs.interval()) &&
      (lhs.lifetime() == rhs.lifetime()) &&
      (lhs.speed_min_value() == rhs.speed_min_value()) &&
      (lhs.speed_max_value() == rhs.speed_max_value()) &&
      (lhs.lifespan_min_value() == rhs.lifespan_min_value()) &&
      (lhs.lifespan_max_value() == rhs.lifespan_max_value()) &&
      (lhs.angle() == rhs.angle()) &&
      (lhs.angle_variance() == rhs.angle_variance());
}

inline bool operator!=(const EffectParticleElementBasic &lhs, const EffectParticleElementBasic &rhs) {
    return !(lhs == rhs);
}


struct EffectNodeT : public flatbuffers::NativeTable {
  typedef EffectNode TableType;
  int16_t array_index = 0;
  int16_t parent_index = 0;
  ss::ssfb::EffectNodeType type = ss::ssfb::EffectNodeType_Root;
  int16_t cell_index = 0;
  ss::ssfb::EffectRenderBlendType blend_type = ss::ssfb::EffectRenderBlendType_Mix;
  std::unique_ptr<ss::ssfb::EffectParticleElementBasic> basic_behavior{};
  ss::ssfb::EffectBehaviorFlags behavior_flags = static_cast<ss::ssfb::EffectBehaviorFlags>(0);
  int32_t seed = 0;
  int32_t delay_time = 0;
  float gravity_x = 0.0f;
  float gravity_y = 0.0f;
  float offset_x_min_value = 0.0f;
  float offset_x_max_value = 0.0f;
  float offset_y_min_value = 0.0f;
  float offset_y_max_value = 0.0f;
  float rotation_min_value = 0.0f;
  float rotation_max_value = 0.0f;
  float rotation_add_min_value = 0.0f;
  float rotation_add_max_value = 0.0f;
  float rotation_factor = 0.0f;
  float end_life_time_per = 0.0f;
  float speed_min_value = 0.0f;
  float speed_max_value = 0.0f;
  float acceleration_min_value = 0.0f;
  float acceleration_max_value = 0.0f;
  uint32_t init_color_min_value = 0;
  uint32_t init_color_max_value = 0;
  uint32_t trans_color_min_value = 0;
  uint32_t trans_color_max_value = 0;
  float disprange_min_value = 0.0f;
  float disprange_max_value = 0.0f;
  float size_x_min_value = 0.0f;
  float size_x_max_value = 0.0f;
  float size_y_min_value = 0.0f;
  float size_y_max_value = 0.0f;
  float scale_factor_min_value = 0.0f;
  float scale_factor_max_value = 0.0f;
  float trans_size_x_min_value = 0.0f;
  float trans_size_x_max_value = 0.0f;
  float trans_size_y_min_value = 0.0f;
  float trans_size_y_max_value = 0.0f;
  float trans_scale_factor_min_value = 0.0f;
  float trans_scale_factor_max_value = 0.0f;
  float point_gravity_position_x = 0.0f;
  float point_gravity_position_y = 0.0f;
  float point_gravity_power = 0.0f;
  float rotation = 0.0f;
  int32_t infinitie_emit_flag = 0;
};

struct EffectNode FLATBUFFERS_FINAL_CLASS : private flatbuffers::Table {
  typedef EffectNodeT NativeTableType;
  typedef EffectNodeBuilder Builder;
  enum FlatBuffersVTableOffset FLATBUFFERS_VTABLE_UNDERLYING_TYPE {
    VT_ARRAY_INDEX = 4,
    VT_PARENT_INDEX = 6,
    VT_TYPE = 8,
    VT_CELL_INDEX = 10,
    VT_BLEND_TYPE = 12,
    VT_BASIC_BEHAVIOR = 14,
    VT_BEHAVIOR_FLAGS = 16,
    VT_SEED = 18,
    VT_DELAY_TIME = 20,
    VT_GRAVITY_X = 22,
    VT_GRAVITY_Y = 24,
    VT_OFFSET_X_MIN_VALUE = 26,
    VT_OFFSET_X_MAX_VALUE = 28,
    VT_OFFSET_Y_MIN_VALUE = 30,
    VT_OFFSET_Y_MAX_VALUE = 32,
    VT_ROTATION_MIN_VALUE = 34,
    VT_ROTATION_MAX_VALUE = 36,
    VT_ROTATION_ADD_MIN_VALUE = 38,
    VT_ROTATION_ADD_MAX_VALUE = 40,
    VT_ROTATION_FACTOR = 42,
    VT_END_LIFE_TIME_PER = 44,
    VT_SPEED_MIN_VALUE = 46,
    VT_SPEED_MAX_VALUE = 48,
    VT_ACCELERATION_MIN_VALUE = 50,
    VT_ACCELERATION_MAX_VALUE = 52,
    VT_INIT_COLOR_MIN_VALUE = 54,
    VT_INIT_COLOR_MAX_VALUE = 56,
    VT_TRANS_COLOR_MIN_VALUE = 58,
    VT_TRANS_COLOR_MAX_VALUE = 60,
    VT_DISPRANGE_MIN_VALUE = 62,
    VT_DISPRANGE_MAX_VALUE = 64,
    VT_SIZE_X_MIN_VALUE = 66,
    VT_SIZE_X_MAX_VALUE = 68,
    VT_SIZE_Y_MIN_VALUE = 70,
    VT_SIZE_Y_MAX_VALUE = 72,
    VT_SCALE_FACTOR_MIN_VALUE = 74,
    VT_SCALE_FACTOR_MAX_VALUE = 76,
    VT_TRANS_SIZE_X_MIN_VALUE = 78,
    VT_TRANS_SIZE_X_MAX_VALUE = 80,
    VT_TRANS_SIZE_Y_MIN_VALUE = 82,
    VT_TRANS_SIZE_Y_MAX_VALUE = 84,
    VT_TRANS_SCALE_FACTOR_MIN_VALUE = 86,
    VT_TRANS_SCALE_FACTOR_MAX_VALUE = 88,
    VT_POINT_GRAVITY_POSITION_X = 90,
    VT_POINT_GRAVITY_POSITION_Y = 92,
    VT_POINT_GRAVITY_POWER = 94,
    VT_ROTATION = 96,
    VT_INFINITIE_EMIT_FLAG = 98
  };
  int16_t array_index() const {
    return GetField<int16_t>(VT_ARRAY_INDEX, 0);
  }
  int16_t parent_index() const {
    return GetField<int16_t>(VT_PARENT_INDEX, 0);
  }
  ss::ssfb::EffectNodeType type() const {
    return static_cast<ss::ssfb::EffectNodeType>(GetField<int8_t>(VT_TYPE, 0));
  }
  int16_t cell_index() const {
    return GetField<int16_t>(VT_CELL_INDEX, 0);
  }
  ss::ssfb::EffectRenderBlendType blend_type() const {
    return static_cast<ss::ssfb::EffectRenderBlendType>(GetField<int8_t>(VT_BLEND_TYPE, 0));
  }
  const ss::ssfb::EffectParticleElementBasic *basic_behavior() const {
    return GetStruct<const ss::ssfb::EffectParticleElementBasic *>(VT_BASIC_BEHAVIOR);
  }
  ss::ssfb::EffectBehaviorFlags behavior_flags() const {
    return static_cast<ss::ssfb::EffectBehaviorFlags>(GetField<uint32_t>(VT_BEHAVIOR_FLAGS, 0));
  }
  int32_t seed() const {
    return GetField<int32_t>(VT_SEED, 0);
  }
  int32_t delay_time() const {
    return GetField<int32_t>(VT_DELAY_TIME, 0);
  }
  float gravity_x() const {
    return GetField<float>(VT_GRAVITY_X, 0.0f);
  }
  float gravity_y() const {
    return GetField<float>(VT_GRAVITY_Y, 0.0f);
  }
  float offset_x_min_value() const {
    return GetField<float>(VT_OFFSET_X_MIN_VALUE, 0.0f);
  }
  float offset_x_max_value() const {
    return GetField<float>(VT_OFFSET_X_MAX_VALUE, 0.0f);
  }
  float offset_y_min_value() const {
    return GetField<float>(VT_OFFSET_Y_MIN_VALUE, 0.0f);
  }
  float offset_y_max_value() const {
    return GetField<float>(VT_OFFSET_Y_MAX_VALUE, 0.0f);
  }
  float rotation_min_value() const {
    return GetField<float>(VT_ROTATION_MIN_VALUE, 0.0f);
  }
  float rotation_max_value() const {
    return GetField<float>(VT_ROTATION_MAX_VALUE, 0.0f);
  }
  float rotation_add_min_value() const {
    return GetField<float>(VT_ROTATION_ADD_MIN_VALUE, 0.0f);
  }
  float rotation_add_max_value() const {
    return GetField<float>(VT_ROTATION_ADD_MAX_VALUE, 0.0f);
  }
  float rotation_factor() const {
    return GetField<float>(VT_ROTATION_FACTOR, 0.0f);
  }
  float end_life_time_per() const {
    return GetField<float>(VT_END_LIFE_TIME_PER, 0.0f);
  }
  float speed_min_value() const {
    return GetField<float>(VT_SPEED_MIN_VALUE, 0.0f);
  }
  float speed_max_value() const {
    return GetField<float>(VT_SPEED_MAX_VALUE, 0.0f);
  }
  float acceleration_min_value() const {
    return GetField<float>(VT_ACCELERATION_MIN_VALUE, 0.0f);
  }
  float acceleration_max_value() const {
    return GetField<float>(VT_ACCELERATION_MAX_VALUE, 0.0f);
  }
  uint32_t init_color_min_value() const {
    return GetField<uint32_t>(VT_INIT_COLOR_MIN_VALUE, 0);
  }
  uint32_t init_color_max_value() const {
    return GetField<uint32_t>(VT_INIT_COLOR_MAX_VALUE, 0);
  }
  uint32_t trans_color_min_value() const {
    return GetField<uint32_t>(VT_TRANS_COLOR_MIN_VALUE, 0);
  }
  uint32_t trans_color_max_value() const {
    return GetField<uint32_t>(VT_TRANS_COLOR_MAX_VALUE, 0);
  }
  float disprange_min_value() const {
    return GetField<float>(VT_DISPRANGE_MIN_VALUE, 0.0f);
  }
  float disprange_max_value() const {
    return GetField<float>(VT_DISPRANGE_MAX_VALUE, 0.0f);
  }
  float size_x_min_value() const {
    return GetField<float>(VT_SIZE_X_MIN_VALUE, 0.0f);
  }
  float size_x_max_value() const {
    return GetField<float>(VT_SIZE_X_MAX_VALUE, 0.0f);
  }
  float size_y_min_value() const {
    return GetField<float>(VT_SIZE_Y_MIN_VALUE, 0.0f);
  }
  float size_y_max_value() const {
    return GetField<float>(VT_SIZE_Y_MAX_VALUE, 0.0f);
  }
  float scale_factor_min_value() const {
    return GetField<float>(VT_SCALE_FACTOR_MIN_VALUE, 0.0f);
  }
  float scale_factor_max_value() const {
    return GetField<float>(VT_SCALE_FACTOR_MAX_VALUE, 0.0f);
  }
  float trans_size_x_min_value() const {
    return GetField<float>(VT_TRANS_SIZE_X_MIN_VALUE, 0.0f);
  }
  float trans_size_x_max_value() const {
    return GetField<float>(VT_TRANS_SIZE_X_MAX_VALUE, 0.0f);
  }
  float trans_size_y_min_value() const {
    return GetField<float>(VT_TRANS_SIZE_Y_MIN_VALUE, 0.0f);
  }
  float trans_size_y_max_value() const {
    return GetField<float>(VT_TRANS_SIZE_Y_MAX_VALUE, 0.0f);
  }
  float trans_scale_factor_min_value() const {
    return GetField<float>(VT_TRANS_SCALE_FACTOR_MIN_VALUE, 0.0f);
  }
  float trans_scale_factor_max_value() const {
    return GetField<float>(VT_TRANS_SCALE_FACTOR_MAX_VALUE, 0.0f);
  }
  float point_gravity_position_x() const {
    return GetField<float>(VT_POINT_GRAVITY_POSITION_X, 0.0f);
  }
  float point_gravity_position_y() const {
    return GetField<float>(VT_POINT_GRAVITY_POSITION_Y, 0.0f);
  }
  float point_gravity_power() const {
    return GetField<float>(VT_POINT_GRAVITY_POWER, 0.0f);
  }
  float rotation() const {
    return GetField<float>(VT_ROTATION, 0.0f);
  }
  int32_t infinitie_emit_flag() const {
    return GetField<int32_t>(VT_INFINITIE_EMIT_FLAG, 0);
  }
  bool Verify(flatbuffers::Verifier &verifier) const {
    return VerifyTableStart(verifier) &&
           VerifyField<int16_t>(verifier, VT_ARRAY_INDEX) &&
           VerifyField<int16_t>(verifier, VT_PARENT_INDEX) &&
           VerifyField<int8_t>(verifier, VT_TYPE) &&
           VerifyField<int16_t>(verifier, VT_CELL_INDEX) &&
           VerifyField<int8_t>(verifier, VT_BLEND_TYPE) &&
           VerifyField<ss::ssfb::EffectParticleElementBasic>(verifier, VT_BASIC_BEHAVIOR) &&
           VerifyField<uint32_t>(verifier, VT_BEHAVIOR_FLAGS) &&
           VerifyField<int32_t>(verifier, VT_SEED) &&
           VerifyField<int32_t>(verifier, VT_DELAY_TIME) &&
           VerifyField<float>(verifier, VT_GRAVITY_X) &&
           VerifyField<float>(verifier, VT_GRAVITY_Y) &&
           VerifyField<float>(verifier, VT_OFFSET_X_MIN_VALUE) &&
           VerifyField<float>(verifier, VT_OFFSET_X_MAX_VALUE) &&
           VerifyField<float>(verifier, VT_OFFSET_Y_MIN_VALUE) &&
           VerifyField<float>(verifier, VT_OFFSET_Y_MAX_VALUE) &&
           VerifyField<float>(verifier, VT_ROTATION_MIN_VALUE) &&
           VerifyField<float>(verifier, VT_ROTATION_MAX_VALUE) &&
           VerifyField<float>(verifier, VT_ROTATION_ADD_MIN_VALUE) &&
           VerifyField<float>(verifier, VT_ROTATION_ADD_MAX_VALUE) &&
           VerifyField<float>(verifier, VT_ROTATION_FACTOR) &&
           VerifyField<float>(verifier, VT_END_LIFE_TIME_PER) &&
           VerifyField<float>(verifier, VT_SPEED_MIN_VALUE) &&
           VerifyField<float>(verifier, VT_SPEED_MAX_VALUE) &&
           VerifyField<float>(verifier, VT_ACCELERATION_MIN_VALUE) &&
           VerifyField<float>(verifier, VT_ACCELERATION_MAX_VALUE) &&
           VerifyField<uint32_t>(verifier, VT_INIT_COLOR_MIN_VALUE) &&
           VerifyField<uint32_t>(verifier, VT_INIT_COLOR_MAX_VALUE) &&
           VerifyField<uint32_t>(verifier, VT_TRANS_COLOR_MIN_VALUE) &&
           VerifyField<uint32_t>(verifier, VT_TRANS_COLOR_MAX_VALUE) &&
           VerifyField<float>(verifier, VT_DISPRANGE_MIN_VALUE) &&
           VerifyField<float>(verifier, VT_DISPRANGE_MAX_VALUE) &&
           VerifyField<float>(verifier, VT_SIZE_X_MIN_VALUE) &&
           VerifyField<float>(verifier, VT_SIZE_X_MAX_VALUE) &&
           VerifyField<float>(verifier, VT_SIZE_Y_MIN_VALUE) &&
           VerifyField<float>(verifier, VT_SIZE_Y_MAX_VALUE) &&
           VerifyField<float>(verifier, VT_SCALE_FACTOR_MIN_VALUE) &&
           VerifyField<float>(verifier, VT_SCALE_FACTOR_MAX_VALUE) &&
           VerifyField<float>(verifier, VT_TRANS_SIZE_X_MIN_VALUE) &&
           VerifyField<float>(verifier, VT_TRANS_SIZE_X_MAX_VALUE) &&
           VerifyField<float>(verifier, VT_TRANS_SIZE_Y_MIN_VALUE) &&
           VerifyField<float>(verifier, VT_TRANS_SIZE_Y_MAX_VALUE) &&
           VerifyField<float>(verifier, VT_TRANS_SCALE_FACTOR_MIN_VALUE) &&
           VerifyField<float>(verifier, VT_TRANS_SCALE_FACTOR_MAX_VALUE) &&
           VerifyField<float>(verifier, VT_POINT_GRAVITY_POSITION_X) &&
           VerifyField<float>(verifier, VT_POINT_GRAVITY_POSITION_Y) &&
           VerifyField<float>(verifier, VT_POINT_GRAVITY_POWER) &&
           VerifyField<float>(verifier, VT_ROTATION) &&
           VerifyField<int32_t>(verifier, VT_INFINITIE_EMIT_FLAG) &&
           verifier.EndTable();
  }
  EffectNodeT *UnPack(const flatbuffers::resolver_function_t *_resolver = nullptr) const;
  void UnPackTo(EffectNodeT *_o, const flatbuffers::resolver_function_t *_resolver = nullptr) const;
  static flatbuffers::Offset<EffectNode> Pack(flatbuffers::FlatBufferBuilder &_fbb, const EffectNodeT* _o, const flatbuffers::rehasher_function_t *_rehasher = nullptr);
};

struct EffectNodeBuilder {
  typedef EffectNode Table;
  flatbuffers::FlatBufferBuilder &fbb_;
  flatbuffers::uoffset_t start_;
  void add_array_index(int16_t array_index) {
    fbb_.AddElement<int16_t>(EffectNode::VT_ARRAY_INDEX, array_index, 0);
  }
  void add_parent_index(int16_t parent_index) {
    fbb_.AddElement<int16_t>(EffectNode::VT_PARENT_INDEX, parent_index, 0);
  }
  void add_type(ss::ssfb::EffectNodeType type) {
    fbb_.AddElement<int8_t>(EffectNode::VT_TYPE, static_cast<int8_t>(type), 0);
  }
  void add_cell_index(int16_t cell_index) {
    fbb_.AddElement<int16_t>(EffectNode::VT_CELL_INDEX, cell_index, 0);
  }
  void add_blend_type(ss::ssfb::EffectRenderBlendType blend_type) {
    fbb_.AddElement<int8_t>(EffectNode::VT_BLEND_TYPE, static_cast<int8_t>(blend_type), 0);
  }
  void add_basic_behavior(const ss::ssfb::EffectParticleElementBasic *basic_behavior) {
    fbb_.AddStruct(EffectNode::VT_BASIC_BEHAVIOR, basic_behavior);
  }
  void add_behavior_flags(ss::ssfb::EffectBehaviorFlags behavior_flags) {
    fbb_.AddElement<uint32_t>(EffectNode::VT_BEHAVIOR_FLAGS, static_cast<uint32_t>(behavior_flags), 0);
  }
  void add_seed(int32_t seed) {
    fbb_.AddElement<int32_t>(EffectNode::VT_SEED, seed, 0);
  }
  void add_delay_time(int32_t delay_time) {
    fbb_.AddElement<int32_t>(EffectNode::VT_DELAY_TIME, delay_time, 0);
  }
  void add_gravity_x(float gravity_x) {
    fbb_.AddElement<float>(EffectNode::VT_GRAVITY_X, gravity_x, 0.0f);
  }
  void add_gravity_y(float gravity_y) {
    fbb_.AddElement<float>(EffectNode::VT_GRAVITY_Y, gravity_y, 0.0f);
  }
  void add_offset_x_min_value(float offset_x_min_value) {
    fbb_.AddElement<float>(EffectNode::VT_OFFSET_X_MIN_VALUE, offset_x_min_value, 0.0f);
  }
  void add_offset_x_max_value(float offset_x_max_value) {
    fbb_.AddElement<float>(EffectNode::VT_OFFSET_X_MAX_VALUE, offset_x_max_value, 0.0f);
  }
  void add_offset_y_min_value(float offset_y_min_value) {
    fbb_.AddElement<float>(EffectNode::VT_OFFSET_Y_MIN_VALUE, offset_y_min_value, 0.0f);
  }
  void add_offset_y_max_value(float offset_y_max_value) {
    fbb_.AddElement<float>(EffectNode::VT_OFFSET_Y_MAX_VALUE, offset_y_max_value, 0.0f);
  }
  void add_rotation_min_value(float rotation_min_value) {
    fbb_.AddElement<float>(EffectNode::VT_ROTATION_MIN_VALUE, rotation_min_value, 0.0f);
  }
  void add_rotation_max_value(float rotation_max_value) {
    fbb_.AddElement<float>(EffectNode::VT_ROTATION_MAX_VALUE, rotation_max_value, 0.0f);
  }
  void add_rotation_add_min_value(float rotation_add_min_value) {
    fbb_.AddElement<float>(EffectNode::VT_ROTATION_ADD_MIN_VALUE, rotation_add_min_value, 0.0f);
  }
  void add_rotation_add_max_value(float rotation_add_max_value) {
    fbb_.AddElement<float>(EffectNode::VT_ROTATION_ADD_MAX_VALUE, rotation_add_max_value, 0.0f);
  }
  void add_rotation_factor(float rotation_factor) {
    fbb_.AddElement<float>(EffectNode::VT_ROTATION_FACTOR, rotation_factor, 0.0f);
  }
  void add_end_life_time_per(float end_life_time_per) {
    fbb_.AddElement<float>(EffectNode::VT_END_LIFE_TIME_PER, end_life_time_per, 0.0f);
  }
  void add_speed_min_value(float speed_min_value) {
    fbb_.AddElement<float>(EffectNode::VT_SPEED_MIN_VALUE, speed_min_value, 0.0f);
  }
  void add_speed_max_value(float speed_max_value) {
    fbb_.AddElement<float>(EffectNode::VT_SPEED_MAX_VALUE, speed_max_value, 0.0f);
  }
  void add_acceleration_min_value(float acceleration_min_value) {
    fbb_.AddElement<float>(EffectNode::VT_ACCELERATION_MIN_VALUE, acceleration_min_value, 0.0f);
  }
  void add_acceleration_max_value(float acceleration_max_value) {
    fbb_.AddElement<float>(EffectNode::VT_ACCELERATION_MAX_VALUE, acceleration_max_value, 0.0f);
  }
  void add_init_color_min_value(uint32_t init_color_min_value) {
    fbb_.AddElement<uint32_t>(EffectNode::VT_INIT_COLOR_MIN_VALUE, init_color_min_value, 0);
  }
  void add_init_color_max_value(uint32_t init_color_max_value) {
    fbb_.AddElement<uint32_t>(EffectNode::VT_INIT_COLOR_MAX_VALUE, init_color_max_value, 0);
  }
  void add_trans_color_min_value(uint32_t trans_color_min_value) {
    fbb_.AddElement<uint32_t>(EffectNode::VT_TRANS_COLOR_MIN_VALUE, trans_color_min_value, 0);
  }
  void add_trans_color_max_value(uint32_t trans_color_max_value) {
    fbb_.AddElement<uint32_t>(EffectNode::VT_TRANS_COLOR_MAX_VALUE, trans_color_max_value, 0);
  }
  void add_disprange_min_value(float disprange_min_value) {
    fbb_.AddElement<float>(EffectNode::VT_DISPRANGE_MIN_VALUE, disprange_min_value, 0.0f);
  }
  void add_disprange_max_value(float disprange_max_value) {
    fbb_.AddElement<float>(EffectNode::VT_DISPRANGE_MAX_VALUE, disprange_max_value, 0.0f);
  }
  void add_size_x_min_value(float size_x_min_value) {
    fbb_.AddElement<float>(EffectNode::VT_SIZE_X_MIN_VALUE, size_x_min_value, 0.0f);
  }
  void add_size_x_max_value(float size_x_max_value) {
    fbb_.AddElement<float>(EffectNode::VT_SIZE_X_MAX_VALUE, size_x_max_value, 0.0f);
  }
  void add_size_y_min_value(float size_y_min_value) {
    fbb_.AddElement<float>(EffectNode::VT_SIZE_Y_MIN_VALUE, size_y_min_value, 0.0f);
  }
  void add_size_y_max_value(float size_y_max_value) {
    fbb_.AddElement<float>(EffectNode::VT_SIZE_Y_MAX_VALUE, size_y_max_value, 0.0f);
  }
  void add_scale_factor_min_value(float scale_factor_min_value) {
    fbb_.AddElement<float>(EffectNode::VT_SCALE_FACTOR_MIN_VALUE, scale_factor_min_value, 0.0f);
  }
  void add_scale_factor_max_value(float scale_factor_max_value) {
    fbb_.AddElement<float>(EffectNode::VT_SCALE_FACTOR_MAX_VALUE, scale_factor_max_value, 0.0f);
  }
  void add_trans_size_x_min_value(float trans_size_x_min_value) {
    fbb_.AddElement<float>(EffectNode::VT_TRANS_SIZE_X_MIN_VALUE, trans_size_x_min_value, 0.0f);
  }
  void add_trans_size_x_max_value(float trans_size_x_max_value) {
    fbb_.AddElement<float>(EffectNode::VT_TRANS_SIZE_X_MAX_VALUE, trans_size_x_max_value, 0.0f);
  }
  void add_trans_size_y_min_value(float trans_size_y_min_value) {
    fbb_.AddElement<float>(EffectNode::VT_TRANS_SIZE_Y_MIN_VALUE, trans_size_y_min_value, 0.0f);
  }
  void add_trans_size_y_max_value(float trans_size_y_max_value) {
    fbb_.AddElement<float>(EffectNode::VT_TRANS_SIZE_Y_MAX_VALUE, trans_size_y_max_value, 0.0f);
  }
  void add_trans_scale_factor_min_value(float trans_scale_factor_min_value) {
    fbb_.AddElement<float>(EffectNode::VT_TRANS_SCALE_FACTOR_MIN_VALUE, trans_scale_factor_min_value, 0.0f);
  }
  void add_trans_scale_factor_max_value(float trans_scale_factor_max_value) {
    fbb_.AddElement<float>(EffectNode::VT_TRANS_SCALE_FACTOR_MAX_VALUE, trans_scale_factor_max_value, 0.0f);
  }
  void add_point_gravity_position_x(float point_gravity_position_x) {
    fbb_.AddElement<float>(EffectNode::VT_POINT_GRAVITY_POSITION_X, point_gravity_position_x, 0.0f);
  }
  void add_point_gravity_position_y(float point_gravity_position_y) {
    fbb_.AddElement<float>(EffectNode::VT_POINT_GRAVITY_POSITION_Y, point_gravity_position_y, 0.0f);
  }
  void add_point_gravity_power(float point_gravity_power) {
    fbb_.AddElement<float>(EffectNode::VT_POINT_GRAVITY_POWER, point_gravity_power, 0.0f);
  }
  void add_rotation(float rotation) {
    fbb_.AddElement<float>(EffectNode::VT_ROTATION, rotation, 0.0f);
  }
  void add_infinitie_emit_flag(int32_t infinitie_emit_flag) {
    fbb_.AddElement<int32_t>(EffectNode::VT_INFINITIE_EMIT_FLAG, infinitie_emit_flag, 0);
  }
  explicit EffectNodeBuilder(flatbuffers::FlatBufferBuilder &_fbb)
        : fbb_(_fbb) {
    start_ = fbb_.StartTable();
  }
  flatbuffers::Offset<EffectNode> Finish() {
    const auto end = fbb_.EndTable(start_);
    auto o = flatbuffers::Offset<EffectNode>(end);
    return o;
  }
};

inline flatbuffers::Offset<EffectNode> CreateEffectNode(
    flatbuffers::FlatBufferBuilder &_fbb,
    int16_t array_index = 0,
    int16_t parent_index = 0,
    ss::ssfb::EffectNodeType type = ss::ssfb::EffectNodeType_Root,
    int16_t cell_index = 0,
    ss::ssfb::EffectRenderBlendType blend_type = ss::ssfb::EffectRenderBlendType_Mix,
    const ss::ssfb::EffectParticleElementBasic *basic_behavior = nullptr,
    ss::ssfb::EffectBehaviorFlags behavior_flags = static_cast<ss::ssfb::EffectBehaviorFlags>(0),
    int32_t seed = 0,
    int32_t delay_time = 0,
    float gravity_x = 0.0f,
    float gravity_y = 0.0f,
    float offset_x_min_value = 0.0f,
    float offset_x_max_value = 0.0f,
    float offset_y_min_value = 0.0f,
    float offset_y_max_value = 0.0f,
    float rotation_min_value = 0.0f,
    float rotation_max_value = 0.0f,
    float rotation_add_min_value = 0.0f,
    float rotation_add_max_value = 0.0f,
    float rotation_factor = 0.0f,
    float end_life_time_per = 0.0f,
    float speed_min_value = 0.0f,
    float speed_max_value = 0.0f,
    float acceleration_min_value = 0.0f,
    float acceleration_max_value = 0.0f,
    uint32_t init_color_min_value = 0,
    uint32_t init_color_max_value = 0,
    uint32_t trans_color_min_value = 0,
    uint32_t trans_color_max_value = 0,
    float disprange_min_value = 0.0f,
    float disprange_max_value = 0.0f,
    float size_x_min_value = 0.0f,
    float size_x_max_value = 0.0f,
    float size_y_min_value = 0.0f,
    float size_y_max_value = 0.0f,
    float scale_factor_min_value = 0.0f,
    float scale_factor_max_value = 0.0f,
    float trans_size_x_min_value = 0.0f,
    float trans_size_x_max_value = 0.0f,
    float trans_size_y_min_value = 0.0f,
    float trans_size_y_max_value = 0.0f,
    float trans_scale_factor_min_value = 0.0f,
    float trans_scale_factor_max_value = 0.0f,
    float point_gravity_position_x = 0.0f,
    float point_gravity_position_y = 0.0f,
    float point_gravity_power = 0.0f,
    float rotation = 0.0f,
    int32_t infinitie_emit_flag = 0) {
  EffectNodeBuilder builder_(_fbb);
  builder_.add_infinitie_emit_flag(infinitie_emit_flag);
  builder_.add_rotation(rotation);
  builder_.add_point_gravity_power(point_gravity_power);
  builder_.add_point_gravity_position_y(point_gravity_position_y);
  builder_.add_point_gravity_position_x(point_gravity_position_x);
  builder_.add_trans_scale_factor_max_value(trans_scale_factor_max_value);
  builder_.add_trans_scale_factor_min_value(trans_scale_factor_min_value);
  builder_.add_trans_size_y_max_value(trans_size_y_max_value);
  builder_.add_trans_size_y_min_value(trans_size_y_min_value);
  builder_.add_trans_size_x_max_value(trans_size_x_max_value);
  builder_.add_trans_size_x_min_value(trans_size_x_min_value);
  builder_.add_scale_factor_max_value(scale_factor_max_value);
  builder_.add_scale_factor_min_value(scale_factor_min_value);
  builder_.add_size_y_max_value(size_y_max_value);
  builder_.add_size_y_min_value(size_y_min_value);
  builder_.add_size_x_max_value(size_x_max_value);
  builder_.add_size_x_min_value(size_x_min_value);
  builder_.add_disprange_max_value(disprange_max_value);
  builder_.add_disprange_min_value(disprange_min_value);
  builder_.add_trans_color_max_value(trans_color_max_value);
  builder_.add_trans_color_min_value(trans_color_min_value);
  builder_.add_init_color_max_value(init_color_max_value);
  builder_.add_init_color_min_value(init_color_min_value);
  builder_.add_acceleration_max_value(acceleration_max_value);
  builder_.add_acceleration_min_value(acceleration_min_value);
  builder_.add_speed_max_value(speed_max_value);
  builder_.add_speed_min_value(speed_min_value);
  builder_.add_end_life_time_per(end_life_time_per);
  builder_.add_rotation_factor(rotation_factor);
  builder_.add_rotation_add_max_value(rotation_add_max_value);
  builder_.add_rotation_add_min_value(rotation_add_min_value);
  builder_.add_rotation_max_value(rotation_max_value);
  builder_.add_rotation_min_value(rotation_min_value);
  builder_.add_offset_y_max_value(offset_y_max_value);
  builder_.add_offset_y_min_value(offset_y_min_value);
  builder_.add_offset_x_max_value(offset_x_max_value);
  builder_.add_offset_x_min_value(offset_x_min_value);
  builder_.add_gravity_y(gravity_y);
  builder_.add_gravity_x(gravity_x);
  builder_.add_delay_time(delay_time);
  builder_.add_seed(seed);
  builder_.add_behavior_flags(behavior_flags);
  builder_.add_basic_behavior(basic_behavior);
  builder_.add_cell_index(cell_index);
  builder_.add_parent_index(parent_index);
  builder_.add_array_index(array_index);
  builder_.add_blend_type(blend_type);
  builder_.add_type(type);
  return builder_.Finish();
}

flatbuffers::Offset<EffectNode> CreateEffectNode(flatbuffers::FlatBufferBuilder &_fbb, const EffectNodeT *_o, const flatbuffers::rehasher_function_t *_rehasher = nullptr);

struct EffectFileT : public flatbuffers::NativeTable {
  typedef EffectFile TableType;
  std::string name{};
  int16_t fps = 0;
  int16_t is_lock_rand_seed = 0;
  int16_t lock_rand_seed = 0;
  int16_t layout_scale_x = 0;
  int16_t layout_scale_y = 0;
  int16_t num_node_list = 0;
  std::vector<std::unique_ptr<ss::ssfb::EffectNodeT>> effect_node{};
};

struct EffectFile FLATBUFFERS_FINAL_CLASS : private flatbuffers::Table {
  typedef EffectFileT NativeTableType;
  typedef EffectFileBuilder Builder;
  enum FlatBuffersVTableOffset FLATBUFFERS_VTABLE_UNDERLYING_TYPE {
    VT_NAME = 4,
    VT_FPS = 6,
    VT_IS_LOCK_RAND_SEED = 8,
    VT_LOCK_RAND_SEED = 10,
    VT_LAYOUT_SCALE_X = 12,
    VT_LAYOUT_SCALE_Y = 14,
    VT_NUM_NODE_LIST = 16,
    VT_EFFECT_NODE = 18
  };
  const flatbuffers::String *name() const {
    return GetPointer<const flatbuffers::String *>(VT_NAME);
  }
  int16_t fps() const {
    return GetField<int16_t>(VT_FPS, 0);
  }
  int16_t is_lock_rand_seed() const {
    return GetField<int16_t>(VT_IS_LOCK_RAND_SEED, 0);
  }
  int16_t lock_rand_seed() const {
    return GetField<int16_t>(VT_LOCK_RAND_SEED, 0);
  }
  int16_t layout_scale_x() const {
    return GetField<int16_t>(VT_LAYOUT_SCALE_X, 0);
  }
  int16_t layout_scale_y() const {
    return GetField<int16_t>(VT_LAYOUT_SCALE_Y, 0);
  }
  int16_t num_node_list() const {
    return GetField<int16_t>(VT_NUM_NODE_LIST, 0);
  }
  const flatbuffers::Vector<flatbuffers::Offset<ss::ssfb::EffectNode>> *effect_node() const {
    return GetPointer<const flatbuffers::Vector<flatbuffers::Offset<ss::ssfb::EffectNode>> *>(VT_EFFECT_NODE);
  }
  bool Verify(flatbuffers::Verifier &verifier) const {
    return VerifyTableStart(verifier) &&
           VerifyOffset(verifier, VT_NAME) &&
           verifier.VerifyString(name()) &&
           VerifyField<int16_t>(verifier, VT_FPS) &&
           VerifyField<int16_t>(verifier, VT_IS_LOCK_RAND_SEED) &&
           VerifyField<int16_t>(verifier, VT_LOCK_RAND_SEED) &&
           VerifyField<int16_t>(verifier, VT_LAYOUT_SCALE_X) &&
           VerifyField<int16_t>(verifier, VT_LAYOUT_SCALE_Y) &&
           VerifyField<int16_t>(verifier, VT_NUM_NODE_LIST) &&
           VerifyOffset(verifier, VT_EFFECT_NODE) &&
           verifier.VerifyVector(effect_node()) &&
           verifier.VerifyVectorOfTables(effect_node()) &&
           verifier.EndTable();
  }
  EffectFileT *UnPack(const flatbuffers::resolver_function_t *_resolver = nullptr) const;
  void UnPackTo(EffectFileT *_o, const flatbuffers::resolver_function_t *_resolver = nullptr) const;
  static flatbuffers::Offset<EffectFile> Pack(flatbuffers::FlatBufferBuilder &_fbb, const EffectFileT* _o, const flatbuffers::rehasher_function_t *_rehasher = nullptr);
};

struct EffectFileBuilder {
  typedef EffectFile Table;
  flatbuffers::FlatBufferBuilder &fbb_;
  flatbuffers::uoffset_t start_;
  void add_name(flatbuffers::Offset<flatbuffers::String> name) {
    fbb_.AddOffset(EffectFile::VT_NAME, name);
  }
  void add_fps(int16_t fps) {
    fbb_.AddElement<int16_t>(EffectFile::VT_FPS, fps, 0);
  }
  void add_is_lock_rand_seed(int16_t is_lock_rand_seed) {
    fbb_.AddElement<int16_t>(EffectFile::VT_IS_LOCK_RAND_SEED, is_lock_rand_seed, 0);
  }
  void add_lock_rand_seed(int16_t lock_rand_seed) {
    fbb_.AddElement<int16_t>(EffectFile::VT_LOCK_RAND_SEED, lock_rand_seed, 0);
  }
  void add_layout_scale_x(int16_t layout_scale_x) {
    fbb_.AddElement<int16_t>(EffectFile::VT_LAYOUT_SCALE_X, layout_scale_x, 0);
  }
  void add_layout_scale_y(int16_t layout_scale_y) {
    fbb_.AddElement<int16_t>(EffectFile::VT_LAYOUT_SCALE_Y, layout_scale_y, 0);
  }
  void add_num_node_list(int16_t num_node_list) {
    fbb_.AddElement<int16_t>(EffectFile::VT_NUM_NODE_LIST, num_node_list, 0);
  }
  void add_effect_node(flatbuffers::Offset<flatbuffers::Vector<flatbuffers::Offset<ss::ssfb::EffectNode>>> effect_node) {
    fbb_.AddOffset(EffectFile::VT_EFFECT_NODE, effect_node);
  }
  explicit EffectFileBuilder(flatbuffers::FlatBufferBuilder &_fbb)
        : fbb_(_fbb) {
    start_ = fbb_.StartTable();
  }
  flatbuffers::Offset<EffectFile> Finish() {
    const auto end = fbb_.EndTable(start_);
    auto o = flatbuffers::Offset<EffectFile>(end);
    return o;
  }
};

inline flatbuffers::Offset<EffectFile> CreateEffectFile(
    flatbuffers::FlatBufferBuilder &_fbb,
    flatbuffers::Offset<flatbuffers::String> name = 0,
    int16_t fps = 0,
    int16_t is_lock_rand_seed = 0,
    int16_t lock_rand_seed = 0,
    int16_t layout_scale_x = 0,
    int16_t layout_scale_y = 0,
    int16_t num_node_list = 0,
    flatbuffers::Offset<flatbuffers::Vector<flatbuffers::Offset<ss::ssfb::EffectNode>>> effect_node = 0) {
  EffectFileBuilder builder_(_fbb);
  builder_.add_effect_node(effect_node);
  builder_.add_name(name);
  builder_.add_num_node_list(num_node_list);
  builder_.add_layout_scale_y(layout_scale_y);
  builder_.add_layout_scale_x(layout_scale_x);
  builder_.add_lock_rand_seed(lock_rand_seed);
  builder_.add_is_lock_rand_seed(is_lock_rand_seed);
  builder_.add_fps(fps);
  return builder_.Finish();
}

inline flatbuffers::Offset<EffectFile> CreateEffectFileDirect(
    flatbuffers::FlatBufferBuilder &_fbb,
    const char *name = nullptr,
    int16_t fps = 0,
    int16_t is_lock_rand_seed = 0,
    int16_t lock_rand_seed = 0,
    int16_t layout_scale_x = 0,
    int16_t layout_scale_y = 0,
    int16_t num_node_list = 0,
    const std::vector<flatbuffers::Offset<ss::ssfb::EffectNode>> *effect_node = nullptr) {
  auto name__ = name ? _fbb.CreateString(name) : 0;
  auto effect_node__ = effect_node ? _fbb.CreateVector<flatbuffers::Offset<ss::ssfb::EffectNode>>(*effect_node) : 0;
  return ss::ssfb::CreateEffectFile(
      _fbb,
      name__,
      fps,
      is_lock_rand_seed,
      lock_rand_seed,
      layout_scale_x,
      layout_scale_y,
      num_node_list,
      effect_node__);
}

flatbuffers::Offset<EffectFile> CreateEffectFile(flatbuffers::FlatBufferBuilder &_fbb, const EffectFileT *_o, const flatbuffers::rehasher_function_t *_rehasher = nullptr);

struct CellMapT : public flatbuffers::NativeTable {
  typedef CellMap TableType;
  std::string name{};
  std::string image_path{};
  int16_t index = 0;
  int16_t wrap_mode = 0;
  int16_t filter_mode = 0;
};

struct CellMap FLATBUFFERS_FINAL_CLASS : private flatbuffers::Table {
  typedef CellMapT NativeTableType;
  typedef CellMapBuilder Builder;
  enum FlatBuffersVTableOffset FLATBUFFERS_VTABLE_UNDERLYING_TYPE {
    VT_NAME = 4,
    VT_IMAGE_PATH = 6,
    VT_INDEX = 8,
    VT_WRAP_MODE = 10,
    VT_FILTER_MODE = 12
  };
  const flatbuffers::String *name() const {
    return GetPointer<const flatbuffers::String *>(VT_NAME);
  }
  const flatbuffers::String *image_path() const {
    return GetPointer<const flatbuffers::String *>(VT_IMAGE_PATH);
  }
  int16_t index() const {
    return GetField<int16_t>(VT_INDEX, 0);
  }
  int16_t wrap_mode() const {
    return GetField<int16_t>(VT_WRAP_MODE, 0);
  }
  int16_t filter_mode() const {
    return GetField<int16_t>(VT_FILTER_MODE, 0);
  }
  bool Verify(flatbuffers::Verifier &verifier) const {
    return VerifyTableStart(verifier) &&
           VerifyOffset(verifier, VT_NAME) &&
           verifier.VerifyString(name()) &&
           VerifyOffset(verifier, VT_IMAGE_PATH) &&
           verifier.VerifyString(image_path()) &&
           VerifyField<int16_t>(verifier, VT_INDEX) &&
           VerifyField<int16_t>(verifier, VT_WRAP_MODE) &&
           VerifyField<int16_t>(verifier, VT_FILTER_MODE) &&
           verifier.EndTable();
  }
  CellMapT *UnPack(const flatbuffers::resolver_function_t *_resolver = nullptr) const;
  void UnPackTo(CellMapT *_o, const flatbuffers::resolver_function_t *_resolver = nullptr) const;
  static flatbuffers::Offset<CellMap> Pack(flatbuffers::FlatBufferBuilder &_fbb, const CellMapT* _o, const flatbuffers::rehasher_function_t *_rehasher = nullptr);
};

struct CellMapBuilder {
  typedef CellMap Table;
  flatbuffers::FlatBufferBuilder &fbb_;
  flatbuffers::uoffset_t start_;
  void add_name(flatbuffers::Offset<flatbuffers::String> name) {
    fbb_.AddOffset(CellMap::VT_NAME, name);
  }
  void add_image_path(flatbuffers::Offset<flatbuffers::String> image_path) {
    fbb_.AddOffset(CellMap::VT_IMAGE_PATH, image_path);
  }
  void add_index(int16_t index) {
    fbb_.AddElement<int16_t>(CellMap::VT_INDEX, index, 0);
  }
  void add_wrap_mode(int16_t wrap_mode) {
    fbb_.AddElement<int16_t>(CellMap::VT_WRAP_MODE, wrap_mode, 0);
  }
  void add_filter_mode(int16_t filter_mode) {
    fbb_.AddElement<int16_t>(CellMap::VT_FILTER_MODE, filter_mode, 0);
  }
  explicit CellMapBuilder(flatbuffers::FlatBufferBuilder &_fbb)
        : fbb_(_fbb) {
    start_ = fbb_.StartTable();
  }
  flatbuffers::Offset<CellMap> Finish() {
    const auto end = fbb_.EndTable(start_);
    auto o = flatbuffers::Offset<CellMap>(end);
    return o;
  }
};

inline flatbuffers::Offset<CellMap> CreateCellMap(
    flatbuffers::FlatBufferBuilder &_fbb,
    flatbuffers::Offset<flatbuffers::String> name = 0,
    flatbuffers::Offset<flatbuffers::String> image_path = 0,
    int16_t index = 0,
    int16_t wrap_mode = 0,
    int16_t filter_mode = 0) {
  CellMapBuilder builder_(_fbb);
  builder_.add_image_path(image_path);
  builder_.add_name(name);
  builder_.add_filter_mode(filter_mode);
  builder_.add_wrap_mode(wrap_mode);
  builder_.add_index(index);
  return builder_.Finish();
}

inline flatbuffers::Offset<CellMap> CreateCellMapDirect(
    flatbuffers::FlatBufferBuilder &_fbb,
    const char *name = nullptr,
    const char *image_path = nullptr,
    int16_t index = 0,
    int16_t wrap_mode = 0,
    int16_t filter_mode = 0) {
  auto name__ = name ? _fbb.CreateString(name) : 0;
  auto image_path__ = image_path ? _fbb.CreateString(image_path) : 0;
  return ss::ssfb::CreateCellMap(
      _fbb,
      name__,
      image_path__,
      index,
      wrap_mode,
      filter_mode);
}

flatbuffers::Offset<CellMap> CreateCellMap(flatbuffers::FlatBufferBuilder &_fbb, const CellMapT *_o, const flatbuffers::rehasher_function_t *_rehasher = nullptr);

struct CellT : public flatbuffers::NativeTable {
  typedef Cell TableType;
  std::string name{};
  std::unique_ptr<ss::ssfb::CellMapT> cell_map{};
  int16_t index_in_cell_map = 0;
  int16_t x = 0;
  int16_t y = 0;
  int16_t width = 0;
  int16_t height = 0;
  float pivot_x = 0.0f;
  float pivot_y = 0.0f;
  float u1 = 0.0f;
  float v1 = 0.0f;
  float u2 = 0.0f;
  float v2 = 0.0f;
};

struct Cell FLATBUFFERS_FINAL_CLASS : private flatbuffers::Table {
  typedef CellT NativeTableType;
  typedef CellBuilder Builder;
  enum FlatBuffersVTableOffset FLATBUFFERS_VTABLE_UNDERLYING_TYPE {
    VT_NAME = 4,
    VT_CELL_MAP = 6,
    VT_INDEX_IN_CELL_MAP = 8,
    VT_X = 10,
    VT_Y = 12,
    VT_WIDTH = 14,
    VT_HEIGHT = 16,
    VT_PIVOT_X = 18,
    VT_PIVOT_Y = 20,
    VT_U1 = 22,
    VT_V1 = 24,
    VT_U2 = 26,
    VT_V2 = 28
  };
  const flatbuffers::String *name() const {
    return GetPointer<const flatbuffers::String *>(VT_NAME);
  }
  const ss::ssfb::CellMap *cell_map() const {
    return GetPointer<const ss::ssfb::CellMap *>(VT_CELL_MAP);
  }
  int16_t index_in_cell_map() const {
    return GetField<int16_t>(VT_INDEX_IN_CELL_MAP, 0);
  }
  int16_t x() const {
    return GetField<int16_t>(VT_X, 0);
  }
  int16_t y() const {
    return GetField<int16_t>(VT_Y, 0);
  }
  int16_t width() const {
    return GetField<int16_t>(VT_WIDTH, 0);
  }
  int16_t height() const {
    return GetField<int16_t>(VT_HEIGHT, 0);
  }
  float pivot_x() const {
    return GetField<float>(VT_PIVOT_X, 0.0f);
  }
  float pivot_y() const {
    return GetField<float>(VT_PIVOT_Y, 0.0f);
  }
  float u1() const {
    return GetField<float>(VT_U1, 0.0f);
  }
  float v1() const {
    return GetField<float>(VT_V1, 0.0f);
  }
  float u2() const {
    return GetField<float>(VT_U2, 0.0f);
  }
  float v2() const {
    return GetField<float>(VT_V2, 0.0f);
  }
  bool Verify(flatbuffers::Verifier &verifier) const {
    return VerifyTableStart(verifier) &&
           VerifyOffset(verifier, VT_NAME) &&
           verifier.VerifyString(name()) &&
           VerifyOffset(verifier, VT_CELL_MAP) &&
           verifier.VerifyTable(cell_map()) &&
           VerifyField<int16_t>(verifier, VT_INDEX_IN_CELL_MAP) &&
           VerifyField<int16_t>(verifier, VT_X) &&
           VerifyField<int16_t>(verifier, VT_Y) &&
           VerifyField<int16_t>(verifier, VT_WIDTH) &&
           VerifyField<int16_t>(verifier, VT_HEIGHT) &&
           VerifyField<float>(verifier, VT_PIVOT_X) &&
           VerifyField<float>(verifier, VT_PIVOT_Y) &&
           VerifyField<float>(verifier, VT_U1) &&
           VerifyField<float>(verifier, VT_V1) &&
           VerifyField<float>(verifier, VT_U2) &&
           VerifyField<float>(verifier, VT_V2) &&
           verifier.EndTable();
  }
  CellT *UnPack(const flatbuffers::resolver_function_t *_resolver = nullptr) const;
  void UnPackTo(CellT *_o, const flatbuffers::resolver_function_t *_resolver = nullptr) const;
  static flatbuffers::Offset<Cell> Pack(flatbuffers::FlatBufferBuilder &_fbb, const CellT* _o, const flatbuffers::rehasher_function_t *_rehasher = nullptr);
};

struct CellBuilder {
  typedef Cell Table;
  flatbuffers::FlatBufferBuilder &fbb_;
  flatbuffers::uoffset_t start_;
  void add_name(flatbuffers::Offset<flatbuffers::String> name) {
    fbb_.AddOffset(Cell::VT_NAME, name);
  }
  void add_cell_map(flatbuffers::Offset<ss::ssfb::CellMap> cell_map) {
    fbb_.AddOffset(Cell::VT_CELL_MAP, cell_map);
  }
  void add_index_in_cell_map(int16_t index_in_cell_map) {
    fbb_.AddElement<int16_t>(Cell::VT_INDEX_IN_CELL_MAP, index_in_cell_map, 0);
  }
  void add_x(int16_t x) {
    fbb_.AddElement<int16_t>(Cell::VT_X, x, 0);
  }
  void add_y(int16_t y) {
    fbb_.AddElement<int16_t>(Cell::VT_Y, y, 0);
  }
  void add_width(int16_t width) {
    fbb_.AddElement<int16_t>(Cell::VT_WIDTH, width, 0);
  }
  void add_height(int16_t height) {
    fbb_.AddElement<int16_t>(Cell::VT_HEIGHT, height, 0);
  }
  void add_pivot_x(float pivot_x) {
    fbb_.AddElement<float>(Cell::VT_PIVOT_X, pivot_x, 0.0f);
  }
  void add_pivot_y(float pivot_y) {
    fbb_.AddElement<float>(Cell::VT_PIVOT_Y, pivot_y, 0.0f);
  }
  void add_u1(float u1) {
    fbb_.AddElement<float>(Cell::VT_U1, u1, 0.0f);
  }
  void add_v1(float v1) {
    fbb_.AddElement<float>(Cell::VT_V1, v1, 0.0f);
  }
  void add_u2(float u2) {
    fbb_.AddElement<float>(Cell::VT_U2, u2, 0.0f);
  }
  void add_v2(float v2) {
    fbb_.AddElement<float>(Cell::VT_V2, v2, 0.0f);
  }
  explicit CellBuilder(flatbuffers::FlatBufferBuilder &_fbb)
        : fbb_(_fbb) {
    start_ = fbb_.StartTable();
  }
  flatbuffers::Offset<Cell> Finish() {
    const auto end = fbb_.EndTable(start_);
    auto o = flatbuffers::Offset<Cell>(end);
    return o;
  }
};

inline flatbuffers::Offset<Cell> CreateCell(
    flatbuffers::FlatBufferBuilder &_fbb,
    flatbuffers::Offset<flatbuffers::String> name = 0,
    flatbuffers::Offset<ss::ssfb::CellMap> cell_map = 0,
    int16_t index_in_cell_map = 0,
    int16_t x = 0,
    int16_t y = 0,
    int16_t width = 0,
    int16_t height = 0,
    float pivot_x = 0.0f,
    float pivot_y = 0.0f,
    float u1 = 0.0f,
    float v1 = 0.0f,
    float u2 = 0.0f,
    float v2 = 0.0f) {
  CellBuilder builder_(_fbb);
  builder_.add_v2(v2);
  builder_.add_u2(u2);
  builder_.add_v1(v1);
  builder_.add_u1(u1);
  builder_.add_pivot_y(pivot_y);
  builder_.add_pivot_x(pivot_x);
  builder_.add_cell_map(cell_map);
  builder_.add_name(name);
  builder_.add_height(height);
  builder_.add_width(width);
  builder_.add_y(y);
  builder_.add_x(x);
  builder_.add_index_in_cell_map(index_in_cell_map);
  return builder_.Finish();
}

inline flatbuffers::Offset<Cell> CreateCellDirect(
    flatbuffers::FlatBufferBuilder &_fbb,
    const char *name = nullptr,
    flatbuffers::Offset<ss::ssfb::CellMap> cell_map = 0,
    int16_t index_in_cell_map = 0,
    int16_t x = 0,
    int16_t y = 0,
    int16_t width = 0,
    int16_t height = 0,
    float pivot_x = 0.0f,
    float pivot_y = 0.0f,
    float u1 = 0.0f,
    float v1 = 0.0f,
    float u2 = 0.0f,
    float v2 = 0.0f) {
  auto name__ = name ? _fbb.CreateString(name) : 0;
  return ss::ssfb::CreateCell(
      _fbb,
      name__,
      cell_map,
      index_in_cell_map,
      x,
      y,
      width,
      height,
      pivot_x,
      pivot_y,
      u1,
      v1,
      u2,
      v2);
}

flatbuffers::Offset<Cell> CreateCell(flatbuffers::FlatBufferBuilder &_fbb, const CellT *_o, const flatbuffers::rehasher_function_t *_rehasher = nullptr);

struct MeshDataUVT : public flatbuffers::NativeTable {
  typedef MeshDataUV TableType;
  std::vector<float> uv{};
};

struct MeshDataUV FLATBUFFERS_FINAL_CLASS : private flatbuffers::Table {
  typedef MeshDataUVT NativeTableType;
  typedef MeshDataUVBuilder Builder;
  enum FlatBuffersVTableOffset FLATBUFFERS_VTABLE_UNDERLYING_TYPE {
    VT_UV = 4
  };
  const flatbuffers::Vector<float> *uv() const {
    return GetPointer<const flatbuffers::Vector<float> *>(VT_UV);
  }
  bool Verify(flatbuffers::Verifier &verifier) const {
    return VerifyTableStart(verifier) &&
           VerifyOffset(verifier, VT_UV) &&
           verifier.VerifyVector(uv()) &&
           verifier.EndTable();
  }
  MeshDataUVT *UnPack(const flatbuffers::resolver_function_t *_resolver = nullptr) const;
  void UnPackTo(MeshDataUVT *_o, const flatbuffers::resolver_function_t *_resolver = nullptr) const;
  static flatbuffers::Offset<MeshDataUV> Pack(flatbuffers::FlatBufferBuilder &_fbb, const MeshDataUVT* _o, const flatbuffers::rehasher_function_t *_rehasher = nullptr);
};

struct MeshDataUVBuilder {
  typedef MeshDataUV Table;
  flatbuffers::FlatBufferBuilder &fbb_;
  flatbuffers::uoffset_t start_;
  void add_uv(flatbuffers::Offset<flatbuffers::Vector<float>> uv) {
    fbb_.AddOffset(MeshDataUV::VT_UV, uv);
  }
  explicit MeshDataUVBuilder(flatbuffers::FlatBufferBuilder &_fbb)
        : fbb_(_fbb) {
    start_ = fbb_.StartTable();
  }
  flatbuffers::Offset<MeshDataUV> Finish() {
    const auto end = fbb_.EndTable(start_);
    auto o = flatbuffers::Offset<MeshDataUV>(end);
    return o;
  }
};

inline flatbuffers::Offset<MeshDataUV> CreateMeshDataUV(
    flatbuffers::FlatBufferBuilder &_fbb,
    flatbuffers::Offset<flatbuffers::Vector<float>> uv = 0) {
  MeshDataUVBuilder builder_(_fbb);
  builder_.add_uv(uv);
  return builder_.Finish();
}

inline flatbuffers::Offset<MeshDataUV> CreateMeshDataUVDirect(
    flatbuffers::FlatBufferBuilder &_fbb,
    const std::vector<float> *uv = nullptr) {
  auto uv__ = uv ? _fbb.CreateVector<float>(*uv) : 0;
  return ss::ssfb::CreateMeshDataUV(
      _fbb,
      uv__);
}

flatbuffers::Offset<MeshDataUV> CreateMeshDataUV(flatbuffers::FlatBufferBuilder &_fbb, const MeshDataUVT *_o, const flatbuffers::rehasher_function_t *_rehasher = nullptr);

struct MeshDataIndicesT : public flatbuffers::NativeTable {
  typedef MeshDataIndices TableType;
  std::vector<float> indices{};
};

struct MeshDataIndices FLATBUFFERS_FINAL_CLASS : private flatbuffers::Table {
  typedef MeshDataIndicesT NativeTableType;
  typedef MeshDataIndicesBuilder Builder;
  enum FlatBuffersVTableOffset FLATBUFFERS_VTABLE_UNDERLYING_TYPE {
    VT_INDICES = 4
  };
  const flatbuffers::Vector<float> *indices() const {
    return GetPointer<const flatbuffers::Vector<float> *>(VT_INDICES);
  }
  bool Verify(flatbuffers::Verifier &verifier) const {
    return VerifyTableStart(verifier) &&
           VerifyOffset(verifier, VT_INDICES) &&
           verifier.VerifyVector(indices()) &&
           verifier.EndTable();
  }
  MeshDataIndicesT *UnPack(const flatbuffers::resolver_function_t *_resolver = nullptr) const;
  void UnPackTo(MeshDataIndicesT *_o, const flatbuffers::resolver_function_t *_resolver = nullptr) const;
  static flatbuffers::Offset<MeshDataIndices> Pack(flatbuffers::FlatBufferBuilder &_fbb, const MeshDataIndicesT* _o, const flatbuffers::rehasher_function_t *_rehasher = nullptr);
};

struct MeshDataIndicesBuilder {
  typedef MeshDataIndices Table;
  flatbuffers::FlatBufferBuilder &fbb_;
  flatbuffers::uoffset_t start_;
  void add_indices(flatbuffers::Offset<flatbuffers::Vector<float>> indices) {
    fbb_.AddOffset(MeshDataIndices::VT_INDICES, indices);
  }
  explicit MeshDataIndicesBuilder(flatbuffers::FlatBufferBuilder &_fbb)
        : fbb_(_fbb) {
    start_ = fbb_.StartTable();
  }
  flatbuffers::Offset<MeshDataIndices> Finish() {
    const auto end = fbb_.EndTable(start_);
    auto o = flatbuffers::Offset<MeshDataIndices>(end);
    return o;
  }
};

inline flatbuffers::Offset<MeshDataIndices> CreateMeshDataIndices(
    flatbuffers::FlatBufferBuilder &_fbb,
    flatbuffers::Offset<flatbuffers::Vector<float>> indices = 0) {
  MeshDataIndicesBuilder builder_(_fbb);
  builder_.add_indices(indices);
  return builder_.Finish();
}

inline flatbuffers::Offset<MeshDataIndices> CreateMeshDataIndicesDirect(
    flatbuffers::FlatBufferBuilder &_fbb,
    const std::vector<float> *indices = nullptr) {
  auto indices__ = indices ? _fbb.CreateVector<float>(*indices) : 0;
  return ss::ssfb::CreateMeshDataIndices(
      _fbb,
      indices__);
}

flatbuffers::Offset<MeshDataIndices> CreateMeshDataIndices(flatbuffers::FlatBufferBuilder &_fbb, const MeshDataIndicesT *_o, const flatbuffers::rehasher_function_t *_rehasher = nullptr);

struct PartStateT : public flatbuffers::NativeTable {
  typedef PartState TableType;
  int16_t index = 0;
  uint32_t flag1 = 0;
  uint32_t flag2 = 0;
  std::vector<uint32_t> data{};
};

struct PartState FLATBUFFERS_FINAL_CLASS : private flatbuffers::Table {
  typedef PartStateT NativeTableType;
  typedef PartStateBuilder Builder;
  enum FlatBuffersVTableOffset FLATBUFFERS_VTABLE_UNDERLYING_TYPE {
    VT_INDEX = 4,
    VT_FLAG1 = 6,
    VT_FLAG2 = 8,
    VT_DATA = 10
  };
  int16_t index() const {
    return GetField<int16_t>(VT_INDEX, 0);
  }
  uint32_t flag1() const {
    return GetField<uint32_t>(VT_FLAG1, 0);
  }
  uint32_t flag2() const {
    return GetField<uint32_t>(VT_FLAG2, 0);
  }
  const flatbuffers::Vector<uint32_t> *data() const {
    return GetPointer<const flatbuffers::Vector<uint32_t> *>(VT_DATA);
  }
  bool Verify(flatbuffers::Verifier &verifier) const {
    return VerifyTableStart(verifier) &&
           VerifyField<int16_t>(verifier, VT_INDEX) &&
           VerifyField<uint32_t>(verifier, VT_FLAG1) &&
           VerifyField<uint32_t>(verifier, VT_FLAG2) &&
           VerifyOffset(verifier, VT_DATA) &&
           verifier.VerifyVector(data()) &&
           verifier.EndTable();
  }
  PartStateT *UnPack(const flatbuffers::resolver_function_t *_resolver = nullptr) const;
  void UnPackTo(PartStateT *_o, const flatbuffers::resolver_function_t *_resolver = nullptr) const;
  static flatbuffers::Offset<PartState> Pack(flatbuffers::FlatBufferBuilder &_fbb, const PartStateT* _o, const flatbuffers::rehasher_function_t *_rehasher = nullptr);
};

struct PartStateBuilder {
  typedef PartState Table;
  flatbuffers::FlatBufferBuilder &fbb_;
  flatbuffers::uoffset_t start_;
  void add_index(int16_t index) {
    fbb_.AddElement<int16_t>(PartState::VT_INDEX, index, 0);
  }
  void add_flag1(uint32_t flag1) {
    fbb_.AddElement<uint32_t>(PartState::VT_FLAG1, flag1, 0);
  }
  void add_flag2(uint32_t flag2) {
    fbb_.AddElement<uint32_t>(PartState::VT_FLAG2, flag2, 0);
  }
  void add_data(flatbuffers::Offset<flatbuffers::Vector<uint32_t>> data) {
    fbb_.AddOffset(PartState::VT_DATA, data);
  }
  explicit PartStateBuilder(flatbuffers::FlatBufferBuilder &_fbb)
        : fbb_(_fbb) {
    start_ = fbb_.StartTable();
  }
  flatbuffers::Offset<PartState> Finish() {
    const auto end = fbb_.EndTable(start_);
    auto o = flatbuffers::Offset<PartState>(end);
    return o;
  }
};

inline flatbuffers::Offset<PartState> CreatePartState(
    flatbuffers::FlatBufferBuilder &_fbb,
    int16_t index = 0,
    uint32_t flag1 = 0,
    uint32_t flag2 = 0,
    flatbuffers::Offset<flatbuffers::Vector<uint32_t>> data = 0) {
  PartStateBuilder builder_(_fbb);
  builder_.add_data(data);
  builder_.add_flag2(flag2);
  builder_.add_flag1(flag1);
  builder_.add_index(index);
  return builder_.Finish();
}

inline flatbuffers::Offset<PartState> CreatePartStateDirect(
    flatbuffers::FlatBufferBuilder &_fbb,
    int16_t index = 0,
    uint32_t flag1 = 0,
    uint32_t flag2 = 0,
    const std::vector<uint32_t> *data = nullptr) {
  auto data__ = data ? _fbb.CreateVector<uint32_t>(*data) : 0;
  return ss::ssfb::CreatePartState(
      _fbb,
      index,
      flag1,
      flag2,
      data__);
}

flatbuffers::Offset<PartState> CreatePartState(flatbuffers::FlatBufferBuilder &_fbb, const PartStateT *_o, const flatbuffers::rehasher_function_t *_rehasher = nullptr);

struct FrameDataIndexT : public flatbuffers::NativeTable {
  typedef FrameDataIndex TableType;
  std::vector<std::unique_ptr<ss::ssfb::PartStateT>> states{};
};

struct FrameDataIndex FLATBUFFERS_FINAL_CLASS : private flatbuffers::Table {
  typedef FrameDataIndexT NativeTableType;
  typedef FrameDataIndexBuilder Builder;
  enum FlatBuffersVTableOffset FLATBUFFERS_VTABLE_UNDERLYING_TYPE {
    VT_STATES = 4
  };
  const flatbuffers::Vector<flatbuffers::Offset<ss::ssfb::PartState>> *states() const {
    return GetPointer<const flatbuffers::Vector<flatbuffers::Offset<ss::ssfb::PartState>> *>(VT_STATES);
  }
  bool Verify(flatbuffers::Verifier &verifier) const {
    return VerifyTableStart(verifier) &&
           VerifyOffset(verifier, VT_STATES) &&
           verifier.VerifyVector(states()) &&
           verifier.VerifyVectorOfTables(states()) &&
           verifier.EndTable();
  }
  FrameDataIndexT *UnPack(const flatbuffers::resolver_function_t *_resolver = nullptr) const;
  void UnPackTo(FrameDataIndexT *_o, const flatbuffers::resolver_function_t *_resolver = nullptr) const;
  static flatbuffers::Offset<FrameDataIndex> Pack(flatbuffers::FlatBufferBuilder &_fbb, const FrameDataIndexT* _o, const flatbuffers::rehasher_function_t *_rehasher = nullptr);
};

struct FrameDataIndexBuilder {
  typedef FrameDataIndex Table;
  flatbuffers::FlatBufferBuilder &fbb_;
  flatbuffers::uoffset_t start_;
  void add_states(flatbuffers::Offset<flatbuffers::Vector<flatbuffers::Offset<ss::ssfb::PartState>>> states) {
    fbb_.AddOffset(FrameDataIndex::VT_STATES, states);
  }
  explicit FrameDataIndexBuilder(flatbuffers::FlatBufferBuilder &_fbb)
        : fbb_(_fbb) {
    start_ = fbb_.StartTable();
  }
  flatbuffers::Offset<FrameDataIndex> Finish() {
    const auto end = fbb_.EndTable(start_);
    auto o = flatbuffers::Offset<FrameDataIndex>(end);
    return o;
  }
};

inline flatbuffers::Offset<FrameDataIndex> CreateFrameDataIndex(
    flatbuffers::FlatBufferBuilder &_fbb,
    flatbuffers::Offset<flatbuffers::Vector<flatbuffers::Offset<ss::ssfb::PartState>>> states = 0) {
  FrameDataIndexBuilder builder_(_fbb);
  builder_.add_states(states);
  return builder_.Finish();
}

inline flatbuffers::Offset<FrameDataIndex> CreateFrameDataIndexDirect(
    flatbuffers::FlatBufferBuilder &_fbb,
    const std::vector<flatbuffers::Offset<ss::ssfb::PartState>> *states = nullptr) {
  auto states__ = states ? _fbb.CreateVector<flatbuffers::Offset<ss::ssfb::PartState>>(*states) : 0;
  return ss::ssfb::CreateFrameDataIndex(
      _fbb,
      states__);
}

flatbuffers::Offset<FrameDataIndex> CreateFrameDataIndex(flatbuffers::FlatBufferBuilder &_fbb, const FrameDataIndexT *_o, const flatbuffers::rehasher_function_t *_rehasher = nullptr);

struct UserDataItemT : public flatbuffers::NativeTable {
  typedef UserDataItem TableType;
  ss::ssfb::UserDataFlag flags = static_cast<ss::ssfb::UserDataFlag>(0);
  int16_t array_index = 0;
  int32_t integer = 0;
  int32_t rect_x = 0;
  int32_t rect_y = 0;
  int32_t rect_w = 0;
  int32_t rect_h = 0;
  int32_t point_x = 0;
  int32_t point_y = 0;
  int32_t user_string_length = 0;
  std::string user_string{};
};

struct UserDataItem FLATBUFFERS_FINAL_CLASS : private flatbuffers::Table {
  typedef UserDataItemT NativeTableType;
  typedef UserDataItemBuilder Builder;
  enum FlatBuffersVTableOffset FLATBUFFERS_VTABLE_UNDERLYING_TYPE {
    VT_FLAGS = 4,
    VT_ARRAY_INDEX = 6,
    VT_INTEGER = 8,
    VT_RECT_X = 10,
    VT_RECT_Y = 12,
    VT_RECT_W = 14,
    VT_RECT_H = 16,
    VT_POINT_X = 18,
    VT_POINT_Y = 20,
    VT_USER_STRING_LENGTH = 22,
    VT_USER_STRING = 24
  };
  ss::ssfb::UserDataFlag flags() const {
    return static_cast<ss::ssfb::UserDataFlag>(GetField<uint8_t>(VT_FLAGS, 0));
  }
  int16_t array_index() const {
    return GetField<int16_t>(VT_ARRAY_INDEX, 0);
  }
  int32_t integer() const {
    return GetField<int32_t>(VT_INTEGER, 0);
  }
  int32_t rect_x() const {
    return GetField<int32_t>(VT_RECT_X, 0);
  }
  int32_t rect_y() const {
    return GetField<int32_t>(VT_RECT_Y, 0);
  }
  int32_t rect_w() const {
    return GetField<int32_t>(VT_RECT_W, 0);
  }
  int32_t rect_h() const {
    return GetField<int32_t>(VT_RECT_H, 0);
  }
  int32_t point_x() const {
    return GetField<int32_t>(VT_POINT_X, 0);
  }
  int32_t point_y() const {
    return GetField<int32_t>(VT_POINT_Y, 0);
  }
  int32_t user_string_length() const {
    return GetField<int32_t>(VT_USER_STRING_LENGTH, 0);
  }
  const flatbuffers::String *user_string() const {
    return GetPointer<const flatbuffers::String *>(VT_USER_STRING);
  }
  bool Verify(flatbuffers::Verifier &verifier) const {
    return VerifyTableStart(verifier) &&
           VerifyField<uint8_t>(verifier, VT_FLAGS) &&
           VerifyField<int16_t>(verifier, VT_ARRAY_INDEX) &&
           VerifyField<int32_t>(verifier, VT_INTEGER) &&
           VerifyField<int32_t>(verifier, VT_RECT_X) &&
           VerifyField<int32_t>(verifier, VT_RECT_Y) &&
           VerifyField<int32_t>(verifier, VT_RECT_W) &&
           VerifyField<int32_t>(verifier, VT_RECT_H) &&
           VerifyField<int32_t>(verifier, VT_POINT_X) &&
           VerifyField<int32_t>(verifier, VT_POINT_Y) &&
           VerifyField<int32_t>(verifier, VT_USER_STRING_LENGTH) &&
           VerifyOffset(verifier, VT_USER_STRING) &&
           verifier.VerifyString(user_string()) &&
           verifier.EndTable();
  }
  UserDataItemT *UnPack(const flatbuffers::resolver_function_t *_resolver = nullptr) const;
  void UnPackTo(UserDataItemT *_o, const flatbuffers::resolver_function_t *_resolver = nullptr) const;
  static flatbuffers::Offset<UserDataItem> Pack(flatbuffers::FlatBufferBuilder &_fbb, const UserDataItemT* _o, const flatbuffers::rehasher_function_t *_rehasher = nullptr);
};

struct UserDataItemBuilder {
  typedef UserDataItem Table;
  flatbuffers::FlatBufferBuilder &fbb_;
  flatbuffers::uoffset_t start_;
  void add_flags(ss::ssfb::UserDataFlag flags) {
    fbb_.AddElement<uint8_t>(UserDataItem::VT_FLAGS, static_cast<uint8_t>(flags), 0);
  }
  void add_array_index(int16_t array_index) {
    fbb_.AddElement<int16_t>(UserDataItem::VT_ARRAY_INDEX, array_index, 0);
  }
  void add_integer(int32_t integer) {
    fbb_.AddElement<int32_t>(UserDataItem::VT_INTEGER, integer, 0);
  }
  void add_rect_x(int32_t rect_x) {
    fbb_.AddElement<int32_t>(UserDataItem::VT_RECT_X, rect_x, 0);
  }
  void add_rect_y(int32_t rect_y) {
    fbb_.AddElement<int32_t>(UserDataItem::VT_RECT_Y, rect_y, 0);
  }
  void add_rect_w(int32_t rect_w) {
    fbb_.AddElement<int32_t>(UserDataItem::VT_RECT_W, rect_w, 0);
  }
  void add_rect_h(int32_t rect_h) {
    fbb_.AddElement<int32_t>(UserDataItem::VT_RECT_H, rect_h, 0);
  }
  void add_point_x(int32_t point_x) {
    fbb_.AddElement<int32_t>(UserDataItem::VT_POINT_X, point_x, 0);
  }
  void add_point_y(int32_t point_y) {
    fbb_.AddElement<int32_t>(UserDataItem::VT_POINT_Y, point_y, 0);
  }
  void add_user_string_length(int32_t user_string_length) {
    fbb_.AddElement<int32_t>(UserDataItem::VT_USER_STRING_LENGTH, user_string_length, 0);
  }
  void add_user_string(flatbuffers::Offset<flatbuffers::String> user_string) {
    fbb_.AddOffset(UserDataItem::VT_USER_STRING, user_string);
  }
  explicit UserDataItemBuilder(flatbuffers::FlatBufferBuilder &_fbb)
        : fbb_(_fbb) {
    start_ = fbb_.StartTable();
  }
  flatbuffers::Offset<UserDataItem> Finish() {
    const auto end = fbb_.EndTable(start_);
    auto o = flatbuffers::Offset<UserDataItem>(end);
    return o;
  }
};

inline flatbuffers::Offset<UserDataItem> CreateUserDataItem(
    flatbuffers::FlatBufferBuilder &_fbb,
    ss::ssfb::UserDataFlag flags = static_cast<ss::ssfb::UserDataFlag>(0),
    int16_t array_index = 0,
    int32_t integer = 0,
    int32_t rect_x = 0,
    int32_t rect_y = 0,
    int32_t rect_w = 0,
    int32_t rect_h = 0,
    int32_t point_x = 0,
    int32_t point_y = 0,
    int32_t user_string_length = 0,
    flatbuffers::Offset<flatbuffers::String> user_string = 0) {
  UserDataItemBuilder builder_(_fbb);
  builder_.add_user_string(user_string);
  builder_.add_user_string_length(user_string_length);
  builder_.add_point_y(point_y);
  builder_.add_point_x(point_x);
  builder_.add_rect_h(rect_h);
  builder_.add_rect_w(rect_w);
  builder_.add_rect_y(rect_y);
  builder_.add_rect_x(rect_x);
  builder_.add_integer(integer);
  builder_.add_array_index(array_index);
  builder_.add_flags(flags);
  return builder_.Finish();
}

inline flatbuffers::Offset<UserDataItem> CreateUserDataItemDirect(
    flatbuffers::FlatBufferBuilder &_fbb,
    ss::ssfb::UserDataFlag flags = static_cast<ss::ssfb::UserDataFlag>(0),
    int16_t array_index = 0,
    int32_t integer = 0,
    int32_t rect_x = 0,
    int32_t rect_y = 0,
    int32_t rect_w = 0,
    int32_t rect_h = 0,
    int32_t point_x = 0,
    int32_t point_y = 0,
    int32_t user_string_length = 0,
    const char *user_string = nullptr) {
  auto user_string__ = user_string ? _fbb.CreateString(user_string) : 0;
  return ss::ssfb::CreateUserDataItem(
      _fbb,
      flags,
      array_index,
      integer,
      rect_x,
      rect_y,
      rect_w,
      rect_h,
      point_x,
      point_y,
      user_string_length,
      user_string__);
}

flatbuffers::Offset<UserDataItem> CreateUserDataItem(flatbuffers::FlatBufferBuilder &_fbb, const UserDataItemT *_o, const flatbuffers::rehasher_function_t *_rehasher = nullptr);

struct UserDataPerFrameT : public flatbuffers::NativeTable {
  typedef UserDataPerFrame TableType;
  int16_t frame_index = 0;
  std::vector<std::unique_ptr<ss::ssfb::UserDataItemT>> data{};
};

struct UserDataPerFrame FLATBUFFERS_FINAL_CLASS : private flatbuffers::Table {
  typedef UserDataPerFrameT NativeTableType;
  typedef UserDataPerFrameBuilder Builder;
  enum FlatBuffersVTableOffset FLATBUFFERS_VTABLE_UNDERLYING_TYPE {
    VT_FRAME_INDEX = 4,
    VT_DATA = 6
  };
  int16_t frame_index() const {
    return GetField<int16_t>(VT_FRAME_INDEX, 0);
  }
  const flatbuffers::Vector<flatbuffers::Offset<ss::ssfb::UserDataItem>> *data() const {
    return GetPointer<const flatbuffers::Vector<flatbuffers::Offset<ss::ssfb::UserDataItem>> *>(VT_DATA);
  }
  bool Verify(flatbuffers::Verifier &verifier) const {
    return VerifyTableStart(verifier) &&
           VerifyField<int16_t>(verifier, VT_FRAME_INDEX) &&
           VerifyOffset(verifier, VT_DATA) &&
           verifier.VerifyVector(data()) &&
           verifier.VerifyVectorOfTables(data()) &&
           verifier.EndTable();
  }
  UserDataPerFrameT *UnPack(const flatbuffers::resolver_function_t *_resolver = nullptr) const;
  void UnPackTo(UserDataPerFrameT *_o, const flatbuffers::resolver_function_t *_resolver = nullptr) const;
  static flatbuffers::Offset<UserDataPerFrame> Pack(flatbuffers::FlatBufferBuilder &_fbb, const UserDataPerFrameT* _o, const flatbuffers::rehasher_function_t *_rehasher = nullptr);
};

struct UserDataPerFrameBuilder {
  typedef UserDataPerFrame Table;
  flatbuffers::FlatBufferBuilder &fbb_;
  flatbuffers::uoffset_t start_;
  void add_frame_index(int16_t frame_index) {
    fbb_.AddElement<int16_t>(UserDataPerFrame::VT_FRAME_INDEX, frame_index, 0);
  }
  void add_data(flatbuffers::Offset<flatbuffers::Vector<flatbuffers::Offset<ss::ssfb::UserDataItem>>> data) {
    fbb_.AddOffset(UserDataPerFrame::VT_DATA, data);
  }
  explicit UserDataPerFrameBuilder(flatbuffers::FlatBufferBuilder &_fbb)
        : fbb_(_fbb) {
    start_ = fbb_.StartTable();
  }
  flatbuffers::Offset<UserDataPerFrame> Finish() {
    const auto end = fbb_.EndTable(start_);
    auto o = flatbuffers::Offset<UserDataPerFrame>(end);
    return o;
  }
};

inline flatbuffers::Offset<UserDataPerFrame> CreateUserDataPerFrame(
    flatbuffers::FlatBufferBuilder &_fbb,
    int16_t frame_index = 0,
    flatbuffers::Offset<flatbuffers::Vector<flatbuffers::Offset<ss::ssfb::UserDataItem>>> data = 0) {
  UserDataPerFrameBuilder builder_(_fbb);
  builder_.add_data(data);
  builder_.add_frame_index(frame_index);
  return builder_.Finish();
}

inline flatbuffers::Offset<UserDataPerFrame> CreateUserDataPerFrameDirect(
    flatbuffers::FlatBufferBuilder &_fbb,
    int16_t frame_index = 0,
    const std::vector<flatbuffers::Offset<ss::ssfb::UserDataItem>> *data = nullptr) {
  auto data__ = data ? _fbb.CreateVector<flatbuffers::Offset<ss::ssfb::UserDataItem>>(*data) : 0;
  return ss::ssfb::CreateUserDataPerFrame(
      _fbb,
      frame_index,
      data__);
}

flatbuffers::Offset<UserDataPerFrame> CreateUserDataPerFrame(flatbuffers::FlatBufferBuilder &_fbb, const UserDataPerFrameT *_o, const flatbuffers::rehasher_function_t *_rehasher = nullptr);

struct LabelDataItemT : public flatbuffers::NativeTable {
  typedef LabelDataItem TableType;
  std::string label{};
  int16_t frame_index = 0;
};

struct LabelDataItem FLATBUFFERS_FINAL_CLASS : private flatbuffers::Table {
  typedef LabelDataItemT NativeTableType;
  typedef LabelDataItemBuilder Builder;
  enum FlatBuffersVTableOffset FLATBUFFERS_VTABLE_UNDERLYING_TYPE {
    VT_LABEL = 4,
    VT_FRAME_INDEX = 6
  };
  const flatbuffers::String *label() const {
    return GetPointer<const flatbuffers::String *>(VT_LABEL);
  }
  int16_t frame_index() const {
    return GetField<int16_t>(VT_FRAME_INDEX, 0);
  }
  bool Verify(flatbuffers::Verifier &verifier) const {
    return VerifyTableStart(verifier) &&
           VerifyOffset(verifier, VT_LABEL) &&
           verifier.VerifyString(label()) &&
           VerifyField<int16_t>(verifier, VT_FRAME_INDEX) &&
           verifier.EndTable();
  }
  LabelDataItemT *UnPack(const flatbuffers::resolver_function_t *_resolver = nullptr) const;
  void UnPackTo(LabelDataItemT *_o, const flatbuffers::resolver_function_t *_resolver = nullptr) const;
  static flatbuffers::Offset<LabelDataItem> Pack(flatbuffers::FlatBufferBuilder &_fbb, const LabelDataItemT* _o, const flatbuffers::rehasher_function_t *_rehasher = nullptr);
};

struct LabelDataItemBuilder {
  typedef LabelDataItem Table;
  flatbuffers::FlatBufferBuilder &fbb_;
  flatbuffers::uoffset_t start_;
  void add_label(flatbuffers::Offset<flatbuffers::String> label) {
    fbb_.AddOffset(LabelDataItem::VT_LABEL, label);
  }
  void add_frame_index(int16_t frame_index) {
    fbb_.AddElement<int16_t>(LabelDataItem::VT_FRAME_INDEX, frame_index, 0);
  }
  explicit LabelDataItemBuilder(flatbuffers::FlatBufferBuilder &_fbb)
        : fbb_(_fbb) {
    start_ = fbb_.StartTable();
  }
  flatbuffers::Offset<LabelDataItem> Finish() {
    const auto end = fbb_.EndTable(start_);
    auto o = flatbuffers::Offset<LabelDataItem>(end);
    return o;
  }
};

inline flatbuffers::Offset<LabelDataItem> CreateLabelDataItem(
    flatbuffers::FlatBufferBuilder &_fbb,
    flatbuffers::Offset<flatbuffers::String> label = 0,
    int16_t frame_index = 0) {
  LabelDataItemBuilder builder_(_fbb);
  builder_.add_label(label);
  builder_.add_frame_index(frame_index);
  return builder_.Finish();
}

inline flatbuffers::Offset<LabelDataItem> CreateLabelDataItemDirect(
    flatbuffers::FlatBufferBuilder &_fbb,
    const char *label = nullptr,
    int16_t frame_index = 0) {
  auto label__ = label ? _fbb.CreateString(label) : 0;
  return ss::ssfb::CreateLabelDataItem(
      _fbb,
      label__,
      frame_index);
}

flatbuffers::Offset<LabelDataItem> CreateLabelDataItem(flatbuffers::FlatBufferBuilder &_fbb, const LabelDataItemT *_o, const flatbuffers::rehasher_function_t *_rehasher = nullptr);

struct AnimationDataT : public flatbuffers::NativeTable {
  typedef AnimationData TableType;
  std::string name{};
  std::vector<std::unique_ptr<ss::ssfb::AnimationInitialDataT>> default_data{};
  std::vector<std::unique_ptr<ss::ssfb::FrameDataIndexT>> frame_data{};
  std::vector<std::unique_ptr<ss::ssfb::UserDataPerFrameT>> user_data{};
  std::vector<std::unique_ptr<ss::ssfb::LabelDataItemT>> label_data{};
  std::vector<std::unique_ptr<ss::ssfb::MeshDataUVT>> meshs_data_UV{};
  std::vector<std::unique_ptr<ss::ssfb::MeshDataIndicesT>> meshs_data_indices{};
  int16_t start_frames = 0;
  int16_t end_frames = 0;
  int16_t total_frames = 0;
  int16_t fps = 0;
  int16_t labelNum = 0;
  int16_t canvas_size_w = 0;
  int16_t canvas_size_h = 0;
  float canvas_pvot_x = 0.0f;
  float canvas_pvot_y = 0.0f;
};

struct AnimationData FLATBUFFERS_FINAL_CLASS : private flatbuffers::Table {
  typedef AnimationDataT NativeTableType;
  typedef AnimationDataBuilder Builder;
  enum FlatBuffersVTableOffset FLATBUFFERS_VTABLE_UNDERLYING_TYPE {
    VT_NAME = 4,
    VT_DEFAULT_DATA = 6,
    VT_FRAME_DATA = 8,
    VT_USER_DATA = 10,
    VT_LABEL_DATA = 12,
    VT_MESHS_DATA_UV = 14,
    VT_MESHS_DATA_INDICES = 16,
    VT_START_FRAMES = 18,
    VT_END_FRAMES = 20,
    VT_TOTAL_FRAMES = 22,
    VT_FPS = 24,
    VT_LABELNUM = 26,
    VT_CANVAS_SIZE_W = 28,
    VT_CANVAS_SIZE_H = 30,
    VT_CANVAS_PVOT_X = 32,
    VT_CANVAS_PVOT_Y = 34
  };
  const flatbuffers::String *name() const {
    return GetPointer<const flatbuffers::String *>(VT_NAME);
  }
  const flatbuffers::Vector<flatbuffers::Offset<ss::ssfb::AnimationInitialData>> *default_data() const {
    return GetPointer<const flatbuffers::Vector<flatbuffers::Offset<ss::ssfb::AnimationInitialData>> *>(VT_DEFAULT_DATA);
  }
  const flatbuffers::Vector<flatbuffers::Offset<ss::ssfb::FrameDataIndex>> *frame_data() const {
    return GetPointer<const flatbuffers::Vector<flatbuffers::Offset<ss::ssfb::FrameDataIndex>> *>(VT_FRAME_DATA);
  }
  const flatbuffers::Vector<flatbuffers::Offset<ss::ssfb::UserDataPerFrame>> *user_data() const {
    return GetPointer<const flatbuffers::Vector<flatbuffers::Offset<ss::ssfb::UserDataPerFrame>> *>(VT_USER_DATA);
  }
  const flatbuffers::Vector<flatbuffers::Offset<ss::ssfb::LabelDataItem>> *label_data() const {
    return GetPointer<const flatbuffers::Vector<flatbuffers::Offset<ss::ssfb::LabelDataItem>> *>(VT_LABEL_DATA);
  }
  const flatbuffers::Vector<flatbuffers::Offset<ss::ssfb::MeshDataUV>> *meshs_data_UV() const {
    return GetPointer<const flatbuffers::Vector<flatbuffers::Offset<ss::ssfb::MeshDataUV>> *>(VT_MESHS_DATA_UV);
  }
  const flatbuffers::Vector<flatbuffers::Offset<ss::ssfb::MeshDataIndices>> *meshs_data_indices() const {
    return GetPointer<const flatbuffers::Vector<flatbuffers::Offset<ss::ssfb::MeshDataIndices>> *>(VT_MESHS_DATA_INDICES);
  }
  int16_t start_frames() const {
    return GetField<int16_t>(VT_START_FRAMES, 0);
  }
  int16_t end_frames() const {
    return GetField<int16_t>(VT_END_FRAMES, 0);
  }
  int16_t total_frames() const {
    return GetField<int16_t>(VT_TOTAL_FRAMES, 0);
  }
  int16_t fps() const {
    return GetField<int16_t>(VT_FPS, 0);
  }
  int16_t labelNum() const {
    return GetField<int16_t>(VT_LABELNUM, 0);
  }
  int16_t canvas_size_w() const {
    return GetField<int16_t>(VT_CANVAS_SIZE_W, 0);
  }
  int16_t canvas_size_h() const {
    return GetField<int16_t>(VT_CANVAS_SIZE_H, 0);
  }
  float canvas_pvot_x() const {
    return GetField<float>(VT_CANVAS_PVOT_X, 0.0f);
  }
  float canvas_pvot_y() const {
    return GetField<float>(VT_CANVAS_PVOT_Y, 0.0f);
  }
  bool Verify(flatbuffers::Verifier &verifier) const {
    return VerifyTableStart(verifier) &&
           VerifyOffset(verifier, VT_NAME) &&
           verifier.VerifyString(name()) &&
           VerifyOffset(verifier, VT_DEFAULT_DATA) &&
           verifier.VerifyVector(default_data()) &&
           verifier.VerifyVectorOfTables(default_data()) &&
           VerifyOffset(verifier, VT_FRAME_DATA) &&
           verifier.VerifyVector(frame_data()) &&
           verifier.VerifyVectorOfTables(frame_data()) &&
           VerifyOffset(verifier, VT_USER_DATA) &&
           verifier.VerifyVector(user_data()) &&
           verifier.VerifyVectorOfTables(user_data()) &&
           VerifyOffset(verifier, VT_LABEL_DATA) &&
           verifier.VerifyVector(label_data()) &&
           verifier.VerifyVectorOfTables(label_data()) &&
           VerifyOffset(verifier, VT_MESHS_DATA_UV) &&
           verifier.VerifyVector(meshs_data_UV()) &&
           verifier.VerifyVectorOfTables(meshs_data_UV()) &&
           VerifyOffset(verifier, VT_MESHS_DATA_INDICES) &&
           verifier.VerifyVector(meshs_data_indices()) &&
           verifier.VerifyVectorOfTables(meshs_data_indices()) &&
           VerifyField<int16_t>(verifier, VT_START_FRAMES) &&
           VerifyField<int16_t>(verifier, VT_END_FRAMES) &&
           VerifyField<int16_t>(verifier, VT_TOTAL_FRAMES) &&
           VerifyField<int16_t>(verifier, VT_FPS) &&
           VerifyField<int16_t>(verifier, VT_LABELNUM) &&
           VerifyField<int16_t>(verifier, VT_CANVAS_SIZE_W) &&
           VerifyField<int16_t>(verifier, VT_CANVAS_SIZE_H) &&
           VerifyField<float>(verifier, VT_CANVAS_PVOT_X) &&
           VerifyField<float>(verifier, VT_CANVAS_PVOT_Y) &&
           verifier.EndTable();
  }
  AnimationDataT *UnPack(const flatbuffers::resolver_function_t *_resolver = nullptr) const;
  void UnPackTo(AnimationDataT *_o, const flatbuffers::resolver_function_t *_resolver = nullptr) const;
  static flatbuffers::Offset<AnimationData> Pack(flatbuffers::FlatBufferBuilder &_fbb, const AnimationDataT* _o, const flatbuffers::rehasher_function_t *_rehasher = nullptr);
};

struct AnimationDataBuilder {
  typedef AnimationData Table;
  flatbuffers::FlatBufferBuilder &fbb_;
  flatbuffers::uoffset_t start_;
  void add_name(flatbuffers::Offset<flatbuffers::String> name) {
    fbb_.AddOffset(AnimationData::VT_NAME, name);
  }
  void add_default_data(flatbuffers::Offset<flatbuffers::Vector<flatbuffers::Offset<ss::ssfb::AnimationInitialData>>> default_data) {
    fbb_.AddOffset(AnimationData::VT_DEFAULT_DATA, default_data);
  }
  void add_frame_data(flatbuffers::Offset<flatbuffers::Vector<flatbuffers::Offset<ss::ssfb::FrameDataIndex>>> frame_data) {
    fbb_.AddOffset(AnimationData::VT_FRAME_DATA, frame_data);
  }
  void add_user_data(flatbuffers::Offset<flatbuffers::Vector<flatbuffers::Offset<ss::ssfb::UserDataPerFrame>>> user_data) {
    fbb_.AddOffset(AnimationData::VT_USER_DATA, user_data);
  }
  void add_label_data(flatbuffers::Offset<flatbuffers::Vector<flatbuffers::Offset<ss::ssfb::LabelDataItem>>> label_data) {
    fbb_.AddOffset(AnimationData::VT_LABEL_DATA, label_data);
  }
  void add_meshs_data_UV(flatbuffers::Offset<flatbuffers::Vector<flatbuffers::Offset<ss::ssfb::MeshDataUV>>> meshs_data_UV) {
    fbb_.AddOffset(AnimationData::VT_MESHS_DATA_UV, meshs_data_UV);
  }
  void add_meshs_data_indices(flatbuffers::Offset<flatbuffers::Vector<flatbuffers::Offset<ss::ssfb::MeshDataIndices>>> meshs_data_indices) {
    fbb_.AddOffset(AnimationData::VT_MESHS_DATA_INDICES, meshs_data_indices);
  }
  void add_start_frames(int16_t start_frames) {
    fbb_.AddElement<int16_t>(AnimationData::VT_START_FRAMES, start_frames, 0);
  }
  void add_end_frames(int16_t end_frames) {
    fbb_.AddElement<int16_t>(AnimationData::VT_END_FRAMES, end_frames, 0);
  }
  void add_total_frames(int16_t total_frames) {
    fbb_.AddElement<int16_t>(AnimationData::VT_TOTAL_FRAMES, total_frames, 0);
  }
  void add_fps(int16_t fps) {
    fbb_.AddElement<int16_t>(AnimationData::VT_FPS, fps, 0);
  }
  void add_labelNum(int16_t labelNum) {
    fbb_.AddElement<int16_t>(AnimationData::VT_LABELNUM, labelNum, 0);
  }
  void add_canvas_size_w(int16_t canvas_size_w) {
    fbb_.AddElement<int16_t>(AnimationData::VT_CANVAS_SIZE_W, canvas_size_w, 0);
  }
  void add_canvas_size_h(int16_t canvas_size_h) {
    fbb_.AddElement<int16_t>(AnimationData::VT_CANVAS_SIZE_H, canvas_size_h, 0);
  }
  void add_canvas_pvot_x(float canvas_pvot_x) {
    fbb_.AddElement<float>(AnimationData::VT_CANVAS_PVOT_X, canvas_pvot_x, 0.0f);
  }
  void add_canvas_pvot_y(float canvas_pvot_y) {
    fbb_.AddElement<float>(AnimationData::VT_CANVAS_PVOT_Y, canvas_pvot_y, 0.0f);
  }
  explicit AnimationDataBuilder(flatbuffers::FlatBufferBuilder &_fbb)
        : fbb_(_fbb) {
    start_ = fbb_.StartTable();
  }
  flatbuffers::Offset<AnimationData> Finish() {
    const auto end = fbb_.EndTable(start_);
    auto o = flatbuffers::Offset<AnimationData>(end);
    return o;
  }
};

inline flatbuffers::Offset<AnimationData> CreateAnimationData(
    flatbuffers::FlatBufferBuilder &_fbb,
    flatbuffers::Offset<flatbuffers::String> name = 0,
    flatbuffers::Offset<flatbuffers::Vector<flatbuffers::Offset<ss::ssfb::AnimationInitialData>>> default_data = 0,
    flatbuffers::Offset<flatbuffers::Vector<flatbuffers::Offset<ss::ssfb::FrameDataIndex>>> frame_data = 0,
    flatbuffers::Offset<flatbuffers::Vector<flatbuffers::Offset<ss::ssfb::UserDataPerFrame>>> user_data = 0,
    flatbuffers::Offset<flatbuffers::Vector<flatbuffers::Offset<ss::ssfb::LabelDataItem>>> label_data = 0,
    flatbuffers::Offset<flatbuffers::Vector<flatbuffers::Offset<ss::ssfb::MeshDataUV>>> meshs_data_UV = 0,
    flatbuffers::Offset<flatbuffers::Vector<flatbuffers::Offset<ss::ssfb::MeshDataIndices>>> meshs_data_indices = 0,
    int16_t start_frames = 0,
    int16_t end_frames = 0,
    int16_t total_frames = 0,
    int16_t fps = 0,
    int16_t labelNum = 0,
    int16_t canvas_size_w = 0,
    int16_t canvas_size_h = 0,
    float canvas_pvot_x = 0.0f,
    float canvas_pvot_y = 0.0f) {
  AnimationDataBuilder builder_(_fbb);
  builder_.add_canvas_pvot_y(canvas_pvot_y);
  builder_.add_canvas_pvot_x(canvas_pvot_x);
  builder_.add_meshs_data_indices(meshs_data_indices);
  builder_.add_meshs_data_UV(meshs_data_UV);
  builder_.add_label_data(label_data);
  builder_.add_user_data(user_data);
  builder_.add_frame_data(frame_data);
  builder_.add_default_data(default_data);
  builder_.add_name(name);
  builder_.add_canvas_size_h(canvas_size_h);
  builder_.add_canvas_size_w(canvas_size_w);
  builder_.add_labelNum(labelNum);
  builder_.add_fps(fps);
  builder_.add_total_frames(total_frames);
  builder_.add_end_frames(end_frames);
  builder_.add_start_frames(start_frames);
  return builder_.Finish();
}

inline flatbuffers::Offset<AnimationData> CreateAnimationDataDirect(
    flatbuffers::FlatBufferBuilder &_fbb,
    const char *name = nullptr,
    const std::vector<flatbuffers::Offset<ss::ssfb::AnimationInitialData>> *default_data = nullptr,
    const std::vector<flatbuffers::Offset<ss::ssfb::FrameDataIndex>> *frame_data = nullptr,
    const std::vector<flatbuffers::Offset<ss::ssfb::UserDataPerFrame>> *user_data = nullptr,
    const std::vector<flatbuffers::Offset<ss::ssfb::LabelDataItem>> *label_data = nullptr,
    const std::vector<flatbuffers::Offset<ss::ssfb::MeshDataUV>> *meshs_data_UV = nullptr,
    const std::vector<flatbuffers::Offset<ss::ssfb::MeshDataIndices>> *meshs_data_indices = nullptr,
    int16_t start_frames = 0,
    int16_t end_frames = 0,
    int16_t total_frames = 0,
    int16_t fps = 0,
    int16_t labelNum = 0,
    int16_t canvas_size_w = 0,
    int16_t canvas_size_h = 0,
    float canvas_pvot_x = 0.0f,
    float canvas_pvot_y = 0.0f) {
  auto name__ = name ? _fbb.CreateString(name) : 0;
  auto default_data__ = default_data ? _fbb.CreateVector<flatbuffers::Offset<ss::ssfb::AnimationInitialData>>(*default_data) : 0;
  auto frame_data__ = frame_data ? _fbb.CreateVector<flatbuffers::Offset<ss::ssfb::FrameDataIndex>>(*frame_data) : 0;
  auto user_data__ = user_data ? _fbb.CreateVector<flatbuffers::Offset<ss::ssfb::UserDataPerFrame>>(*user_data) : 0;
  auto label_data__ = label_data ? _fbb.CreateVector<flatbuffers::Offset<ss::ssfb::LabelDataItem>>(*label_data) : 0;
  auto meshs_data_UV__ = meshs_data_UV ? _fbb.CreateVector<flatbuffers::Offset<ss::ssfb::MeshDataUV>>(*meshs_data_UV) : 0;
  auto meshs_data_indices__ = meshs_data_indices ? _fbb.CreateVector<flatbuffers::Offset<ss::ssfb::MeshDataIndices>>(*meshs_data_indices) : 0;
  return ss::ssfb::CreateAnimationData(
      _fbb,
      name__,
      default_data__,
      frame_data__,
      user_data__,
      label_data__,
      meshs_data_UV__,
      meshs_data_indices__,
      start_frames,
      end_frames,
      total_frames,
      fps,
      labelNum,
      canvas_size_w,
      canvas_size_h,
      canvas_pvot_x,
      canvas_pvot_y);
}

flatbuffers::Offset<AnimationData> CreateAnimationData(flatbuffers::FlatBufferBuilder &_fbb, const AnimationDataT *_o, const flatbuffers::rehasher_function_t *_rehasher = nullptr);

struct AnimationInitialDataT : public flatbuffers::NativeTable {
  typedef AnimationInitialData TableType;
  int16_t index = 0;
  int32_t lowflag = 0;
  int32_t highflag = 0;
  int16_t priority = 0;
  int16_t cell_index = 0;
  int16_t opacity = 0;
  int16_t local_opacity = 0;
  int16_t masklimen = 0;
  float position_x = 0.0f;
  float position_y = 0.0f;
  float position_z = 0.0f;
  float pivot_x = 0.0f;
  float pivot_y = 0.0f;
  float rotation_x = 0.0f;
  float rotation_y = 0.0f;
  float rotation_z = 0.0f;
  float scale_x = 0.0f;
  float scale_y = 0.0f;
  float local_scale_x = 0.0f;
  float local_scale_y = 0.0f;
  float size_x = 0.0f;
  float size_y = 0.0f;
  float uv_move_x = 0.0f;
  float uv_move_y = 0.0f;
  float uv_rotation = 0.0f;
  float uv_scale_x = 0.0f;
  float uv_scale_y = 0.0f;
  float bounding_radius = 0.0f;
  int32_t instance_value_cur_keyframe = 0;
  int32_t instance_value_start_frame = 0;
  int32_t instance_value_end_frame = 0;
  int32_t instance_value_loop_num = 0;
  float instance_value_speed = 0.0f;
  int32_t instance_value_loop_flag = 0;
  int32_t effect_value_cur_keyframe = 0;
  int32_t effect_value_start_time = 0;
  float effect_value_speed = 0.0f;
  int32_t effect_value_loop_flag = 0;
};

struct AnimationInitialData FLATBUFFERS_FINAL_CLASS : private flatbuffers::Table {
  typedef AnimationInitialDataT NativeTableType;
  typedef AnimationInitialDataBuilder Builder;
  enum FlatBuffersVTableOffset FLATBUFFERS_VTABLE_UNDERLYING_TYPE {
    VT_INDEX = 4,
    VT_LOWFLAG = 6,
    VT_HIGHFLAG = 8,
    VT_PRIORITY = 10,
    VT_CELL_INDEX = 12,
    VT_OPACITY = 14,
    VT_LOCAL_OPACITY = 16,
    VT_MASKLIMEN = 18,
    VT_POSITION_X = 20,
    VT_POSITION_Y = 22,
    VT_POSITION_Z = 24,
    VT_PIVOT_X = 26,
    VT_PIVOT_Y = 28,
    VT_ROTATION_X = 30,
    VT_ROTATION_Y = 32,
    VT_ROTATION_Z = 34,
    VT_SCALE_X = 36,
    VT_SCALE_Y = 38,
    VT_LOCAL_SCALE_X = 40,
    VT_LOCAL_SCALE_Y = 42,
    VT_SIZE_X = 44,
    VT_SIZE_Y = 46,
    VT_UV_MOVE_X = 48,
    VT_UV_MOVE_Y = 50,
    VT_UV_ROTATION = 52,
    VT_UV_SCALE_X = 54,
    VT_UV_SCALE_Y = 56,
    VT_BOUNDING_RADIUS = 58,
    VT_INSTANCE_VALUE_CUR_KEYFRAME = 60,
    VT_INSTANCE_VALUE_START_FRAME = 62,
    VT_INSTANCE_VALUE_END_FRAME = 64,
    VT_INSTANCE_VALUE_LOOP_NUM = 66,
    VT_INSTANCE_VALUE_SPEED = 68,
    VT_INSTANCE_VALUE_LOOP_FLAG = 70,
    VT_EFFECT_VALUE_CUR_KEYFRAME = 72,
    VT_EFFECT_VALUE_START_TIME = 74,
    VT_EFFECT_VALUE_SPEED = 76,
    VT_EFFECT_VALUE_LOOP_FLAG = 78
  };
  int16_t index() const {
    return GetField<int16_t>(VT_INDEX, 0);
  }
  int32_t lowflag() const {
    return GetField<int32_t>(VT_LOWFLAG, 0);
  }
  int32_t highflag() const {
    return GetField<int32_t>(VT_HIGHFLAG, 0);
  }
  int16_t priority() const {
    return GetField<int16_t>(VT_PRIORITY, 0);
  }
  int16_t cell_index() const {
    return GetField<int16_t>(VT_CELL_INDEX, 0);
  }
  int16_t opacity() const {
    return GetField<int16_t>(VT_OPACITY, 0);
  }
  int16_t local_opacity() const {
    return GetField<int16_t>(VT_LOCAL_OPACITY, 0);
  }
  int16_t masklimen() const {
    return GetField<int16_t>(VT_MASKLIMEN, 0);
  }
  float position_x() const {
    return GetField<float>(VT_POSITION_X, 0.0f);
  }
  float position_y() const {
    return GetField<float>(VT_POSITION_Y, 0.0f);
  }
  float position_z() const {
    return GetField<float>(VT_POSITION_Z, 0.0f);
  }
  float pivot_x() const {
    return GetField<float>(VT_PIVOT_X, 0.0f);
  }
  float pivot_y() const {
    return GetField<float>(VT_PIVOT_Y, 0.0f);
  }
  float rotation_x() const {
    return GetField<float>(VT_ROTATION_X, 0.0f);
  }
  float rotation_y() const {
    return GetField<float>(VT_ROTATION_Y, 0.0f);
  }
  float rotation_z() const {
    return GetField<float>(VT_ROTATION_Z, 0.0f);
  }
  float scale_x() const {
    return GetField<float>(VT_SCALE_X, 0.0f);
  }
  float scale_y() const {
    return GetField<float>(VT_SCALE_Y, 0.0f);
  }
  float local_scale_x() const {
    return GetField<float>(VT_LOCAL_SCALE_X, 0.0f);
  }
  float local_scale_y() const {
    return GetField<float>(VT_LOCAL_SCALE_Y, 0.0f);
  }
  float size_x() const {
    return GetField<float>(VT_SIZE_X, 0.0f);
  }
  float size_y() const {
    return GetField<float>(VT_SIZE_Y, 0.0f);
  }
  float uv_move_x() const {
    return GetField<float>(VT_UV_MOVE_X, 0.0f);
  }
  float uv_move_y() const {
    return GetField<float>(VT_UV_MOVE_Y, 0.0f);
  }
  float uv_rotation() const {
    return GetField<float>(VT_UV_ROTATION, 0.0f);
  }
  float uv_scale_x() const {
    return GetField<float>(VT_UV_SCALE_X, 0.0f);
  }
  float uv_scale_y() const {
    return GetField<float>(VT_UV_SCALE_Y, 0.0f);
  }
  float bounding_radius() const {
    return GetField<float>(VT_BOUNDING_RADIUS, 0.0f);
  }
  int32_t instance_value_cur_keyframe() const {
    return GetField<int32_t>(VT_INSTANCE_VALUE_CUR_KEYFRAME, 0);
  }
  int32_t instance_value_start_frame() const {
    return GetField<int32_t>(VT_INSTANCE_VALUE_START_FRAME, 0);
  }
  int32_t instance_value_end_frame() const {
    return GetField<int32_t>(VT_INSTANCE_VALUE_END_FRAME, 0);
  }
  int32_t instance_value_loop_num() const {
    return GetField<int32_t>(VT_INSTANCE_VALUE_LOOP_NUM, 0);
  }
  float instance_value_speed() const {
    return GetField<float>(VT_INSTANCE_VALUE_SPEED, 0.0f);
  }
  int32_t instance_value_loop_flag() const {
    return GetField<int32_t>(VT_INSTANCE_VALUE_LOOP_FLAG, 0);
  }
  int32_t effect_value_cur_keyframe() const {
    return GetField<int32_t>(VT_EFFECT_VALUE_CUR_KEYFRAME, 0);
  }
  int32_t effect_value_start_time() const {
    return GetField<int32_t>(VT_EFFECT_VALUE_START_TIME, 0);
  }
  float effect_value_speed() const {
    return GetField<float>(VT_EFFECT_VALUE_SPEED, 0.0f);
  }
  int32_t effect_value_loop_flag() const {
    return GetField<int32_t>(VT_EFFECT_VALUE_LOOP_FLAG, 0);
  }
  bool Verify(flatbuffers::Verifier &verifier) const {
    return VerifyTableStart(verifier) &&
           VerifyField<int16_t>(verifier, VT_INDEX) &&
           VerifyField<int32_t>(verifier, VT_LOWFLAG) &&
           VerifyField<int32_t>(verifier, VT_HIGHFLAG) &&
           VerifyField<int16_t>(verifier, VT_PRIORITY) &&
           VerifyField<int16_t>(verifier, VT_CELL_INDEX) &&
           VerifyField<int16_t>(verifier, VT_OPACITY) &&
           VerifyField<int16_t>(verifier, VT_LOCAL_OPACITY) &&
           VerifyField<int16_t>(verifier, VT_MASKLIMEN) &&
           VerifyField<float>(verifier, VT_POSITION_X) &&
           VerifyField<float>(verifier, VT_POSITION_Y) &&
           VerifyField<float>(verifier, VT_POSITION_Z) &&
           VerifyField<float>(verifier, VT_PIVOT_X) &&
           VerifyField<float>(verifier, VT_PIVOT_Y) &&
           VerifyField<float>(verifier, VT_ROTATION_X) &&
           VerifyField<float>(verifier, VT_ROTATION_Y) &&
           VerifyField<float>(verifier, VT_ROTATION_Z) &&
           VerifyField<float>(verifier, VT_SCALE_X) &&
           VerifyField<float>(verifier, VT_SCALE_Y) &&
           VerifyField<float>(verifier, VT_LOCAL_SCALE_X) &&
           VerifyField<float>(verifier, VT_LOCAL_SCALE_Y) &&
           VerifyField<float>(verifier, VT_SIZE_X) &&
           VerifyField<float>(verifier, VT_SIZE_Y) &&
           VerifyField<float>(verifier, VT_UV_MOVE_X) &&
           VerifyField<float>(verifier, VT_UV_MOVE_Y) &&
           VerifyField<float>(verifier, VT_UV_ROTATION) &&
           VerifyField<float>(verifier, VT_UV_SCALE_X) &&
           VerifyField<float>(verifier, VT_UV_SCALE_Y) &&
           VerifyField<float>(verifier, VT_BOUNDING_RADIUS) &&
           VerifyField<int32_t>(verifier, VT_INSTANCE_VALUE_CUR_KEYFRAME) &&
           VerifyField<int32_t>(verifier, VT_INSTANCE_VALUE_START_FRAME) &&
           VerifyField<int32_t>(verifier, VT_INSTANCE_VALUE_END_FRAME) &&
           VerifyField<int32_t>(verifier, VT_INSTANCE_VALUE_LOOP_NUM) &&
           VerifyField<float>(verifier, VT_INSTANCE_VALUE_SPEED) &&
           VerifyField<int32_t>(verifier, VT_INSTANCE_VALUE_LOOP_FLAG) &&
           VerifyField<int32_t>(verifier, VT_EFFECT_VALUE_CUR_KEYFRAME) &&
           VerifyField<int32_t>(verifier, VT_EFFECT_VALUE_START_TIME) &&
           VerifyField<float>(verifier, VT_EFFECT_VALUE_SPEED) &&
           VerifyField<int32_t>(verifier, VT_EFFECT_VALUE_LOOP_FLAG) &&
           verifier.EndTable();
  }
  AnimationInitialDataT *UnPack(const flatbuffers::resolver_function_t *_resolver = nullptr) const;
  void UnPackTo(AnimationInitialDataT *_o, const flatbuffers::resolver_function_t *_resolver = nullptr) const;
  static flatbuffers::Offset<AnimationInitialData> Pack(flatbuffers::FlatBufferBuilder &_fbb, const AnimationInitialDataT* _o, const flatbuffers::rehasher_function_t *_rehasher = nullptr);
};

struct AnimationInitialDataBuilder {
  typedef AnimationInitialData Table;
  flatbuffers::FlatBufferBuilder &fbb_;
  flatbuffers::uoffset_t start_;
  void add_index(int16_t index) {
    fbb_.AddElement<int16_t>(AnimationInitialData::VT_INDEX, index, 0);
  }
  void add_lowflag(int32_t lowflag) {
    fbb_.AddElement<int32_t>(AnimationInitialData::VT_LOWFLAG, lowflag, 0);
  }
  void add_highflag(int32_t highflag) {
    fbb_.AddElement<int32_t>(AnimationInitialData::VT_HIGHFLAG, highflag, 0);
  }
  void add_priority(int16_t priority) {
    fbb_.AddElement<int16_t>(AnimationInitialData::VT_PRIORITY, priority, 0);
  }
  void add_cell_index(int16_t cell_index) {
    fbb_.AddElement<int16_t>(AnimationInitialData::VT_CELL_INDEX, cell_index, 0);
  }
  void add_opacity(int16_t opacity) {
    fbb_.AddElement<int16_t>(AnimationInitialData::VT_OPACITY, opacity, 0);
  }
  void add_local_opacity(int16_t local_opacity) {
    fbb_.AddElement<int16_t>(AnimationInitialData::VT_LOCAL_OPACITY, local_opacity, 0);
  }
  void add_masklimen(int16_t masklimen) {
    fbb_.AddElement<int16_t>(AnimationInitialData::VT_MASKLIMEN, masklimen, 0);
  }
  void add_position_x(float position_x) {
    fbb_.AddElement<float>(AnimationInitialData::VT_POSITION_X, position_x, 0.0f);
  }
  void add_position_y(float position_y) {
    fbb_.AddElement<float>(AnimationInitialData::VT_POSITION_Y, position_y, 0.0f);
  }
  void add_position_z(float position_z) {
    fbb_.AddElement<float>(AnimationInitialData::VT_POSITION_Z, position_z, 0.0f);
  }
  void add_pivot_x(float pivot_x) {
    fbb_.AddElement<float>(AnimationInitialData::VT_PIVOT_X, pivot_x, 0.0f);
  }
  void add_pivot_y(float pivot_y) {
    fbb_.AddElement<float>(AnimationInitialData::VT_PIVOT_Y, pivot_y, 0.0f);
  }
  void add_rotation_x(float rotation_x) {
    fbb_.AddElement<float>(AnimationInitialData::VT_ROTATION_X, rotation_x, 0.0f);
  }
  void add_rotation_y(float rotation_y) {
    fbb_.AddElement<float>(AnimationInitialData::VT_ROTATION_Y, rotation_y, 0.0f);
  }
  void add_rotation_z(float rotation_z) {
    fbb_.AddElement<float>(AnimationInitialData::VT_ROTATION_Z, rotation_z, 0.0f);
  }
  void add_scale_x(float scale_x) {
    fbb_.AddElement<float>(AnimationInitialData::VT_SCALE_X, scale_x, 0.0f);
  }
  void add_scale_y(float scale_y) {
    fbb_.AddElement<float>(AnimationInitialData::VT_SCALE_Y, scale_y, 0.0f);
  }
  void add_local_scale_x(float local_scale_x) {
    fbb_.AddElement<float>(AnimationInitialData::VT_LOCAL_SCALE_X, local_scale_x, 0.0f);
  }
  void add_local_scale_y(float local_scale_y) {
    fbb_.AddElement<float>(AnimationInitialData::VT_LOCAL_SCALE_Y, local_scale_y, 0.0f);
  }
  void add_size_x(float size_x) {
    fbb_.AddElement<float>(AnimationInitialData::VT_SIZE_X, size_x, 0.0f);
  }
  void add_size_y(float size_y) {
    fbb_.AddElement<float>(AnimationInitialData::VT_SIZE_Y, size_y, 0.0f);
  }
  void add_uv_move_x(float uv_move_x) {
    fbb_.AddElement<float>(AnimationInitialData::VT_UV_MOVE_X, uv_move_x, 0.0f);
  }
  void add_uv_move_y(float uv_move_y) {
    fbb_.AddElement<float>(AnimationInitialData::VT_UV_MOVE_Y, uv_move_y, 0.0f);
  }
  void add_uv_rotation(float uv_rotation) {
    fbb_.AddElement<float>(AnimationInitialData::VT_UV_ROTATION, uv_rotation, 0.0f);
  }
  void add_uv_scale_x(float uv_scale_x) {
    fbb_.AddElement<float>(AnimationInitialData::VT_UV_SCALE_X, uv_scale_x, 0.0f);
  }
  void add_uv_scale_y(float uv_scale_y) {
    fbb_.AddElement<float>(AnimationInitialData::VT_UV_SCALE_Y, uv_scale_y, 0.0f);
  }
  void add_bounding_radius(float bounding_radius) {
    fbb_.AddElement<float>(AnimationInitialData::VT_BOUNDING_RADIUS, bounding_radius, 0.0f);
  }
  void add_instance_value_cur_keyframe(int32_t instance_value_cur_keyframe) {
    fbb_.AddElement<int32_t>(AnimationInitialData::VT_INSTANCE_VALUE_CUR_KEYFRAME, instance_value_cur_keyframe, 0);
  }
  void add_instance_value_start_frame(int32_t instance_value_start_frame) {
    fbb_.AddElement<int32_t>(AnimationInitialData::VT_INSTANCE_VALUE_START_FRAME, instance_value_start_frame, 0);
  }
  void add_instance_value_end_frame(int32_t instance_value_end_frame) {
    fbb_.AddElement<int32_t>(AnimationInitialData::VT_INSTANCE_VALUE_END_FRAME, instance_value_end_frame, 0);
  }
  void add_instance_value_loop_num(int32_t instance_value_loop_num) {
    fbb_.AddElement<int32_t>(AnimationInitialData::VT_INSTANCE_VALUE_LOOP_NUM, instance_value_loop_num, 0);
  }
  void add_instance_value_speed(float instance_value_speed) {
    fbb_.AddElement<float>(AnimationInitialData::VT_INSTANCE_VALUE_SPEED, instance_value_speed, 0.0f);
  }
  void add_instance_value_loop_flag(int32_t instance_value_loop_flag) {
    fbb_.AddElement<int32_t>(AnimationInitialData::VT_INSTANCE_VALUE_LOOP_FLAG, instance_value_loop_flag, 0);
  }
  void add_effect_value_cur_keyframe(int32_t effect_value_cur_keyframe) {
    fbb_.AddElement<int32_t>(AnimationInitialData::VT_EFFECT_VALUE_CUR_KEYFRAME, effect_value_cur_keyframe, 0);
  }
  void add_effect_value_start_time(int32_t effect_value_start_time) {
    fbb_.AddElement<int32_t>(AnimationInitialData::VT_EFFECT_VALUE_START_TIME, effect_value_start_time, 0);
  }
  void add_effect_value_speed(float effect_value_speed) {
    fbb_.AddElement<float>(AnimationInitialData::VT_EFFECT_VALUE_SPEED, effect_value_speed, 0.0f);
  }
  void add_effect_value_loop_flag(int32_t effect_value_loop_flag) {
    fbb_.AddElement<int32_t>(AnimationInitialData::VT_EFFECT_VALUE_LOOP_FLAG, effect_value_loop_flag, 0);
  }
  explicit AnimationInitialDataBuilder(flatbuffers::FlatBufferBuilder &_fbb)
        : fbb_(_fbb) {
    start_ = fbb_.StartTable();
  }
  flatbuffers::Offset<AnimationInitialData> Finish() {
    const auto end = fbb_.EndTable(start_);
    auto o = flatbuffers::Offset<AnimationInitialData>(end);
    return o;
  }
};

inline flatbuffers::Offset<AnimationInitialData> CreateAnimationInitialData(
    flatbuffers::FlatBufferBuilder &_fbb,
    int16_t index = 0,
    int32_t lowflag = 0,
    int32_t highflag = 0,
    int16_t priority = 0,
    int16_t cell_index = 0,
    int16_t opacity = 0,
    int16_t local_opacity = 0,
    int16_t masklimen = 0,
    float position_x = 0.0f,
    float position_y = 0.0f,
    float position_z = 0.0f,
    float pivot_x = 0.0f,
    float pivot_y = 0.0f,
    float rotation_x = 0.0f,
    float rotation_y = 0.0f,
    float rotation_z = 0.0f,
    float scale_x = 0.0f,
    float scale_y = 0.0f,
    float local_scale_x = 0.0f,
    float local_scale_y = 0.0f,
    float size_x = 0.0f,
    float size_y = 0.0f,
    float uv_move_x = 0.0f,
    float uv_move_y = 0.0f,
    float uv_rotation = 0.0f,
    float uv_scale_x = 0.0f,
    float uv_scale_y = 0.0f,
    float bounding_radius = 0.0f,
    int32_t instance_value_cur_keyframe = 0,
    int32_t instance_value_start_frame = 0,
    int32_t instance_value_end_frame = 0,
    int32_t instance_value_loop_num = 0,
    float instance_value_speed = 0.0f,
    int32_t instance_value_loop_flag = 0,
    int32_t effect_value_cur_keyframe = 0,
    int32_t effect_value_start_time = 0,
    float effect_value_speed = 0.0f,
    int32_t effect_value_loop_flag = 0) {
  AnimationInitialDataBuilder builder_(_fbb);
  builder_.add_effect_value_loop_flag(effect_value_loop_flag);
  builder_.add_effect_value_speed(effect_value_speed);
  builder_.add_effect_value_start_time(effect_value_start_time);
  builder_.add_effect_value_cur_keyframe(effect_value_cur_keyframe);
  builder_.add_instance_value_loop_flag(instance_value_loop_flag);
  builder_.add_instance_value_speed(instance_value_speed);
  builder_.add_instance_value_loop_num(instance_value_loop_num);
  builder_.add_instance_value_end_frame(instance_value_end_frame);
  builder_.add_instance_value_start_frame(instance_value_start_frame);
  builder_.add_instance_value_cur_keyframe(instance_value_cur_keyframe);
  builder_.add_bounding_radius(bounding_radius);
  builder_.add_uv_scale_y(uv_scale_y);
  builder_.add_uv_scale_x(uv_scale_x);
  builder_.add_uv_rotation(uv_rotation);
  builder_.add_uv_move_y(uv_move_y);
  builder_.add_uv_move_x(uv_move_x);
  builder_.add_size_y(size_y);
  builder_.add_size_x(size_x);
  builder_.add_local_scale_y(local_scale_y);
  builder_.add_local_scale_x(local_scale_x);
  builder_.add_scale_y(scale_y);
  builder_.add_scale_x(scale_x);
  builder_.add_rotation_z(rotation_z);
  builder_.add_rotation_y(rotation_y);
  builder_.add_rotation_x(rotation_x);
  builder_.add_pivot_y(pivot_y);
  builder_.add_pivot_x(pivot_x);
  builder_.add_position_z(position_z);
  builder_.add_position_y(position_y);
  builder_.add_position_x(position_x);
  builder_.add_highflag(highflag);
  builder_.add_lowflag(lowflag);
  builder_.add_masklimen(masklimen);
  builder_.add_local_opacity(local_opacity);
  builder_.add_opacity(opacity);
  builder_.add_cell_index(cell_index);
  builder_.add_priority(priority);
  builder_.add_index(index);
  return builder_.Finish();
}

flatbuffers::Offset<AnimationInitialData> CreateAnimationInitialData(flatbuffers::FlatBufferBuilder &_fbb, const AnimationInitialDataT *_o, const flatbuffers::rehasher_function_t *_rehasher = nullptr);

struct PartDataT : public flatbuffers::NativeTable {
  typedef PartData TableType;
  std::string name{};
  int16_t index = 0;
  int16_t parent_index = 0;
  ss::ssfb::SsPartType type = ss::ssfb::SsPartType_Nulltype;
  int16_t bounds_type = 0;
  int16_t alpha_blend_type = 0;
  std::string refname{};
  std::string effectfilename{};
  std::string colorLabel{};
  int16_t mask_influence = 0;
};

struct PartData FLATBUFFERS_FINAL_CLASS : private flatbuffers::Table {
  typedef PartDataT NativeTableType;
  typedef PartDataBuilder Builder;
  enum FlatBuffersVTableOffset FLATBUFFERS_VTABLE_UNDERLYING_TYPE {
    VT_NAME = 4,
    VT_INDEX = 6,
    VT_PARENT_INDEX = 8,
    VT_TYPE = 10,
    VT_BOUNDS_TYPE = 12,
    VT_ALPHA_BLEND_TYPE = 14,
    VT_REFNAME = 16,
    VT_EFFECTFILENAME = 18,
    VT_COLORLABEL = 20,
    VT_MASK_INFLUENCE = 22
  };
  const flatbuffers::String *name() const {
    return GetPointer<const flatbuffers::String *>(VT_NAME);
  }
  int16_t index() const {
    return GetField<int16_t>(VT_INDEX, 0);
  }
  int16_t parent_index() const {
    return GetField<int16_t>(VT_PARENT_INDEX, 0);
  }
  ss::ssfb::SsPartType type() const {
    return static_cast<ss::ssfb::SsPartType>(GetField<int8_t>(VT_TYPE, 0));
  }
  int16_t bounds_type() const {
    return GetField<int16_t>(VT_BOUNDS_TYPE, 0);
  }
  int16_t alpha_blend_type() const {
    return GetField<int16_t>(VT_ALPHA_BLEND_TYPE, 0);
  }
  const flatbuffers::String *refname() const {
    return GetPointer<const flatbuffers::String *>(VT_REFNAME);
  }
  const flatbuffers::String *effectfilename() const {
    return GetPointer<const flatbuffers::String *>(VT_EFFECTFILENAME);
  }
  const flatbuffers::String *colorLabel() const {
    return GetPointer<const flatbuffers::String *>(VT_COLORLABEL);
  }
  int16_t mask_influence() const {
    return GetField<int16_t>(VT_MASK_INFLUENCE, 0);
  }
  bool Verify(flatbuffers::Verifier &verifier) const {
    return VerifyTableStart(verifier) &&
           VerifyOffset(verifier, VT_NAME) &&
           verifier.VerifyString(name()) &&
           VerifyField<int16_t>(verifier, VT_INDEX) &&
           VerifyField<int16_t>(verifier, VT_PARENT_INDEX) &&
           VerifyField<int8_t>(verifier, VT_TYPE) &&
           VerifyField<int16_t>(verifier, VT_BOUNDS_TYPE) &&
           VerifyField<int16_t>(verifier, VT_ALPHA_BLEND_TYPE) &&
           VerifyOffset(verifier, VT_REFNAME) &&
           verifier.VerifyString(refname()) &&
           VerifyOffset(verifier, VT_EFFECTFILENAME) &&
           verifier.VerifyString(effectfilename()) &&
           VerifyOffset(verifier, VT_COLORLABEL) &&
           verifier.VerifyString(colorLabel()) &&
           VerifyField<int16_t>(verifier, VT_MASK_INFLUENCE) &&
           verifier.EndTable();
  }
  PartDataT *UnPack(const flatbuffers::resolver_function_t *_resolver = nullptr) const;
  void UnPackTo(PartDataT *_o, const flatbuffers::resolver_function_t *_resolver = nullptr) const;
  static flatbuffers::Offset<PartData> Pack(flatbuffers::FlatBufferBuilder &_fbb, const PartDataT* _o, const flatbuffers::rehasher_function_t *_rehasher = nullptr);
};

struct PartDataBuilder {
  typedef PartData Table;
  flatbuffers::FlatBufferBuilder &fbb_;
  flatbuffers::uoffset_t start_;
  void add_name(flatbuffers::Offset<flatbuffers::String> name) {
    fbb_.AddOffset(PartData::VT_NAME, name);
  }
  void add_index(int16_t index) {
    fbb_.AddElement<int16_t>(PartData::VT_INDEX, index, 0);
  }
  void add_parent_index(int16_t parent_index) {
    fbb_.AddElement<int16_t>(PartData::VT_PARENT_INDEX, parent_index, 0);
  }
  void add_type(ss::ssfb::SsPartType type) {
    fbb_.AddElement<int8_t>(PartData::VT_TYPE, static_cast<int8_t>(type), 0);
  }
  void add_bounds_type(int16_t bounds_type) {
    fbb_.AddElement<int16_t>(PartData::VT_BOUNDS_TYPE, bounds_type, 0);
  }
  void add_alpha_blend_type(int16_t alpha_blend_type) {
    fbb_.AddElement<int16_t>(PartData::VT_ALPHA_BLEND_TYPE, alpha_blend_type, 0);
  }
  void add_refname(flatbuffers::Offset<flatbuffers::String> refname) {
    fbb_.AddOffset(PartData::VT_REFNAME, refname);
  }
  void add_effectfilename(flatbuffers::Offset<flatbuffers::String> effectfilename) {
    fbb_.AddOffset(PartData::VT_EFFECTFILENAME, effectfilename);
  }
  void add_colorLabel(flatbuffers::Offset<flatbuffers::String> colorLabel) {
    fbb_.AddOffset(PartData::VT_COLORLABEL, colorLabel);
  }
  void add_mask_influence(int16_t mask_influence) {
    fbb_.AddElement<int16_t>(PartData::VT_MASK_INFLUENCE, mask_influence, 0);
  }
  explicit PartDataBuilder(flatbuffers::FlatBufferBuilder &_fbb)
        : fbb_(_fbb) {
    start_ = fbb_.StartTable();
  }
  flatbuffers::Offset<PartData> Finish() {
    const auto end = fbb_.EndTable(start_);
    auto o = flatbuffers::Offset<PartData>(end);
    return o;
  }
};

inline flatbuffers::Offset<PartData> CreatePartData(
    flatbuffers::FlatBufferBuilder &_fbb,
    flatbuffers::Offset<flatbuffers::String> name = 0,
    int16_t index = 0,
    int16_t parent_index = 0,
    ss::ssfb::SsPartType type = ss::ssfb::SsPartType_Nulltype,
    int16_t bounds_type = 0,
    int16_t alpha_blend_type = 0,
    flatbuffers::Offset<flatbuffers::String> refname = 0,
    flatbuffers::Offset<flatbuffers::String> effectfilename = 0,
    flatbuffers::Offset<flatbuffers::String> colorLabel = 0,
    int16_t mask_influence = 0) {
  PartDataBuilder builder_(_fbb);
  builder_.add_colorLabel(colorLabel);
  builder_.add_effectfilename(effectfilename);
  builder_.add_refname(refname);
  builder_.add_name(name);
  builder_.add_mask_influence(mask_influence);
  builder_.add_alpha_blend_type(alpha_blend_type);
  builder_.add_bounds_type(bounds_type);
  builder_.add_parent_index(parent_index);
  builder_.add_index(index);
  builder_.add_type(type);
  return builder_.Finish();
}

inline flatbuffers::Offset<PartData> CreatePartDataDirect(
    flatbuffers::FlatBufferBuilder &_fbb,
    const char *name = nullptr,
    int16_t index = 0,
    int16_t parent_index = 0,
    ss::ssfb::SsPartType type = ss::ssfb::SsPartType_Nulltype,
    int16_t bounds_type = 0,
    int16_t alpha_blend_type = 0,
    const char *refname = nullptr,
    const char *effectfilename = nullptr,
    const char *colorLabel = nullptr,
    int16_t mask_influence = 0) {
  auto name__ = name ? _fbb.CreateString(name) : 0;
  auto refname__ = refname ? _fbb.CreateString(refname) : 0;
  auto effectfilename__ = effectfilename ? _fbb.CreateString(effectfilename) : 0;
  auto colorLabel__ = colorLabel ? _fbb.CreateString(colorLabel) : 0;
  return ss::ssfb::CreatePartData(
      _fbb,
      name__,
      index,
      parent_index,
      type,
      bounds_type,
      alpha_blend_type,
      refname__,
      effectfilename__,
      colorLabel__,
      mask_influence);
}

flatbuffers::Offset<PartData> CreatePartData(flatbuffers::FlatBufferBuilder &_fbb, const PartDataT *_o, const flatbuffers::rehasher_function_t *_rehasher = nullptr);

struct AnimePackDataT : public flatbuffers::NativeTable {
  typedef AnimePackData TableType;
  std::string name{};
  std::vector<std::unique_ptr<ss::ssfb::PartDataT>> parts{};
  std::vector<std::unique_ptr<ss::ssfb::AnimationDataT>> animations{};
};

struct AnimePackData FLATBUFFERS_FINAL_CLASS : private flatbuffers::Table {
  typedef AnimePackDataT NativeTableType;
  typedef AnimePackDataBuilder Builder;
  enum FlatBuffersVTableOffset FLATBUFFERS_VTABLE_UNDERLYING_TYPE {
    VT_NAME = 4,
    VT_PARTS = 6,
    VT_ANIMATIONS = 8
  };
  const flatbuffers::String *name() const {
    return GetPointer<const flatbuffers::String *>(VT_NAME);
  }
  const flatbuffers::Vector<flatbuffers::Offset<ss::ssfb::PartData>> *parts() const {
    return GetPointer<const flatbuffers::Vector<flatbuffers::Offset<ss::ssfb::PartData>> *>(VT_PARTS);
  }
  const flatbuffers::Vector<flatbuffers::Offset<ss::ssfb::AnimationData>> *animations() const {
    return GetPointer<const flatbuffers::Vector<flatbuffers::Offset<ss::ssfb::AnimationData>> *>(VT_ANIMATIONS);
  }
  bool Verify(flatbuffers::Verifier &verifier) const {
    return VerifyTableStart(verifier) &&
           VerifyOffset(verifier, VT_NAME) &&
           verifier.VerifyString(name()) &&
           VerifyOffset(verifier, VT_PARTS) &&
           verifier.VerifyVector(parts()) &&
           verifier.VerifyVectorOfTables(parts()) &&
           VerifyOffset(verifier, VT_ANIMATIONS) &&
           verifier.VerifyVector(animations()) &&
           verifier.VerifyVectorOfTables(animations()) &&
           verifier.EndTable();
  }
  AnimePackDataT *UnPack(const flatbuffers::resolver_function_t *_resolver = nullptr) const;
  void UnPackTo(AnimePackDataT *_o, const flatbuffers::resolver_function_t *_resolver = nullptr) const;
  static flatbuffers::Offset<AnimePackData> Pack(flatbuffers::FlatBufferBuilder &_fbb, const AnimePackDataT* _o, const flatbuffers::rehasher_function_t *_rehasher = nullptr);
};

struct AnimePackDataBuilder {
  typedef AnimePackData Table;
  flatbuffers::FlatBufferBuilder &fbb_;
  flatbuffers::uoffset_t start_;
  void add_name(flatbuffers::Offset<flatbuffers::String> name) {
    fbb_.AddOffset(AnimePackData::VT_NAME, name);
  }
  void add_parts(flatbuffers::Offset<flatbuffers::Vector<flatbuffers::Offset<ss::ssfb::PartData>>> parts) {
    fbb_.AddOffset(AnimePackData::VT_PARTS, parts);
  }
  void add_animations(flatbuffers::Offset<flatbuffers::Vector<flatbuffers::Offset<ss::ssfb::AnimationData>>> animations) {
    fbb_.AddOffset(AnimePackData::VT_ANIMATIONS, animations);
  }
  explicit AnimePackDataBuilder(flatbuffers::FlatBufferBuilder &_fbb)
        : fbb_(_fbb) {
    start_ = fbb_.StartTable();
  }
  flatbuffers::Offset<AnimePackData> Finish() {
    const auto end = fbb_.EndTable(start_);
    auto o = flatbuffers::Offset<AnimePackData>(end);
    return o;
  }
};

inline flatbuffers::Offset<AnimePackData> CreateAnimePackData(
    flatbuffers::FlatBufferBuilder &_fbb,
    flatbuffers::Offset<flatbuffers::String> name = 0,
    flatbuffers::Offset<flatbuffers::Vector<flatbuffers::Offset<ss::ssfb::PartData>>> parts = 0,
    flatbuffers::Offset<flatbuffers::Vector<flatbuffers::Offset<ss::ssfb::AnimationData>>> animations = 0) {
  AnimePackDataBuilder builder_(_fbb);
  builder_.add_animations(animations);
  builder_.add_parts(parts);
  builder_.add_name(name);
  return builder_.Finish();
}

inline flatbuffers::Offset<AnimePackData> CreateAnimePackDataDirect(
    flatbuffers::FlatBufferBuilder &_fbb,
    const char *name = nullptr,
    const std::vector<flatbuffers::Offset<ss::ssfb::PartData>> *parts = nullptr,
    const std::vector<flatbuffers::Offset<ss::ssfb::AnimationData>> *animations = nullptr) {
  auto name__ = name ? _fbb.CreateString(name) : 0;
  auto parts__ = parts ? _fbb.CreateVector<flatbuffers::Offset<ss::ssfb::PartData>>(*parts) : 0;
  auto animations__ = animations ? _fbb.CreateVector<flatbuffers::Offset<ss::ssfb::AnimationData>>(*animations) : 0;
  return ss::ssfb::CreateAnimePackData(
      _fbb,
      name__,
      parts__,
      animations__);
}

flatbuffers::Offset<AnimePackData> CreateAnimePackData(flatbuffers::FlatBufferBuilder &_fbb, const AnimePackDataT *_o, const flatbuffers::rehasher_function_t *_rehasher = nullptr);

struct ProjectDataT : public flatbuffers::NativeTable {
  typedef ProjectData TableType;
  uint32_t dataId = 0;
  uint32_t version = 0;
  int32_t flags = 0;
  std::string image_base_dir{};
  std::vector<std::unique_ptr<ss::ssfb::CellT>> cells{};
  std::vector<std::unique_ptr<ss::ssfb::AnimePackDataT>> anime_packs{};
  std::vector<std::unique_ptr<ss::ssfb::EffectFileT>> effect_file_list{};
  int16_t num_cells = 0;
  int16_t num_animePacks = 0;
  int16_t num_effectFileList = 0;
};

struct ProjectData FLATBUFFERS_FINAL_CLASS : private flatbuffers::Table {
  typedef ProjectDataT NativeTableType;
  typedef ProjectDataBuilder Builder;
  enum FlatBuffersVTableOffset FLATBUFFERS_VTABLE_UNDERLYING_TYPE {
    VT_DATAID = 4,
    VT_VERSION = 6,
    VT_FLAGS = 8,
    VT_IMAGE_BASE_DIR = 10,
    VT_CELLS = 12,
    VT_ANIME_PACKS = 14,
    VT_EFFECT_FILE_LIST = 16,
    VT_NUM_CELLS = 18,
    VT_NUM_ANIMEPACKS = 20,
    VT_NUM_EFFECTFILELIST = 22
  };
  uint32_t dataId() const {
    return GetField<uint32_t>(VT_DATAID, 0);
  }
  uint32_t version() const {
    return GetField<uint32_t>(VT_VERSION, 0);
  }
  int32_t flags() const {
    return GetField<int32_t>(VT_FLAGS, 0);
  }
  const flatbuffers::String *image_base_dir() const {
    return GetPointer<const flatbuffers::String *>(VT_IMAGE_BASE_DIR);
  }
  const flatbuffers::Vector<flatbuffers::Offset<ss::ssfb::Cell>> *cells() const {
    return GetPointer<const flatbuffers::Vector<flatbuffers::Offset<ss::ssfb::Cell>> *>(VT_CELLS);
  }
  const flatbuffers::Vector<flatbuffers::Offset<ss::ssfb::AnimePackData>> *anime_packs() const {
    return GetPointer<const flatbuffers::Vector<flatbuffers::Offset<ss::ssfb::AnimePackData>> *>(VT_ANIME_PACKS);
  }
  const flatbuffers::Vector<flatbuffers::Offset<ss::ssfb::EffectFile>> *effect_file_list() const {
    return GetPointer<const flatbuffers::Vector<flatbuffers::Offset<ss::ssfb::EffectFile>> *>(VT_EFFECT_FILE_LIST);
  }
  int16_t num_cells() const {
    return GetField<int16_t>(VT_NUM_CELLS, 0);
  }
  int16_t num_animePacks() const {
    return GetField<int16_t>(VT_NUM_ANIMEPACKS, 0);
  }
  int16_t num_effectFileList() const {
    return GetField<int16_t>(VT_NUM_EFFECTFILELIST, 0);
  }
  bool Verify(flatbuffers::Verifier &verifier) const {
    return VerifyTableStart(verifier) &&
           VerifyField<uint32_t>(verifier, VT_DATAID) &&
           VerifyField<uint32_t>(verifier, VT_VERSION) &&
           VerifyField<int32_t>(verifier, VT_FLAGS) &&
           VerifyOffset(verifier, VT_IMAGE_BASE_DIR) &&
           verifier.VerifyString(image_base_dir()) &&
           VerifyOffset(verifier, VT_CELLS) &&
           verifier.VerifyVector(cells()) &&
           verifier.VerifyVectorOfTables(cells()) &&
           VerifyOffset(verifier, VT_ANIME_PACKS) &&
           verifier.VerifyVector(anime_packs()) &&
           verifier.VerifyVectorOfTables(anime_packs()) &&
           VerifyOffset(verifier, VT_EFFECT_FILE_LIST) &&
           verifier.VerifyVector(effect_file_list()) &&
           verifier.VerifyVectorOfTables(effect_file_list()) &&
           VerifyField<int16_t>(verifier, VT_NUM_CELLS) &&
           VerifyField<int16_t>(verifier, VT_NUM_ANIMEPACKS) &&
           VerifyField<int16_t>(verifier, VT_NUM_EFFECTFILELIST) &&
           verifier.EndTable();
  }
  ProjectDataT *UnPack(const flatbuffers::resolver_function_t *_resolver = nullptr) const;
  void UnPackTo(ProjectDataT *_o, const flatbuffers::resolver_function_t *_resolver = nullptr) const;
  static flatbuffers::Offset<ProjectData> Pack(flatbuffers::FlatBufferBuilder &_fbb, const ProjectDataT* _o, const flatbuffers::rehasher_function_t *_rehasher = nullptr);
};

struct ProjectDataBuilder {
  typedef ProjectData Table;
  flatbuffers::FlatBufferBuilder &fbb_;
  flatbuffers::uoffset_t start_;
  void add_dataId(uint32_t dataId) {
    fbb_.AddElement<uint32_t>(ProjectData::VT_DATAID, dataId, 0);
  }
  void add_version(uint32_t version) {
    fbb_.AddElement<uint32_t>(ProjectData::VT_VERSION, version, 0);
  }
  void add_flags(int32_t flags) {
    fbb_.AddElement<int32_t>(ProjectData::VT_FLAGS, flags, 0);
  }
  void add_image_base_dir(flatbuffers::Offset<flatbuffers::String> image_base_dir) {
    fbb_.AddOffset(ProjectData::VT_IMAGE_BASE_DIR, image_base_dir);
  }
  void add_cells(flatbuffers::Offset<flatbuffers::Vector<flatbuffers::Offset<ss::ssfb::Cell>>> cells) {
    fbb_.AddOffset(ProjectData::VT_CELLS, cells);
  }
  void add_anime_packs(flatbuffers::Offset<flatbuffers::Vector<flatbuffers::Offset<ss::ssfb::AnimePackData>>> anime_packs) {
    fbb_.AddOffset(ProjectData::VT_ANIME_PACKS, anime_packs);
  }
  void add_effect_file_list(flatbuffers::Offset<flatbuffers::Vector<flatbuffers::Offset<ss::ssfb::EffectFile>>> effect_file_list) {
    fbb_.AddOffset(ProjectData::VT_EFFECT_FILE_LIST, effect_file_list);
  }
  void add_num_cells(int16_t num_cells) {
    fbb_.AddElement<int16_t>(ProjectData::VT_NUM_CELLS, num_cells, 0);
  }
  void add_num_animePacks(int16_t num_animePacks) {
    fbb_.AddElement<int16_t>(ProjectData::VT_NUM_ANIMEPACKS, num_animePacks, 0);
  }
  void add_num_effectFileList(int16_t num_effectFileList) {
    fbb_.AddElement<int16_t>(ProjectData::VT_NUM_EFFECTFILELIST, num_effectFileList, 0);
  }
  explicit ProjectDataBuilder(flatbuffers::FlatBufferBuilder &_fbb)
        : fbb_(_fbb) {
    start_ = fbb_.StartTable();
  }
  flatbuffers::Offset<ProjectData> Finish() {
    const auto end = fbb_.EndTable(start_);
    auto o = flatbuffers::Offset<ProjectData>(end);
    return o;
  }
};

inline flatbuffers::Offset<ProjectData> CreateProjectData(
    flatbuffers::FlatBufferBuilder &_fbb,
    uint32_t dataId = 0,
    uint32_t version = 0,
    int32_t flags = 0,
    flatbuffers::Offset<flatbuffers::String> image_base_dir = 0,
    flatbuffers::Offset<flatbuffers::Vector<flatbuffers::Offset<ss::ssfb::Cell>>> cells = 0,
    flatbuffers::Offset<flatbuffers::Vector<flatbuffers::Offset<ss::ssfb::AnimePackData>>> anime_packs = 0,
    flatbuffers::Offset<flatbuffers::Vector<flatbuffers::Offset<ss::ssfb::EffectFile>>> effect_file_list = 0,
    int16_t num_cells = 0,
    int16_t num_animePacks = 0,
    int16_t num_effectFileList = 0) {
  ProjectDataBuilder builder_(_fbb);
  builder_.add_effect_file_list(effect_file_list);
  builder_.add_anime_packs(anime_packs);
  builder_.add_cells(cells);
  builder_.add_image_base_dir(image_base_dir);
  builder_.add_flags(flags);
  builder_.add_version(version);
  builder_.add_dataId(dataId);
  builder_.add_num_effectFileList(num_effectFileList);
  builder_.add_num_animePacks(num_animePacks);
  builder_.add_num_cells(num_cells);
  return builder_.Finish();
}

inline flatbuffers::Offset<ProjectData> CreateProjectDataDirect(
    flatbuffers::FlatBufferBuilder &_fbb,
    uint32_t dataId = 0,
    uint32_t version = 0,
    int32_t flags = 0,
    const char *image_base_dir = nullptr,
    const std::vector<flatbuffers::Offset<ss::ssfb::Cell>> *cells = nullptr,
    const std::vector<flatbuffers::Offset<ss::ssfb::AnimePackData>> *anime_packs = nullptr,
    const std::vector<flatbuffers::Offset<ss::ssfb::EffectFile>> *effect_file_list = nullptr,
    int16_t num_cells = 0,
    int16_t num_animePacks = 0,
    int16_t num_effectFileList = 0) {
  auto image_base_dir__ = image_base_dir ? _fbb.CreateString(image_base_dir) : 0;
  auto cells__ = cells ? _fbb.CreateVector<flatbuffers::Offset<ss::ssfb::Cell>>(*cells) : 0;
  auto anime_packs__ = anime_packs ? _fbb.CreateVector<flatbuffers::Offset<ss::ssfb::AnimePackData>>(*anime_packs) : 0;
  auto effect_file_list__ = effect_file_list ? _fbb.CreateVector<flatbuffers::Offset<ss::ssfb::EffectFile>>(*effect_file_list) : 0;
  return ss::ssfb::CreateProjectData(
      _fbb,
      dataId,
      version,
      flags,
      image_base_dir__,
      cells__,
      anime_packs__,
      effect_file_list__,
      num_cells,
      num_animePacks,
      num_effectFileList);
}

flatbuffers::Offset<ProjectData> CreateProjectData(flatbuffers::FlatBufferBuilder &_fbb, const ProjectDataT *_o, const flatbuffers::rehasher_function_t *_rehasher = nullptr);


inline bool operator==(const EffectNodeT &lhs, const EffectNodeT &rhs) {
  return
      (lhs.array_index == rhs.array_index) &&
      (lhs.parent_index == rhs.parent_index) &&
      (lhs.type == rhs.type) &&
      (lhs.cell_index == rhs.cell_index) &&
      (lhs.blend_type == rhs.blend_type) &&
      ((lhs.basic_behavior == rhs.basic_behavior) || (lhs.basic_behavior && rhs.basic_behavior && *lhs.basic_behavior == *rhs.basic_behavior)) &&
      (lhs.behavior_flags == rhs.behavior_flags) &&
      (lhs.seed == rhs.seed) &&
      (lhs.delay_time == rhs.delay_time) &&
      (lhs.gravity_x == rhs.gravity_x) &&
      (lhs.gravity_y == rhs.gravity_y) &&
      (lhs.offset_x_min_value == rhs.offset_x_min_value) &&
      (lhs.offset_x_max_value == rhs.offset_x_max_value) &&
      (lhs.offset_y_min_value == rhs.offset_y_min_value) &&
      (lhs.offset_y_max_value == rhs.offset_y_max_value) &&
      (lhs.rotation_min_value == rhs.rotation_min_value) &&
      (lhs.rotation_max_value == rhs.rotation_max_value) &&
      (lhs.rotation_add_min_value == rhs.rotation_add_min_value) &&
      (lhs.rotation_add_max_value == rhs.rotation_add_max_value) &&
      (lhs.rotation_factor == rhs.rotation_factor) &&
      (lhs.end_life_time_per == rhs.end_life_time_per) &&
      (lhs.speed_min_value == rhs.speed_min_value) &&
      (lhs.speed_max_value == rhs.speed_max_value) &&
      (lhs.acceleration_min_value == rhs.acceleration_min_value) &&
      (lhs.acceleration_max_value == rhs.acceleration_max_value) &&
      (lhs.init_color_min_value == rhs.init_color_min_value) &&
      (lhs.init_color_max_value == rhs.init_color_max_value) &&
      (lhs.trans_color_min_value == rhs.trans_color_min_value) &&
      (lhs.trans_color_max_value == rhs.trans_color_max_value) &&
      (lhs.disprange_min_value == rhs.disprange_min_value) &&
      (lhs.disprange_max_value == rhs.disprange_max_value) &&
      (lhs.size_x_min_value == rhs.size_x_min_value) &&
      (lhs.size_x_max_value == rhs.size_x_max_value) &&
      (lhs.size_y_min_value == rhs.size_y_min_value) &&
      (lhs.size_y_max_value == rhs.size_y_max_value) &&
      (lhs.scale_factor_min_value == rhs.scale_factor_min_value) &&
      (lhs.scale_factor_max_value == rhs.scale_factor_max_value) &&
      (lhs.trans_size_x_min_value == rhs.trans_size_x_min_value) &&
      (lhs.trans_size_x_max_value == rhs.trans_size_x_max_value) &&
      (lhs.trans_size_y_min_value == rhs.trans_size_y_min_value) &&
      (lhs.trans_size_y_max_value == rhs.trans_size_y_max_value) &&
      (lhs.trans_scale_factor_min_value == rhs.trans_scale_factor_min_value) &&
      (lhs.trans_scale_factor_max_value == rhs.trans_scale_factor_max_value) &&
      (lhs.point_gravity_position_x == rhs.point_gravity_position_x) &&
      (lhs.point_gravity_position_y == rhs.point_gravity_position_y) &&
      (lhs.point_gravity_power == rhs.point_gravity_power) &&
      (lhs.rotation == rhs.rotation) &&
      (lhs.infinitie_emit_flag == rhs.infinitie_emit_flag);
}

inline bool operator!=(const EffectNodeT &lhs, const EffectNodeT &rhs) {
    return !(lhs == rhs);
}


inline EffectNodeT *EffectNode::UnPack(const flatbuffers::resolver_function_t *_resolver) const {
  auto _o = std::unique_ptr<EffectNodeT>(new EffectNodeT());
  UnPackTo(_o.get(), _resolver);
  return _o.release();
}

inline void EffectNode::UnPackTo(EffectNodeT *_o, const flatbuffers::resolver_function_t *_resolver) const {
  (void)_o;
  (void)_resolver;
  { auto _e = array_index(); _o->array_index = _e; }
  { auto _e = parent_index(); _o->parent_index = _e; }
  { auto _e = type(); _o->type = _e; }
  { auto _e = cell_index(); _o->cell_index = _e; }
  { auto _e = blend_type(); _o->blend_type = _e; }
  { auto _e = basic_behavior(); if (_e) _o->basic_behavior = std::unique_ptr<ss::ssfb::EffectParticleElementBasic>(new ss::ssfb::EffectParticleElementBasic(*_e)); }
  { auto _e = behavior_flags(); _o->behavior_flags = _e; }
  { auto _e = seed(); _o->seed = _e; }
  { auto _e = delay_time(); _o->delay_time = _e; }
  { auto _e = gravity_x(); _o->gravity_x = _e; }
  { auto _e = gravity_y(); _o->gravity_y = _e; }
  { auto _e = offset_x_min_value(); _o->offset_x_min_value = _e; }
  { auto _e = offset_x_max_value(); _o->offset_x_max_value = _e; }
  { auto _e = offset_y_min_value(); _o->offset_y_min_value = _e; }
  { auto _e = offset_y_max_value(); _o->offset_y_max_value = _e; }
  { auto _e = rotation_min_value(); _o->rotation_min_value = _e; }
  { auto _e = rotation_max_value(); _o->rotation_max_value = _e; }
  { auto _e = rotation_add_min_value(); _o->rotation_add_min_value = _e; }
  { auto _e = rotation_add_max_value(); _o->rotation_add_max_value = _e; }
  { auto _e = rotation_factor(); _o->rotation_factor = _e; }
  { auto _e = end_life_time_per(); _o->end_life_time_per = _e; }
  { auto _e = speed_min_value(); _o->speed_min_value = _e; }
  { auto _e = speed_max_value(); _o->speed_max_value = _e; }
  { auto _e = acceleration_min_value(); _o->acceleration_min_value = _e; }
  { auto _e = acceleration_max_value(); _o->acceleration_max_value = _e; }
  { auto _e = init_color_min_value(); _o->init_color_min_value = _e; }
  { auto _e = init_color_max_value(); _o->init_color_max_value = _e; }
  { auto _e = trans_color_min_value(); _o->trans_color_min_value = _e; }
  { auto _e = trans_color_max_value(); _o->trans_color_max_value = _e; }
  { auto _e = disprange_min_value(); _o->disprange_min_value = _e; }
  { auto _e = disprange_max_value(); _o->disprange_max_value = _e; }
  { auto _e = size_x_min_value(); _o->size_x_min_value = _e; }
  { auto _e = size_x_max_value(); _o->size_x_max_value = _e; }
  { auto _e = size_y_min_value(); _o->size_y_min_value = _e; }
  { auto _e = size_y_max_value(); _o->size_y_max_value = _e; }
  { auto _e = scale_factor_min_value(); _o->scale_factor_min_value = _e; }
  { auto _e = scale_factor_max_value(); _o->scale_factor_max_value = _e; }
  { auto _e = trans_size_x_min_value(); _o->trans_size_x_min_value = _e; }
  { auto _e = trans_size_x_max_value(); _o->trans_size_x_max_value = _e; }
  { auto _e = trans_size_y_min_value(); _o->trans_size_y_min_value = _e; }
  { auto _e = trans_size_y_max_value(); _o->trans_size_y_max_value = _e; }
  { auto _e = trans_scale_factor_min_value(); _o->trans_scale_factor_min_value = _e; }
  { auto _e = trans_scale_factor_max_value(); _o->trans_scale_factor_max_value = _e; }
  { auto _e = point_gravity_position_x(); _o->point_gravity_position_x = _e; }
  { auto _e = point_gravity_position_y(); _o->point_gravity_position_y = _e; }
  { auto _e = point_gravity_power(); _o->point_gravity_power = _e; }
  { auto _e = rotation(); _o->rotation = _e; }
  { auto _e = infinitie_emit_flag(); _o->infinitie_emit_flag = _e; }
}

inline flatbuffers::Offset<EffectNode> EffectNode::Pack(flatbuffers::FlatBufferBuilder &_fbb, const EffectNodeT* _o, const flatbuffers::rehasher_function_t *_rehasher) {
  return CreateEffectNode(_fbb, _o, _rehasher);
}

inline flatbuffers::Offset<EffectNode> CreateEffectNode(flatbuffers::FlatBufferBuilder &_fbb, const EffectNodeT *_o, const flatbuffers::rehasher_function_t *_rehasher) {
  (void)_rehasher;
  (void)_o;
  struct _VectorArgs { flatbuffers::FlatBufferBuilder *__fbb; const EffectNodeT* __o; const flatbuffers::rehasher_function_t *__rehasher; } _va = { &_fbb, _o, _rehasher}; (void)_va;
  auto _array_index = _o->array_index;
  auto _parent_index = _o->parent_index;
  auto _type = _o->type;
  auto _cell_index = _o->cell_index;
  auto _blend_type = _o->blend_type;
  auto _basic_behavior = _o->basic_behavior ? _o->basic_behavior.get() : 0;
  auto _behavior_flags = _o->behavior_flags;
  auto _seed = _o->seed;
  auto _delay_time = _o->delay_time;
  auto _gravity_x = _o->gravity_x;
  auto _gravity_y = _o->gravity_y;
  auto _offset_x_min_value = _o->offset_x_min_value;
  auto _offset_x_max_value = _o->offset_x_max_value;
  auto _offset_y_min_value = _o->offset_y_min_value;
  auto _offset_y_max_value = _o->offset_y_max_value;
  auto _rotation_min_value = _o->rotation_min_value;
  auto _rotation_max_value = _o->rotation_max_value;
  auto _rotation_add_min_value = _o->rotation_add_min_value;
  auto _rotation_add_max_value = _o->rotation_add_max_value;
  auto _rotation_factor = _o->rotation_factor;
  auto _end_life_time_per = _o->end_life_time_per;
  auto _speed_min_value = _o->speed_min_value;
  auto _speed_max_value = _o->speed_max_value;
  auto _acceleration_min_value = _o->acceleration_min_value;
  auto _acceleration_max_value = _o->acceleration_max_value;
  auto _init_color_min_value = _o->init_color_min_value;
  auto _init_color_max_value = _o->init_color_max_value;
  auto _trans_color_min_value = _o->trans_color_min_value;
  auto _trans_color_max_value = _o->trans_color_max_value;
  auto _disprange_min_value = _o->disprange_min_value;
  auto _disprange_max_value = _o->disprange_max_value;
  auto _size_x_min_value = _o->size_x_min_value;
  auto _size_x_max_value = _o->size_x_max_value;
  auto _size_y_min_value = _o->size_y_min_value;
  auto _size_y_max_value = _o->size_y_max_value;
  auto _scale_factor_min_value = _o->scale_factor_min_value;
  auto _scale_factor_max_value = _o->scale_factor_max_value;
  auto _trans_size_x_min_value = _o->trans_size_x_min_value;
  auto _trans_size_x_max_value = _o->trans_size_x_max_value;
  auto _trans_size_y_min_value = _o->trans_size_y_min_value;
  auto _trans_size_y_max_value = _o->trans_size_y_max_value;
  auto _trans_scale_factor_min_value = _o->trans_scale_factor_min_value;
  auto _trans_scale_factor_max_value = _o->trans_scale_factor_max_value;
  auto _point_gravity_position_x = _o->point_gravity_position_x;
  auto _point_gravity_position_y = _o->point_gravity_position_y;
  auto _point_gravity_power = _o->point_gravity_power;
  auto _rotation = _o->rotation;
  auto _infinitie_emit_flag = _o->infinitie_emit_flag;
  return ss::ssfb::CreateEffectNode(
      _fbb,
      _array_index,
      _parent_index,
      _type,
      _cell_index,
      _blend_type,
      _basic_behavior,
      _behavior_flags,
      _seed,
      _delay_time,
      _gravity_x,
      _gravity_y,
      _offset_x_min_value,
      _offset_x_max_value,
      _offset_y_min_value,
      _offset_y_max_value,
      _rotation_min_value,
      _rotation_max_value,
      _rotation_add_min_value,
      _rotation_add_max_value,
      _rotation_factor,
      _end_life_time_per,
      _speed_min_value,
      _speed_max_value,
      _acceleration_min_value,
      _acceleration_max_value,
      _init_color_min_value,
      _init_color_max_value,
      _trans_color_min_value,
      _trans_color_max_value,
      _disprange_min_value,
      _disprange_max_value,
      _size_x_min_value,
      _size_x_max_value,
      _size_y_min_value,
      _size_y_max_value,
      _scale_factor_min_value,
      _scale_factor_max_value,
      _trans_size_x_min_value,
      _trans_size_x_max_value,
      _trans_size_y_min_value,
      _trans_size_y_max_value,
      _trans_scale_factor_min_value,
      _trans_scale_factor_max_value,
      _point_gravity_position_x,
      _point_gravity_position_y,
      _point_gravity_power,
      _rotation,
      _infinitie_emit_flag);
}


inline bool operator==(const EffectFileT &lhs, const EffectFileT &rhs) {
  return
      (lhs.name == rhs.name) &&
      (lhs.fps == rhs.fps) &&
      (lhs.is_lock_rand_seed == rhs.is_lock_rand_seed) &&
      (lhs.lock_rand_seed == rhs.lock_rand_seed) &&
      (lhs.layout_scale_x == rhs.layout_scale_x) &&
      (lhs.layout_scale_y == rhs.layout_scale_y) &&
      (lhs.num_node_list == rhs.num_node_list) &&
      (lhs.effect_node == rhs.effect_node);
}

inline bool operator!=(const EffectFileT &lhs, const EffectFileT &rhs) {
    return !(lhs == rhs);
}


inline EffectFileT *EffectFile::UnPack(const flatbuffers::resolver_function_t *_resolver) const {
  auto _o = std::unique_ptr<EffectFileT>(new EffectFileT());
  UnPackTo(_o.get(), _resolver);
  return _o.release();
}

inline void EffectFile::UnPackTo(EffectFileT *_o, const flatbuffers::resolver_function_t *_resolver) const {
  (void)_o;
  (void)_resolver;
  { auto _e = name(); if (_e) _o->name = _e->str(); }
  { auto _e = fps(); _o->fps = _e; }
  { auto _e = is_lock_rand_seed(); _o->is_lock_rand_seed = _e; }
  { auto _e = lock_rand_seed(); _o->lock_rand_seed = _e; }
  { auto _e = layout_scale_x(); _o->layout_scale_x = _e; }
  { auto _e = layout_scale_y(); _o->layout_scale_y = _e; }
  { auto _e = num_node_list(); _o->num_node_list = _e; }
  { auto _e = effect_node(); if (_e) { _o->effect_node.resize(_e->size()); for (flatbuffers::uoffset_t _i = 0; _i < _e->size(); _i++) { if(_o->effect_node[_i]) { _e->Get(_i)->UnPackTo(_o->effect_node[_i].get(), _resolver); } else { _o->effect_node[_i] = std::unique_ptr<ss::ssfb::EffectNodeT>(_e->Get(_i)->UnPack(_resolver)); }; } } }
}

inline flatbuffers::Offset<EffectFile> EffectFile::Pack(flatbuffers::FlatBufferBuilder &_fbb, const EffectFileT* _o, const flatbuffers::rehasher_function_t *_rehasher) {
  return CreateEffectFile(_fbb, _o, _rehasher);
}

inline flatbuffers::Offset<EffectFile> CreateEffectFile(flatbuffers::FlatBufferBuilder &_fbb, const EffectFileT *_o, const flatbuffers::rehasher_function_t *_rehasher) {
  (void)_rehasher;
  (void)_o;
  struct _VectorArgs { flatbuffers::FlatBufferBuilder *__fbb; const EffectFileT* __o; const flatbuffers::rehasher_function_t *__rehasher; } _va = { &_fbb, _o, _rehasher}; (void)_va;
  auto _name = _o->name.empty() ? 0 : _fbb.CreateString(_o->name);
  auto _fps = _o->fps;
  auto _is_lock_rand_seed = _o->is_lock_rand_seed;
  auto _lock_rand_seed = _o->lock_rand_seed;
  auto _layout_scale_x = _o->layout_scale_x;
  auto _layout_scale_y = _o->layout_scale_y;
  auto _num_node_list = _o->num_node_list;
  auto _effect_node = _o->effect_node.size() ? _fbb.CreateVector<flatbuffers::Offset<ss::ssfb::EffectNode>> (_o->effect_node.size(), [](size_t i, _VectorArgs *__va) { return CreateEffectNode(*__va->__fbb, __va->__o->effect_node[i].get(), __va->__rehasher); }, &_va ) : 0;
  return ss::ssfb::CreateEffectFile(
      _fbb,
      _name,
      _fps,
      _is_lock_rand_seed,
      _lock_rand_seed,
      _layout_scale_x,
      _layout_scale_y,
      _num_node_list,
      _effect_node);
}


inline bool operator==(const CellMapT &lhs, const CellMapT &rhs) {
  return
      (lhs.name == rhs.name) &&
      (lhs.image_path == rhs.image_path) &&
      (lhs.index == rhs.index) &&
      (lhs.wrap_mode == rhs.wrap_mode) &&
      (lhs.filter_mode == rhs.filter_mode);
}

inline bool operator!=(const CellMapT &lhs, const CellMapT &rhs) {
    return !(lhs == rhs);
}


inline CellMapT *CellMap::UnPack(const flatbuffers::resolver_function_t *_resolver) const {
  auto _o = std::unique_ptr<CellMapT>(new CellMapT());
  UnPackTo(_o.get(), _resolver);
  return _o.release();
}

inline void CellMap::UnPackTo(CellMapT *_o, const flatbuffers::resolver_function_t *_resolver) const {
  (void)_o;
  (void)_resolver;
  { auto _e = name(); if (_e) _o->name = _e->str(); }
  { auto _e = image_path(); if (_e) _o->image_path = _e->str(); }
  { auto _e = index(); _o->index = _e; }
  { auto _e = wrap_mode(); _o->wrap_mode = _e; }
  { auto _e = filter_mode(); _o->filter_mode = _e; }
}

inline flatbuffers::Offset<CellMap> CellMap::Pack(flatbuffers::FlatBufferBuilder &_fbb, const CellMapT* _o, const flatbuffers::rehasher_function_t *_rehasher) {
  return CreateCellMap(_fbb, _o, _rehasher);
}

inline flatbuffers::Offset<CellMap> CreateCellMap(flatbuffers::FlatBufferBuilder &_fbb, const CellMapT *_o, const flatbuffers::rehasher_function_t *_rehasher) {
  (void)_rehasher;
  (void)_o;
  struct _VectorArgs { flatbuffers::FlatBufferBuilder *__fbb; const CellMapT* __o; const flatbuffers::rehasher_function_t *__rehasher; } _va = { &_fbb, _o, _rehasher}; (void)_va;
  auto _name = _o->name.empty() ? 0 : _fbb.CreateString(_o->name);
  auto _image_path = _o->image_path.empty() ? 0 : _fbb.CreateString(_o->image_path);
  auto _index = _o->index;
  auto _wrap_mode = _o->wrap_mode;
  auto _filter_mode = _o->filter_mode;
  return ss::ssfb::CreateCellMap(
      _fbb,
      _name,
      _image_path,
      _index,
      _wrap_mode,
      _filter_mode);
}


inline bool operator==(const CellT &lhs, const CellT &rhs) {
  return
      (lhs.name == rhs.name) &&
      ((lhs.cell_map == rhs.cell_map) || (lhs.cell_map && rhs.cell_map && *lhs.cell_map == *rhs.cell_map)) &&
      (lhs.index_in_cell_map == rhs.index_in_cell_map) &&
      (lhs.x == rhs.x) &&
      (lhs.y == rhs.y) &&
      (lhs.width == rhs.width) &&
      (lhs.height == rhs.height) &&
      (lhs.pivot_x == rhs.pivot_x) &&
      (lhs.pivot_y == rhs.pivot_y) &&
      (lhs.u1 == rhs.u1) &&
      (lhs.v1 == rhs.v1) &&
      (lhs.u2 == rhs.u2) &&
      (lhs.v2 == rhs.v2);
}

inline bool operator!=(const CellT &lhs, const CellT &rhs) {
    return !(lhs == rhs);
}


inline CellT *Cell::UnPack(const flatbuffers::resolver_function_t *_resolver) const {
  auto _o = std::unique_ptr<CellT>(new CellT());
  UnPackTo(_o.get(), _resolver);
  return _o.release();
}

inline void Cell::UnPackTo(CellT *_o, const flatbuffers::resolver_function_t *_resolver) const {
  (void)_o;
  (void)_resolver;
  { auto _e = name(); if (_e) _o->name = _e->str(); }
  { auto _e = cell_map(); if (_e) { if(_o->cell_map) { _e->UnPackTo(_o->cell_map.get(), _resolver); } else { _o->cell_map = std::unique_ptr<ss::ssfb::CellMapT>(_e->UnPack(_resolver)); } } }
  { auto _e = index_in_cell_map(); _o->index_in_cell_map = _e; }
  { auto _e = x(); _o->x = _e; }
  { auto _e = y(); _o->y = _e; }
  { auto _e = width(); _o->width = _e; }
  { auto _e = height(); _o->height = _e; }
  { auto _e = pivot_x(); _o->pivot_x = _e; }
  { auto _e = pivot_y(); _o->pivot_y = _e; }
  { auto _e = u1(); _o->u1 = _e; }
  { auto _e = v1(); _o->v1 = _e; }
  { auto _e = u2(); _o->u2 = _e; }
  { auto _e = v2(); _o->v2 = _e; }
}

inline flatbuffers::Offset<Cell> Cell::Pack(flatbuffers::FlatBufferBuilder &_fbb, const CellT* _o, const flatbuffers::rehasher_function_t *_rehasher) {
  return CreateCell(_fbb, _o, _rehasher);
}

inline flatbuffers::Offset<Cell> CreateCell(flatbuffers::FlatBufferBuilder &_fbb, const CellT *_o, const flatbuffers::rehasher_function_t *_rehasher) {
  (void)_rehasher;
  (void)_o;
  struct _VectorArgs { flatbuffers::FlatBufferBuilder *__fbb; const CellT* __o; const flatbuffers::rehasher_function_t *__rehasher; } _va = { &_fbb, _o, _rehasher}; (void)_va;
  auto _name = _o->name.empty() ? 0 : _fbb.CreateString(_o->name);
  auto _cell_map = _o->cell_map ? CreateCellMap(_fbb, _o->cell_map.get(), _rehasher) : 0;
  auto _index_in_cell_map = _o->index_in_cell_map;
  auto _x = _o->x;
  auto _y = _o->y;
  auto _width = _o->width;
  auto _height = _o->height;
  auto _pivot_x = _o->pivot_x;
  auto _pivot_y = _o->pivot_y;
  auto _u1 = _o->u1;
  auto _v1 = _o->v1;
  auto _u2 = _o->u2;
  auto _v2 = _o->v2;
  return ss::ssfb::CreateCell(
      _fbb,
      _name,
      _cell_map,
      _index_in_cell_map,
      _x,
      _y,
      _width,
      _height,
      _pivot_x,
      _pivot_y,
      _u1,
      _v1,
      _u2,
      _v2);
}


inline bool operator==(const MeshDataUVT &lhs, const MeshDataUVT &rhs) {
  return
      (lhs.uv == rhs.uv);
}

inline bool operator!=(const MeshDataUVT &lhs, const MeshDataUVT &rhs) {
    return !(lhs == rhs);
}


inline MeshDataUVT *MeshDataUV::UnPack(const flatbuffers::resolver_function_t *_resolver) const {
  auto _o = std::unique_ptr<MeshDataUVT>(new MeshDataUVT());
  UnPackTo(_o.get(), _resolver);
  return _o.release();
}

inline void MeshDataUV::UnPackTo(MeshDataUVT *_o, const flatbuffers::resolver_function_t *_resolver) const {
  (void)_o;
  (void)_resolver;
  { auto _e = uv(); if (_e) { _o->uv.resize(_e->size()); for (flatbuffers::uoffset_t _i = 0; _i < _e->size(); _i++) { _o->uv[_i] = _e->Get(_i); } } }
}

inline flatbuffers::Offset<MeshDataUV> MeshDataUV::Pack(flatbuffers::FlatBufferBuilder &_fbb, const MeshDataUVT* _o, const flatbuffers::rehasher_function_t *_rehasher) {
  return CreateMeshDataUV(_fbb, _o, _rehasher);
}

inline flatbuffers::Offset<MeshDataUV> CreateMeshDataUV(flatbuffers::FlatBufferBuilder &_fbb, const MeshDataUVT *_o, const flatbuffers::rehasher_function_t *_rehasher) {
  (void)_rehasher;
  (void)_o;
  struct _VectorArgs { flatbuffers::FlatBufferBuilder *__fbb; const MeshDataUVT* __o; const flatbuffers::rehasher_function_t *__rehasher; } _va = { &_fbb, _o, _rehasher}; (void)_va;
  auto _uv = _o->uv.size() ? _fbb.CreateVector(_o->uv) : 0;
  return ss::ssfb::CreateMeshDataUV(
      _fbb,
      _uv);
}


inline bool operator==(const MeshDataIndicesT &lhs, const MeshDataIndicesT &rhs) {
  return
      (lhs.indices == rhs.indices);
}

inline bool operator!=(const MeshDataIndicesT &lhs, const MeshDataIndicesT &rhs) {
    return !(lhs == rhs);
}


inline MeshDataIndicesT *MeshDataIndices::UnPack(const flatbuffers::resolver_function_t *_resolver) const {
  auto _o = std::unique_ptr<MeshDataIndicesT>(new MeshDataIndicesT());
  UnPackTo(_o.get(), _resolver);
  return _o.release();
}

inline void MeshDataIndices::UnPackTo(MeshDataIndicesT *_o, const flatbuffers::resolver_function_t *_resolver) const {
  (void)_o;
  (void)_resolver;
  { auto _e = indices(); if (_e) { _o->indices.resize(_e->size()); for (flatbuffers::uoffset_t _i = 0; _i < _e->size(); _i++) { _o->indices[_i] = _e->Get(_i); } } }
}

inline flatbuffers::Offset<MeshDataIndices> MeshDataIndices::Pack(flatbuffers::FlatBufferBuilder &_fbb, const MeshDataIndicesT* _o, const flatbuffers::rehasher_function_t *_rehasher) {
  return CreateMeshDataIndices(_fbb, _o, _rehasher);
}

inline flatbuffers::Offset<MeshDataIndices> CreateMeshDataIndices(flatbuffers::FlatBufferBuilder &_fbb, const MeshDataIndicesT *_o, const flatbuffers::rehasher_function_t *_rehasher) {
  (void)_rehasher;
  (void)_o;
  struct _VectorArgs { flatbuffers::FlatBufferBuilder *__fbb; const MeshDataIndicesT* __o; const flatbuffers::rehasher_function_t *__rehasher; } _va = { &_fbb, _o, _rehasher}; (void)_va;
  auto _indices = _o->indices.size() ? _fbb.CreateVector(_o->indices) : 0;
  return ss::ssfb::CreateMeshDataIndices(
      _fbb,
      _indices);
}


inline bool operator==(const PartStateT &lhs, const PartStateT &rhs) {
  return
      (lhs.index == rhs.index) &&
      (lhs.flag1 == rhs.flag1) &&
      (lhs.flag2 == rhs.flag2) &&
      (lhs.data == rhs.data);
}

inline bool operator!=(const PartStateT &lhs, const PartStateT &rhs) {
    return !(lhs == rhs);
}


inline PartStateT *PartState::UnPack(const flatbuffers::resolver_function_t *_resolver) const {
  auto _o = std::unique_ptr<PartStateT>(new PartStateT());
  UnPackTo(_o.get(), _resolver);
  return _o.release();
}

inline void PartState::UnPackTo(PartStateT *_o, const flatbuffers::resolver_function_t *_resolver) const {
  (void)_o;
  (void)_resolver;
  { auto _e = index(); _o->index = _e; }
  { auto _e = flag1(); _o->flag1 = _e; }
  { auto _e = flag2(); _o->flag2 = _e; }
  { auto _e = data(); if (_e) { _o->data.resize(_e->size()); for (flatbuffers::uoffset_t _i = 0; _i < _e->size(); _i++) { _o->data[_i] = _e->Get(_i); } } }
}

inline flatbuffers::Offset<PartState> PartState::Pack(flatbuffers::FlatBufferBuilder &_fbb, const PartStateT* _o, const flatbuffers::rehasher_function_t *_rehasher) {
  return CreatePartState(_fbb, _o, _rehasher);
}

inline flatbuffers::Offset<PartState> CreatePartState(flatbuffers::FlatBufferBuilder &_fbb, const PartStateT *_o, const flatbuffers::rehasher_function_t *_rehasher) {
  (void)_rehasher;
  (void)_o;
  struct _VectorArgs { flatbuffers::FlatBufferBuilder *__fbb; const PartStateT* __o; const flatbuffers::rehasher_function_t *__rehasher; } _va = { &_fbb, _o, _rehasher}; (void)_va;
  auto _index = _o->index;
  auto _flag1 = _o->flag1;
  auto _flag2 = _o->flag2;
  auto _data = _o->data.size() ? _fbb.CreateVector(_o->data) : 0;
  return ss::ssfb::CreatePartState(
      _fbb,
      _index,
      _flag1,
      _flag2,
      _data);
}


inline bool operator==(const FrameDataIndexT &lhs, const FrameDataIndexT &rhs) {
  return
      (lhs.states == rhs.states);
}

inline bool operator!=(const FrameDataIndexT &lhs, const FrameDataIndexT &rhs) {
    return !(lhs == rhs);
}


inline FrameDataIndexT *FrameDataIndex::UnPack(const flatbuffers::resolver_function_t *_resolver) const {
  auto _o = std::unique_ptr<FrameDataIndexT>(new FrameDataIndexT());
  UnPackTo(_o.get(), _resolver);
  return _o.release();
}

inline void FrameDataIndex::UnPackTo(FrameDataIndexT *_o, const flatbuffers::resolver_function_t *_resolver) const {
  (void)_o;
  (void)_resolver;
  { auto _e = states(); if (_e) { _o->states.resize(_e->size()); for (flatbuffers::uoffset_t _i = 0; _i < _e->size(); _i++) { if(_o->states[_i]) { _e->Get(_i)->UnPackTo(_o->states[_i].get(), _resolver); } else { _o->states[_i] = std::unique_ptr<ss::ssfb::PartStateT>(_e->Get(_i)->UnPack(_resolver)); }; } } }
}

inline flatbuffers::Offset<FrameDataIndex> FrameDataIndex::Pack(flatbuffers::FlatBufferBuilder &_fbb, const FrameDataIndexT* _o, const flatbuffers::rehasher_function_t *_rehasher) {
  return CreateFrameDataIndex(_fbb, _o, _rehasher);
}

inline flatbuffers::Offset<FrameDataIndex> CreateFrameDataIndex(flatbuffers::FlatBufferBuilder &_fbb, const FrameDataIndexT *_o, const flatbuffers::rehasher_function_t *_rehasher) {
  (void)_rehasher;
  (void)_o;
  struct _VectorArgs { flatbuffers::FlatBufferBuilder *__fbb; const FrameDataIndexT* __o; const flatbuffers::rehasher_function_t *__rehasher; } _va = { &_fbb, _o, _rehasher}; (void)_va;
  auto _states = _o->states.size() ? _fbb.CreateVector<flatbuffers::Offset<ss::ssfb::PartState>> (_o->states.size(), [](size_t i, _VectorArgs *__va) { return CreatePartState(*__va->__fbb, __va->__o->states[i].get(), __va->__rehasher); }, &_va ) : 0;
  return ss::ssfb::CreateFrameDataIndex(
      _fbb,
      _states);
}


inline bool operator==(const UserDataItemT &lhs, const UserDataItemT &rhs) {
  return
      (lhs.flags == rhs.flags) &&
      (lhs.array_index == rhs.array_index) &&
      (lhs.integer == rhs.integer) &&
      (lhs.rect_x == rhs.rect_x) &&
      (lhs.rect_y == rhs.rect_y) &&
      (lhs.rect_w == rhs.rect_w) &&
      (lhs.rect_h == rhs.rect_h) &&
      (lhs.point_x == rhs.point_x) &&
      (lhs.point_y == rhs.point_y) &&
      (lhs.user_string_length == rhs.user_string_length) &&
      (lhs.user_string == rhs.user_string);
}

inline bool operator!=(const UserDataItemT &lhs, const UserDataItemT &rhs) {
    return !(lhs == rhs);
}


inline UserDataItemT *UserDataItem::UnPack(const flatbuffers::resolver_function_t *_resolver) const {
  auto _o = std::unique_ptr<UserDataItemT>(new UserDataItemT());
  UnPackTo(_o.get(), _resolver);
  return _o.release();
}

inline void UserDataItem::UnPackTo(UserDataItemT *_o, const flatbuffers::resolver_function_t *_resolver) const {
  (void)_o;
  (void)_resolver;
  { auto _e = flags(); _o->flags = _e; }
  { auto _e = array_index(); _o->array_index = _e; }
  { auto _e = integer(); _o->integer = _e; }
  { auto _e = rect_x(); _o->rect_x = _e; }
  { auto _e = rect_y(); _o->rect_y = _e; }
  { auto _e = rect_w(); _o->rect_w = _e; }
  { auto _e = rect_h(); _o->rect_h = _e; }
  { auto _e = point_x(); _o->point_x = _e; }
  { auto _e = point_y(); _o->point_y = _e; }
  { auto _e = user_string_length(); _o->user_string_length = _e; }
  { auto _e = user_string(); if (_e) _o->user_string = _e->str(); }
}

inline flatbuffers::Offset<UserDataItem> UserDataItem::Pack(flatbuffers::FlatBufferBuilder &_fbb, const UserDataItemT* _o, const flatbuffers::rehasher_function_t *_rehasher) {
  return CreateUserDataItem(_fbb, _o, _rehasher);
}

inline flatbuffers::Offset<UserDataItem> CreateUserDataItem(flatbuffers::FlatBufferBuilder &_fbb, const UserDataItemT *_o, const flatbuffers::rehasher_function_t *_rehasher) {
  (void)_rehasher;
  (void)_o;
  struct _VectorArgs { flatbuffers::FlatBufferBuilder *__fbb; const UserDataItemT* __o; const flatbuffers::rehasher_function_t *__rehasher; } _va = { &_fbb, _o, _rehasher}; (void)_va;
  auto _flags = _o->flags;
  auto _array_index = _o->array_index;
  auto _integer = _o->integer;
  auto _rect_x = _o->rect_x;
  auto _rect_y = _o->rect_y;
  auto _rect_w = _o->rect_w;
  auto _rect_h = _o->rect_h;
  auto _point_x = _o->point_x;
  auto _point_y = _o->point_y;
  auto _user_string_length = _o->user_string_length;
  auto _user_string = _o->user_string.empty() ? 0 : _fbb.CreateString(_o->user_string);
  return ss::ssfb::CreateUserDataItem(
      _fbb,
      _flags,
      _array_index,
      _integer,
      _rect_x,
      _rect_y,
      _rect_w,
      _rect_h,
      _point_x,
      _point_y,
      _user_string_length,
      _user_string);
}


inline bool operator==(const UserDataPerFrameT &lhs, const UserDataPerFrameT &rhs) {
  return
      (lhs.frame_index == rhs.frame_index) &&
      (lhs.data == rhs.data);
}

inline bool operator!=(const UserDataPerFrameT &lhs, const UserDataPerFrameT &rhs) {
    return !(lhs == rhs);
}


inline UserDataPerFrameT *UserDataPerFrame::UnPack(const flatbuffers::resolver_function_t *_resolver) const {
  auto _o = std::unique_ptr<UserDataPerFrameT>(new UserDataPerFrameT());
  UnPackTo(_o.get(), _resolver);
  return _o.release();
}

inline void UserDataPerFrame::UnPackTo(UserDataPerFrameT *_o, const flatbuffers::resolver_function_t *_resolver) const {
  (void)_o;
  (void)_resolver;
  { auto _e = frame_index(); _o->frame_index = _e; }
  { auto _e = data(); if (_e) { _o->data.resize(_e->size()); for (flatbuffers::uoffset_t _i = 0; _i < _e->size(); _i++) { if(_o->data[_i]) { _e->Get(_i)->UnPackTo(_o->data[_i].get(), _resolver); } else { _o->data[_i] = std::unique_ptr<ss::ssfb::UserDataItemT>(_e->Get(_i)->UnPack(_resolver)); }; } } }
}

inline flatbuffers::Offset<UserDataPerFrame> UserDataPerFrame::Pack(flatbuffers::FlatBufferBuilder &_fbb, const UserDataPerFrameT* _o, const flatbuffers::rehasher_function_t *_rehasher) {
  return CreateUserDataPerFrame(_fbb, _o, _rehasher);
}

inline flatbuffers::Offset<UserDataPerFrame> CreateUserDataPerFrame(flatbuffers::FlatBufferBuilder &_fbb, const UserDataPerFrameT *_o, const flatbuffers::rehasher_function_t *_rehasher) {
  (void)_rehasher;
  (void)_o;
  struct _VectorArgs { flatbuffers::FlatBufferBuilder *__fbb; const UserDataPerFrameT* __o; const flatbuffers::rehasher_function_t *__rehasher; } _va = { &_fbb, _o, _rehasher}; (void)_va;
  auto _frame_index = _o->frame_index;
  auto _data = _o->data.size() ? _fbb.CreateVector<flatbuffers::Offset<ss::ssfb::UserDataItem>> (_o->data.size(), [](size_t i, _VectorArgs *__va) { return CreateUserDataItem(*__va->__fbb, __va->__o->data[i].get(), __va->__rehasher); }, &_va ) : 0;
  return ss::ssfb::CreateUserDataPerFrame(
      _fbb,
      _frame_index,
      _data);
}


inline bool operator==(const LabelDataItemT &lhs, const LabelDataItemT &rhs) {
  return
      (lhs.label == rhs.label) &&
      (lhs.frame_index == rhs.frame_index);
}

inline bool operator!=(const LabelDataItemT &lhs, const LabelDataItemT &rhs) {
    return !(lhs == rhs);
}


inline LabelDataItemT *LabelDataItem::UnPack(const flatbuffers::resolver_function_t *_resolver) const {
  auto _o = std::unique_ptr<LabelDataItemT>(new LabelDataItemT());
  UnPackTo(_o.get(), _resolver);
  return _o.release();
}

inline void LabelDataItem::UnPackTo(LabelDataItemT *_o, const flatbuffers::resolver_function_t *_resolver) const {
  (void)_o;
  (void)_resolver;
  { auto _e = label(); if (_e) _o->label = _e->str(); }
  { auto _e = frame_index(); _o->frame_index = _e; }
}

inline flatbuffers::Offset<LabelDataItem> LabelDataItem::Pack(flatbuffers::FlatBufferBuilder &_fbb, const LabelDataItemT* _o, const flatbuffers::rehasher_function_t *_rehasher) {
  return CreateLabelDataItem(_fbb, _o, _rehasher);
}

inline flatbuffers::Offset<LabelDataItem> CreateLabelDataItem(flatbuffers::FlatBufferBuilder &_fbb, const LabelDataItemT *_o, const flatbuffers::rehasher_function_t *_rehasher) {
  (void)_rehasher;
  (void)_o;
  struct _VectorArgs { flatbuffers::FlatBufferBuilder *__fbb; const LabelDataItemT* __o; const flatbuffers::rehasher_function_t *__rehasher; } _va = { &_fbb, _o, _rehasher}; (void)_va;
  auto _label = _o->label.empty() ? 0 : _fbb.CreateString(_o->label);
  auto _frame_index = _o->frame_index;
  return ss::ssfb::CreateLabelDataItem(
      _fbb,
      _label,
      _frame_index);
}


inline bool operator==(const AnimationDataT &lhs, const AnimationDataT &rhs) {
  return
      (lhs.name == rhs.name) &&
      (lhs.default_data == rhs.default_data) &&
      (lhs.frame_data == rhs.frame_data) &&
      (lhs.user_data == rhs.user_data) &&
      (lhs.label_data == rhs.label_data) &&
      (lhs.meshs_data_UV == rhs.meshs_data_UV) &&
      (lhs.meshs_data_indices == rhs.meshs_data_indices) &&
      (lhs.start_frames == rhs.start_frames) &&
      (lhs.end_frames == rhs.end_frames) &&
      (lhs.total_frames == rhs.total_frames) &&
      (lhs.fps == rhs.fps) &&
      (lhs.labelNum == rhs.labelNum) &&
      (lhs.canvas_size_w == rhs.canvas_size_w) &&
      (lhs.canvas_size_h == rhs.canvas_size_h) &&
      (lhs.canvas_pvot_x == rhs.canvas_pvot_x) &&
      (lhs.canvas_pvot_y == rhs.canvas_pvot_y);
}

inline bool operator!=(const AnimationDataT &lhs, const AnimationDataT &rhs) {
    return !(lhs == rhs);
}


inline AnimationDataT *AnimationData::UnPack(const flatbuffers::resolver_function_t *_resolver) const {
  auto _o = std::unique_ptr<AnimationDataT>(new AnimationDataT());
  UnPackTo(_o.get(), _resolver);
  return _o.release();
}

inline void AnimationData::UnPackTo(AnimationDataT *_o, const flatbuffers::resolver_function_t *_resolver) const {
  (void)_o;
  (void)_resolver;
  { auto _e = name(); if (_e) _o->name = _e->str(); }
  { auto _e = default_data(); if (_e) { _o->default_data.resize(_e->size()); for (flatbuffers::uoffset_t _i = 0; _i < _e->size(); _i++) { if(_o->default_data[_i]) { _e->Get(_i)->UnPackTo(_o->default_data[_i].get(), _resolver); } else { _o->default_data[_i] = std::unique_ptr<ss::ssfb::AnimationInitialDataT>(_e->Get(_i)->UnPack(_resolver)); }; } } }
  { auto _e = frame_data(); if (_e) { _o->frame_data.resize(_e->size()); for (flatbuffers::uoffset_t _i = 0; _i < _e->size(); _i++) { if(_o->frame_data[_i]) { _e->Get(_i)->UnPackTo(_o->frame_data[_i].get(), _resolver); } else { _o->frame_data[_i] = std::unique_ptr<ss::ssfb::FrameDataIndexT>(_e->Get(_i)->UnPack(_resolver)); }; } } }
  { auto _e = user_data(); if (_e) { _o->user_data.resize(_e->size()); for (flatbuffers::uoffset_t _i = 0; _i < _e->size(); _i++) { if(_o->user_data[_i]) { _e->Get(_i)->UnPackTo(_o->user_data[_i].get(), _resolver); } else { _o->user_data[_i] = std::unique_ptr<ss::ssfb::UserDataPerFrameT>(_e->Get(_i)->UnPack(_resolver)); }; } } }
  { auto _e = label_data(); if (_e) { _o->label_data.resize(_e->size()); for (flatbuffers::uoffset_t _i = 0; _i < _e->size(); _i++) { if(_o->label_data[_i]) { _e->Get(_i)->UnPackTo(_o->label_data[_i].get(), _resolver); } else { _o->label_data[_i] = std::unique_ptr<ss::ssfb::LabelDataItemT>(_e->Get(_i)->UnPack(_resolver)); }; } } }
  { auto _e = meshs_data_UV(); if (_e) { _o->meshs_data_UV.resize(_e->size()); for (flatbuffers::uoffset_t _i = 0; _i < _e->size(); _i++) { if(_o->meshs_data_UV[_i]) { _e->Get(_i)->UnPackTo(_o->meshs_data_UV[_i].get(), _resolver); } else { _o->meshs_data_UV[_i] = std::unique_ptr<ss::ssfb::MeshDataUVT>(_e->Get(_i)->UnPack(_resolver)); }; } } }
  { auto _e = meshs_data_indices(); if (_e) { _o->meshs_data_indices.resize(_e->size()); for (flatbuffers::uoffset_t _i = 0; _i < _e->size(); _i++) { if(_o->meshs_data_indices[_i]) { _e->Get(_i)->UnPackTo(_o->meshs_data_indices[_i].get(), _resolver); } else { _o->meshs_data_indices[_i] = std::unique_ptr<ss::ssfb::MeshDataIndicesT>(_e->Get(_i)->UnPack(_resolver)); }; } } }
  { auto _e = start_frames(); _o->start_frames = _e; }
  { auto _e = end_frames(); _o->end_frames = _e; }
  { auto _e = total_frames(); _o->total_frames = _e; }
  { auto _e = fps(); _o->fps = _e; }
  { auto _e = labelNum(); _o->labelNum = _e; }
  { auto _e = canvas_size_w(); _o->canvas_size_w = _e; }
  { auto _e = canvas_size_h(); _o->canvas_size_h = _e; }
  { auto _e = canvas_pvot_x(); _o->canvas_pvot_x = _e; }
  { auto _e = canvas_pvot_y(); _o->canvas_pvot_y = _e; }
}

inline flatbuffers::Offset<AnimationData> AnimationData::Pack(flatbuffers::FlatBufferBuilder &_fbb, const AnimationDataT* _o, const flatbuffers::rehasher_function_t *_rehasher) {
  return CreateAnimationData(_fbb, _o, _rehasher);
}

inline flatbuffers::Offset<AnimationData> CreateAnimationData(flatbuffers::FlatBufferBuilder &_fbb, const AnimationDataT *_o, const flatbuffers::rehasher_function_t *_rehasher) {
  (void)_rehasher;
  (void)_o;
  struct _VectorArgs { flatbuffers::FlatBufferBuilder *__fbb; const AnimationDataT* __o; const flatbuffers::rehasher_function_t *__rehasher; } _va = { &_fbb, _o, _rehasher}; (void)_va;
  auto _name = _o->name.empty() ? 0 : _fbb.CreateString(_o->name);
  auto _default_data = _o->default_data.size() ? _fbb.CreateVector<flatbuffers::Offset<ss::ssfb::AnimationInitialData>> (_o->default_data.size(), [](size_t i, _VectorArgs *__va) { return CreateAnimationInitialData(*__va->__fbb, __va->__o->default_data[i].get(), __va->__rehasher); }, &_va ) : 0;
  auto _frame_data = _o->frame_data.size() ? _fbb.CreateVector<flatbuffers::Offset<ss::ssfb::FrameDataIndex>> (_o->frame_data.size(), [](size_t i, _VectorArgs *__va) { return CreateFrameDataIndex(*__va->__fbb, __va->__o->frame_data[i].get(), __va->__rehasher); }, &_va ) : 0;
  auto _user_data = _o->user_data.size() ? _fbb.CreateVector<flatbuffers::Offset<ss::ssfb::UserDataPerFrame>> (_o->user_data.size(), [](size_t i, _VectorArgs *__va) { return CreateUserDataPerFrame(*__va->__fbb, __va->__o->user_data[i].get(), __va->__rehasher); }, &_va ) : 0;
  auto _label_data = _o->label_data.size() ? _fbb.CreateVector<flatbuffers::Offset<ss::ssfb::LabelDataItem>> (_o->label_data.size(), [](size_t i, _VectorArgs *__va) { return CreateLabelDataItem(*__va->__fbb, __va->__o->label_data[i].get(), __va->__rehasher); }, &_va ) : 0;
  auto _meshs_data_UV = _o->meshs_data_UV.size() ? _fbb.CreateVector<flatbuffers::Offset<ss::ssfb::MeshDataUV>> (_o->meshs_data_UV.size(), [](size_t i, _VectorArgs *__va) { return CreateMeshDataUV(*__va->__fbb, __va->__o->meshs_data_UV[i].get(), __va->__rehasher); }, &_va ) : 0;
  auto _meshs_data_indices = _o->meshs_data_indices.size() ? _fbb.CreateVector<flatbuffers::Offset<ss::ssfb::MeshDataIndices>> (_o->meshs_data_indices.size(), [](size_t i, _VectorArgs *__va) { return CreateMeshDataIndices(*__va->__fbb, __va->__o->meshs_data_indices[i].get(), __va->__rehasher); }, &_va ) : 0;
  auto _start_frames = _o->start_frames;
  auto _end_frames = _o->end_frames;
  auto _total_frames = _o->total_frames;
  auto _fps = _o->fps;
  auto _labelNum = _o->labelNum;
  auto _canvas_size_w = _o->canvas_size_w;
  auto _canvas_size_h = _o->canvas_size_h;
  auto _canvas_pvot_x = _o->canvas_pvot_x;
  auto _canvas_pvot_y = _o->canvas_pvot_y;
  return ss::ssfb::CreateAnimationData(
      _fbb,
      _name,
      _default_data,
      _frame_data,
      _user_data,
      _label_data,
      _meshs_data_UV,
      _meshs_data_indices,
      _start_frames,
      _end_frames,
      _total_frames,
      _fps,
      _labelNum,
      _canvas_size_w,
      _canvas_size_h,
      _canvas_pvot_x,
      _canvas_pvot_y);
}


inline bool operator==(const AnimationInitialDataT &lhs, const AnimationInitialDataT &rhs) {
  return
      (lhs.index == rhs.index) &&
      (lhs.lowflag == rhs.lowflag) &&
      (lhs.highflag == rhs.highflag) &&
      (lhs.priority == rhs.priority) &&
      (lhs.cell_index == rhs.cell_index) &&
      (lhs.opacity == rhs.opacity) &&
      (lhs.local_opacity == rhs.local_opacity) &&
      (lhs.masklimen == rhs.masklimen) &&
      (lhs.position_x == rhs.position_x) &&
      (lhs.position_y == rhs.position_y) &&
      (lhs.position_z == rhs.position_z) &&
      (lhs.pivot_x == rhs.pivot_x) &&
      (lhs.pivot_y == rhs.pivot_y) &&
      (lhs.rotation_x == rhs.rotation_x) &&
      (lhs.rotation_y == rhs.rotation_y) &&
      (lhs.rotation_z == rhs.rotation_z) &&
      (lhs.scale_x == rhs.scale_x) &&
      (lhs.scale_y == rhs.scale_y) &&
      (lhs.local_scale_x == rhs.local_scale_x) &&
      (lhs.local_scale_y == rhs.local_scale_y) &&
      (lhs.size_x == rhs.size_x) &&
      (lhs.size_y == rhs.size_y) &&
      (lhs.uv_move_x == rhs.uv_move_x) &&
      (lhs.uv_move_y == rhs.uv_move_y) &&
      (lhs.uv_rotation == rhs.uv_rotation) &&
      (lhs.uv_scale_x == rhs.uv_scale_x) &&
      (lhs.uv_scale_y == rhs.uv_scale_y) &&
      (lhs.bounding_radius == rhs.bounding_radius) &&
      (lhs.instance_value_cur_keyframe == rhs.instance_value_cur_keyframe) &&
      (lhs.instance_value_start_frame == rhs.instance_value_start_frame) &&
      (lhs.instance_value_end_frame == rhs.instance_value_end_frame) &&
      (lhs.instance_value_loop_num == rhs.instance_value_loop_num) &&
      (lhs.instance_value_speed == rhs.instance_value_speed) &&
      (lhs.instance_value_loop_flag == rhs.instance_value_loop_flag) &&
      (lhs.effect_value_cur_keyframe == rhs.effect_value_cur_keyframe) &&
      (lhs.effect_value_start_time == rhs.effect_value_start_time) &&
      (lhs.effect_value_speed == rhs.effect_value_speed) &&
      (lhs.effect_value_loop_flag == rhs.effect_value_loop_flag);
}

inline bool operator!=(const AnimationInitialDataT &lhs, const AnimationInitialDataT &rhs) {
    return !(lhs == rhs);
}


inline AnimationInitialDataT *AnimationInitialData::UnPack(const flatbuffers::resolver_function_t *_resolver) const {
  auto _o = std::unique_ptr<AnimationInitialDataT>(new AnimationInitialDataT());
  UnPackTo(_o.get(), _resolver);
  return _o.release();
}

inline void AnimationInitialData::UnPackTo(AnimationInitialDataT *_o, const flatbuffers::resolver_function_t *_resolver) const {
  (void)_o;
  (void)_resolver;
  { auto _e = index(); _o->index = _e; }
  { auto _e = lowflag(); _o->lowflag = _e; }
  { auto _e = highflag(); _o->highflag = _e; }
  { auto _e = priority(); _o->priority = _e; }
  { auto _e = cell_index(); _o->cell_index = _e; }
  { auto _e = opacity(); _o->opacity = _e; }
  { auto _e = local_opacity(); _o->local_opacity = _e; }
  { auto _e = masklimen(); _o->masklimen = _e; }
  { auto _e = position_x(); _o->position_x = _e; }
  { auto _e = position_y(); _o->position_y = _e; }
  { auto _e = position_z(); _o->position_z = _e; }
  { auto _e = pivot_x(); _o->pivot_x = _e; }
  { auto _e = pivot_y(); _o->pivot_y = _e; }
  { auto _e = rotation_x(); _o->rotation_x = _e; }
  { auto _e = rotation_y(); _o->rotation_y = _e; }
  { auto _e = rotation_z(); _o->rotation_z = _e; }
  { auto _e = scale_x(); _o->scale_x = _e; }
  { auto _e = scale_y(); _o->scale_y = _e; }
  { auto _e = local_scale_x(); _o->local_scale_x = _e; }
  { auto _e = local_scale_y(); _o->local_scale_y = _e; }
  { auto _e = size_x(); _o->size_x = _e; }
  { auto _e = size_y(); _o->size_y = _e; }
  { auto _e = uv_move_x(); _o->uv_move_x = _e; }
  { auto _e = uv_move_y(); _o->uv_move_y = _e; }
  { auto _e = uv_rotation(); _o->uv_rotation = _e; }
  { auto _e = uv_scale_x(); _o->uv_scale_x = _e; }
  { auto _e = uv_scale_y(); _o->uv_scale_y = _e; }
  { auto _e = bounding_radius(); _o->bounding_radius = _e; }
  { auto _e = instance_value_cur_keyframe(); _o->instance_value_cur_keyframe = _e; }
  { auto _e = instance_value_start_frame(); _o->instance_value_start_frame = _e; }
  { auto _e = instance_value_end_frame(); _o->instance_value_end_frame = _e; }
  { auto _e = instance_value_loop_num(); _o->instance_value_loop_num = _e; }
  { auto _e = instance_value_speed(); _o->instance_value_speed = _e; }
  { auto _e = instance_value_loop_flag(); _o->instance_value_loop_flag = _e; }
  { auto _e = effect_value_cur_keyframe(); _o->effect_value_cur_keyframe = _e; }
  { auto _e = effect_value_start_time(); _o->effect_value_start_time = _e; }
  { auto _e = effect_value_speed(); _o->effect_value_speed = _e; }
  { auto _e = effect_value_loop_flag(); _o->effect_value_loop_flag = _e; }
}

inline flatbuffers::Offset<AnimationInitialData> AnimationInitialData::Pack(flatbuffers::FlatBufferBuilder &_fbb, const AnimationInitialDataT* _o, const flatbuffers::rehasher_function_t *_rehasher) {
  return CreateAnimationInitialData(_fbb, _o, _rehasher);
}

inline flatbuffers::Offset<AnimationInitialData> CreateAnimationInitialData(flatbuffers::FlatBufferBuilder &_fbb, const AnimationInitialDataT *_o, const flatbuffers::rehasher_function_t *_rehasher) {
  (void)_rehasher;
  (void)_o;
  struct _VectorArgs { flatbuffers::FlatBufferBuilder *__fbb; const AnimationInitialDataT* __o; const flatbuffers::rehasher_function_t *__rehasher; } _va = { &_fbb, _o, _rehasher}; (void)_va;
  auto _index = _o->index;
  auto _lowflag = _o->lowflag;
  auto _highflag = _o->highflag;
  auto _priority = _o->priority;
  auto _cell_index = _o->cell_index;
  auto _opacity = _o->opacity;
  auto _local_opacity = _o->local_opacity;
  auto _masklimen = _o->masklimen;
  auto _position_x = _o->position_x;
  auto _position_y = _o->position_y;
  auto _position_z = _o->position_z;
  auto _pivot_x = _o->pivot_x;
  auto _pivot_y = _o->pivot_y;
  auto _rotation_x = _o->rotation_x;
  auto _rotation_y = _o->rotation_y;
  auto _rotation_z = _o->rotation_z;
  auto _scale_x = _o->scale_x;
  auto _scale_y = _o->scale_y;
  auto _local_scale_x = _o->local_scale_x;
  auto _local_scale_y = _o->local_scale_y;
  auto _size_x = _o->size_x;
  auto _size_y = _o->size_y;
  auto _uv_move_x = _o->uv_move_x;
  auto _uv_move_y = _o->uv_move_y;
  auto _uv_rotation = _o->uv_rotation;
  auto _uv_scale_x = _o->uv_scale_x;
  auto _uv_scale_y = _o->uv_scale_y;
  auto _bounding_radius = _o->bounding_radius;
  auto _instance_value_cur_keyframe = _o->instance_value_cur_keyframe;
  auto _instance_value_start_frame = _o->instance_value_start_frame;
  auto _instance_value_end_frame = _o->instance_value_end_frame;
  auto _instance_value_loop_num = _o->instance_value_loop_num;
  auto _instance_value_speed = _o->instance_value_speed;
  auto _instance_value_loop_flag = _o->instance_value_loop_flag;
  auto _effect_value_cur_keyframe = _o->effect_value_cur_keyframe;
  auto _effect_value_start_time = _o->effect_value_start_time;
  auto _effect_value_speed = _o->effect_value_speed;
  auto _effect_value_loop_flag = _o->effect_value_loop_flag;
  return ss::ssfb::CreateAnimationInitialData(
      _fbb,
      _index,
      _lowflag,
      _highflag,
      _priority,
      _cell_index,
      _opacity,
      _local_opacity,
      _masklimen,
      _position_x,
      _position_y,
      _position_z,
      _pivot_x,
      _pivot_y,
      _rotation_x,
      _rotation_y,
      _rotation_z,
      _scale_x,
      _scale_y,
      _local_scale_x,
      _local_scale_y,
      _size_x,
      _size_y,
      _uv_move_x,
      _uv_move_y,
      _uv_rotation,
      _uv_scale_x,
      _uv_scale_y,
      _bounding_radius,
      _instance_value_cur_keyframe,
      _instance_value_start_frame,
      _instance_value_end_frame,
      _instance_value_loop_num,
      _instance_value_speed,
      _instance_value_loop_flag,
      _effect_value_cur_keyframe,
      _effect_value_start_time,
      _effect_value_speed,
      _effect_value_loop_flag);
}


inline bool operator==(const PartDataT &lhs, const PartDataT &rhs) {
  return
      (lhs.name == rhs.name) &&
      (lhs.index == rhs.index) &&
      (lhs.parent_index == rhs.parent_index) &&
      (lhs.type == rhs.type) &&
      (lhs.bounds_type == rhs.bounds_type) &&
      (lhs.alpha_blend_type == rhs.alpha_blend_type) &&
      (lhs.refname == rhs.refname) &&
      (lhs.effectfilename == rhs.effectfilename) &&
      (lhs.colorLabel == rhs.colorLabel) &&
      (lhs.mask_influence == rhs.mask_influence);
}

inline bool operator!=(const PartDataT &lhs, const PartDataT &rhs) {
    return !(lhs == rhs);
}


inline PartDataT *PartData::UnPack(const flatbuffers::resolver_function_t *_resolver) const {
  auto _o = std::unique_ptr<PartDataT>(new PartDataT());
  UnPackTo(_o.get(), _resolver);
  return _o.release();
}

inline void PartData::UnPackTo(PartDataT *_o, const flatbuffers::resolver_function_t *_resolver) const {
  (void)_o;
  (void)_resolver;
  { auto _e = name(); if (_e) _o->name = _e->str(); }
  { auto _e = index(); _o->index = _e; }
  { auto _e = parent_index(); _o->parent_index = _e; }
  { auto _e = type(); _o->type = _e; }
  { auto _e = bounds_type(); _o->bounds_type = _e; }
  { auto _e = alpha_blend_type(); _o->alpha_blend_type = _e; }
  { auto _e = refname(); if (_e) _o->refname = _e->str(); }
  { auto _e = effectfilename(); if (_e) _o->effectfilename = _e->str(); }
  { auto _e = colorLabel(); if (_e) _o->colorLabel = _e->str(); }
  { auto _e = mask_influence(); _o->mask_influence = _e; }
}

inline flatbuffers::Offset<PartData> PartData::Pack(flatbuffers::FlatBufferBuilder &_fbb, const PartDataT* _o, const flatbuffers::rehasher_function_t *_rehasher) {
  return CreatePartData(_fbb, _o, _rehasher);
}

inline flatbuffers::Offset<PartData> CreatePartData(flatbuffers::FlatBufferBuilder &_fbb, const PartDataT *_o, const flatbuffers::rehasher_function_t *_rehasher) {
  (void)_rehasher;
  (void)_o;
  struct _VectorArgs { flatbuffers::FlatBufferBuilder *__fbb; const PartDataT* __o; const flatbuffers::rehasher_function_t *__rehasher; } _va = { &_fbb, _o, _rehasher}; (void)_va;
  auto _name = _o->name.empty() ? 0 : _fbb.CreateString(_o->name);
  auto _index = _o->index;
  auto _parent_index = _o->parent_index;
  auto _type = _o->type;
  auto _bounds_type = _o->bounds_type;
  auto _alpha_blend_type = _o->alpha_blend_type;
  auto _refname = _o->refname.empty() ? 0 : _fbb.CreateString(_o->refname);
  auto _effectfilename = _o->effectfilename.empty() ? 0 : _fbb.CreateString(_o->effectfilename);
  auto _colorLabel = _o->colorLabel.empty() ? 0 : _fbb.CreateString(_o->colorLabel);
  auto _mask_influence = _o->mask_influence;
  return ss::ssfb::CreatePartData(
      _fbb,
      _name,
      _index,
      _parent_index,
      _type,
      _bounds_type,
      _alpha_blend_type,
      _refname,
      _effectfilename,
      _colorLabel,
      _mask_influence);
}


inline bool operator==(const AnimePackDataT &lhs, const AnimePackDataT &rhs) {
  return
      (lhs.name == rhs.name) &&
      (lhs.parts == rhs.parts) &&
      (lhs.animations == rhs.animations);
}

inline bool operator!=(const AnimePackDataT &lhs, const AnimePackDataT &rhs) {
    return !(lhs == rhs);
}


inline AnimePackDataT *AnimePackData::UnPack(const flatbuffers::resolver_function_t *_resolver) const {
  auto _o = std::unique_ptr<AnimePackDataT>(new AnimePackDataT());
  UnPackTo(_o.get(), _resolver);
  return _o.release();
}

inline void AnimePackData::UnPackTo(AnimePackDataT *_o, const flatbuffers::resolver_function_t *_resolver) const {
  (void)_o;
  (void)_resolver;
  { auto _e = name(); if (_e) _o->name = _e->str(); }
  { auto _e = parts(); if (_e) { _o->parts.resize(_e->size()); for (flatbuffers::uoffset_t _i = 0; _i < _e->size(); _i++) { if(_o->parts[_i]) { _e->Get(_i)->UnPackTo(_o->parts[_i].get(), _resolver); } else { _o->parts[_i] = std::unique_ptr<ss::ssfb::PartDataT>(_e->Get(_i)->UnPack(_resolver)); }; } } }
  { auto _e = animations(); if (_e) { _o->animations.resize(_e->size()); for (flatbuffers::uoffset_t _i = 0; _i < _e->size(); _i++) { if(_o->animations[_i]) { _e->Get(_i)->UnPackTo(_o->animations[_i].get(), _resolver); } else { _o->animations[_i] = std::unique_ptr<ss::ssfb::AnimationDataT>(_e->Get(_i)->UnPack(_resolver)); }; } } }
}

inline flatbuffers::Offset<AnimePackData> AnimePackData::Pack(flatbuffers::FlatBufferBuilder &_fbb, const AnimePackDataT* _o, const flatbuffers::rehasher_function_t *_rehasher) {
  return CreateAnimePackData(_fbb, _o, _rehasher);
}

inline flatbuffers::Offset<AnimePackData> CreateAnimePackData(flatbuffers::FlatBufferBuilder &_fbb, const AnimePackDataT *_o, const flatbuffers::rehasher_function_t *_rehasher) {
  (void)_rehasher;
  (void)_o;
  struct _VectorArgs { flatbuffers::FlatBufferBuilder *__fbb; const AnimePackDataT* __o; const flatbuffers::rehasher_function_t *__rehasher; } _va = { &_fbb, _o, _rehasher}; (void)_va;
  auto _name = _o->name.empty() ? 0 : _fbb.CreateString(_o->name);
  auto _parts = _o->parts.size() ? _fbb.CreateVector<flatbuffers::Offset<ss::ssfb::PartData>> (_o->parts.size(), [](size_t i, _VectorArgs *__va) { return CreatePartData(*__va->__fbb, __va->__o->parts[i].get(), __va->__rehasher); }, &_va ) : 0;
  auto _animations = _o->animations.size() ? _fbb.CreateVector<flatbuffers::Offset<ss::ssfb::AnimationData>> (_o->animations.size(), [](size_t i, _VectorArgs *__va) { return CreateAnimationData(*__va->__fbb, __va->__o->animations[i].get(), __va->__rehasher); }, &_va ) : 0;
  return ss::ssfb::CreateAnimePackData(
      _fbb,
      _name,
      _parts,
      _animations);
}


inline bool operator==(const ProjectDataT &lhs, const ProjectDataT &rhs) {
  return
      (lhs.dataId == rhs.dataId) &&
      (lhs.version == rhs.version) &&
      (lhs.flags == rhs.flags) &&
      (lhs.image_base_dir == rhs.image_base_dir) &&
      (lhs.cells == rhs.cells) &&
      (lhs.anime_packs == rhs.anime_packs) &&
      (lhs.effect_file_list == rhs.effect_file_list) &&
      (lhs.num_cells == rhs.num_cells) &&
      (lhs.num_animePacks == rhs.num_animePacks) &&
      (lhs.num_effectFileList == rhs.num_effectFileList);
}

inline bool operator!=(const ProjectDataT &lhs, const ProjectDataT &rhs) {
    return !(lhs == rhs);
}


inline ProjectDataT *ProjectData::UnPack(const flatbuffers::resolver_function_t *_resolver) const {
  auto _o = std::unique_ptr<ProjectDataT>(new ProjectDataT());
  UnPackTo(_o.get(), _resolver);
  return _o.release();
}

inline void ProjectData::UnPackTo(ProjectDataT *_o, const flatbuffers::resolver_function_t *_resolver) const {
  (void)_o;
  (void)_resolver;
  { auto _e = dataId(); _o->dataId = _e; }
  { auto _e = version(); _o->version = _e; }
  { auto _e = flags(); _o->flags = _e; }
  { auto _e = image_base_dir(); if (_e) _o->image_base_dir = _e->str(); }
  { auto _e = cells(); if (_e) { _o->cells.resize(_e->size()); for (flatbuffers::uoffset_t _i = 0; _i < _e->size(); _i++) { if(_o->cells[_i]) { _e->Get(_i)->UnPackTo(_o->cells[_i].get(), _resolver); } else { _o->cells[_i] = std::unique_ptr<ss::ssfb::CellT>(_e->Get(_i)->UnPack(_resolver)); }; } } }
  { auto _e = anime_packs(); if (_e) { _o->anime_packs.resize(_e->size()); for (flatbuffers::uoffset_t _i = 0; _i < _e->size(); _i++) { if(_o->anime_packs[_i]) { _e->Get(_i)->UnPackTo(_o->anime_packs[_i].get(), _resolver); } else { _o->anime_packs[_i] = std::unique_ptr<ss::ssfb::AnimePackDataT>(_e->Get(_i)->UnPack(_resolver)); }; } } }
  { auto _e = effect_file_list(); if (_e) { _o->effect_file_list.resize(_e->size()); for (flatbuffers::uoffset_t _i = 0; _i < _e->size(); _i++) { if(_o->effect_file_list[_i]) { _e->Get(_i)->UnPackTo(_o->effect_file_list[_i].get(), _resolver); } else { _o->effect_file_list[_i] = std::unique_ptr<ss::ssfb::EffectFileT>(_e->Get(_i)->UnPack(_resolver)); }; } } }
  { auto _e = num_cells(); _o->num_cells = _e; }
  { auto _e = num_animePacks(); _o->num_animePacks = _e; }
  { auto _e = num_effectFileList(); _o->num_effectFileList = _e; }
}

inline flatbuffers::Offset<ProjectData> ProjectData::Pack(flatbuffers::FlatBufferBuilder &_fbb, const ProjectDataT* _o, const flatbuffers::rehasher_function_t *_rehasher) {
  return CreateProjectData(_fbb, _o, _rehasher);
}

inline flatbuffers::Offset<ProjectData> CreateProjectData(flatbuffers::FlatBufferBuilder &_fbb, const ProjectDataT *_o, const flatbuffers::rehasher_function_t *_rehasher) {
  (void)_rehasher;
  (void)_o;
  struct _VectorArgs { flatbuffers::FlatBufferBuilder *__fbb; const ProjectDataT* __o; const flatbuffers::rehasher_function_t *__rehasher; } _va = { &_fbb, _o, _rehasher}; (void)_va;
  auto _dataId = _o->dataId;
  auto _version = _o->version;
  auto _flags = _o->flags;
  auto _image_base_dir = _o->image_base_dir.empty() ? 0 : _fbb.CreateString(_o->image_base_dir);
  auto _cells = _o->cells.size() ? _fbb.CreateVector<flatbuffers::Offset<ss::ssfb::Cell>> (_o->cells.size(), [](size_t i, _VectorArgs *__va) { return CreateCell(*__va->__fbb, __va->__o->cells[i].get(), __va->__rehasher); }, &_va ) : 0;
  auto _anime_packs = _o->anime_packs.size() ? _fbb.CreateVector<flatbuffers::Offset<ss::ssfb::AnimePackData>> (_o->anime_packs.size(), [](size_t i, _VectorArgs *__va) { return CreateAnimePackData(*__va->__fbb, __va->__o->anime_packs[i].get(), __va->__rehasher); }, &_va ) : 0;
  auto _effect_file_list = _o->effect_file_list.size() ? _fbb.CreateVector<flatbuffers::Offset<ss::ssfb::EffectFile>> (_o->effect_file_list.size(), [](size_t i, _VectorArgs *__va) { return CreateEffectFile(*__va->__fbb, __va->__o->effect_file_list[i].get(), __va->__rehasher); }, &_va ) : 0;
  auto _num_cells = _o->num_cells;
  auto _num_animePacks = _o->num_animePacks;
  auto _num_effectFileList = _o->num_effectFileList;
  return ss::ssfb::CreateProjectData(
      _fbb,
      _dataId,
      _version,
      _flags,
      _image_base_dir,
      _cells,
      _anime_packs,
      _effect_file_list,
      _num_cells,
      _num_animePacks,
      _num_effectFileList);
}

inline const ss::ssfb::ProjectData *GetProjectData(const void *buf) {
  return flatbuffers::GetRoot<ss::ssfb::ProjectData>(buf);
}

inline const ss::ssfb::ProjectData *GetSizePrefixedProjectData(const void *buf) {
  return flatbuffers::GetSizePrefixedRoot<ss::ssfb::ProjectData>(buf);
}

inline const char *ProjectDataIdentifier() {
  return "SSFB";
}

inline bool ProjectDataBufferHasIdentifier(const void *buf) {
  return flatbuffers::BufferHasIdentifier(
      buf, ProjectDataIdentifier());
}

inline bool VerifyProjectDataBuffer(
    flatbuffers::Verifier &verifier) {
  return verifier.VerifyBuffer<ss::ssfb::ProjectData>(ProjectDataIdentifier());
}

inline bool VerifySizePrefixedProjectDataBuffer(
    flatbuffers::Verifier &verifier) {
  return verifier.VerifySizePrefixedBuffer<ss::ssfb::ProjectData>(ProjectDataIdentifier());
}

inline void FinishProjectDataBuffer(
    flatbuffers::FlatBufferBuilder &fbb,
    flatbuffers::Offset<ss::ssfb::ProjectData> root) {
  fbb.Finish(root, ProjectDataIdentifier());
}

inline void FinishSizePrefixedProjectDataBuffer(
    flatbuffers::FlatBufferBuilder &fbb,
    flatbuffers::Offset<ss::ssfb::ProjectData> root) {
  fbb.FinishSizePrefixed(root, ProjectDataIdentifier());
}

inline std::unique_ptr<ss::ssfb::ProjectDataT> UnPackProjectData(
    const void *buf,
    const flatbuffers::resolver_function_t *res = nullptr) {
  return std::unique_ptr<ss::ssfb::ProjectDataT>(GetProjectData(buf)->UnPack(res));
}

inline std::unique_ptr<ss::ssfb::ProjectDataT> UnPackSizePrefixedProjectData(
    const void *buf,
    const flatbuffers::resolver_function_t *res = nullptr) {
  return std::unique_ptr<ss::ssfb::ProjectDataT>(GetSizePrefixedProjectData(buf)->UnPack(res));
}

}  // namespace ssfb
}  // namespace ss

#endif  // FLATBUFFERS_GENERATED_SSFB_SS_SSFB_H_
