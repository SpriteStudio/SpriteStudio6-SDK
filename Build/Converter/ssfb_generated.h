// automatically generated by the FlatBuffers compiler, do not modify


#ifndef FLATBUFFERS_GENERATED_SSFB_SS_SSFB_H_
#define FLATBUFFERS_GENERATED_SSFB_SS_SSFB_H_

#include "flatbuffers/flatbuffers.h"

namespace ss {
namespace ssfb {

struct EffectParticleInfiniteEmitEnabled;

struct EffectParticleTurnToDirectionEnabled;

struct EffectParticlePointGravity;

struct EffectParticleElementTransSize;

struct EffectParticleElementSize;

struct EffectParticleElementAlphaFade;

struct EffectParticleElementTransColor;

struct EffectParticleElementInitColor;

struct EffectParticleElementTangentialAcceleration;

struct EffectParticleElementTransSpeed;

struct EffectParticleElementRotationTrans;

struct EffectParticleElementRotation;

struct EffectParticleElementPosition;

struct EffectParticleElementGravity;

struct EffectParticleElementDelay;

struct EffectParticleElementRndSeedChange;

struct EffectParticleElementBasic;

struct EffectNode;

struct EffectFile;

struct CellMap;

struct Cell;

struct meshDataUV;

struct meshDataIndices;

struct frameDataIndex;

struct userDataInteger;

struct userDataRect;

struct userDataPoint;

struct userDataString;

struct userDataItem;

struct userDataPerFrame;

struct labelDataItem;

struct AnimationData;

struct AnimationInitialData;

struct PartData;

struct AnimePackData;

struct ProjectData;

enum SsPartType {
  SsPartType_Invalid = -1,
  SsPartType_Nulltype = 0,
  SsPartType_Normal = 1,
  SsPartType_Text = 2,
  SsPartType_Instance = 3,
  SsPartType_Armature = 4,
  SsPartType_Effect = 5,
  SsPartType_Mesh = 6,
  SsPartType_Movenode = 7,
  SsPartType_Constraint = 8,
  SsPartType_Mask = 9,
  SsPartType_Joint = 10,
  SsPartType_Bonepoint = 11,
  SsPartType_MIN = SsPartType_Invalid,
  SsPartType_MAX = SsPartType_Bonepoint
};

inline const SsPartType (&EnumValuesSsPartType())[13] {
  static const SsPartType values[] = {
    SsPartType_Invalid,
    SsPartType_Nulltype,
    SsPartType_Normal,
    SsPartType_Text,
    SsPartType_Instance,
    SsPartType_Armature,
    SsPartType_Effect,
    SsPartType_Mesh,
    SsPartType_Movenode,
    SsPartType_Constraint,
    SsPartType_Mask,
    SsPartType_Joint,
    SsPartType_Bonepoint
  };
  return values;
}

inline const char * const *EnumNamesSsPartType() {
  static const char * const names[] = {
    "Invalid",
    "Nulltype",
    "Normal",
    "Text",
    "Instance",
    "Armature",
    "Effect",
    "Mesh",
    "Movenode",
    "Constraint",
    "Mask",
    "Joint",
    "Bonepoint",
    nullptr
  };
  return names;
}

inline const char *EnumNameSsPartType(SsPartType e) {
  const size_t index = static_cast<int>(e) - static_cast<int>(SsPartType_Invalid);
  return EnumNamesSsPartType()[index];
}

enum PART_FLAG {
  PART_FLAG_INVISIBLE = 1,
  PART_FLAG_FLIP_H = 2,
  PART_FLAG_FLIP_V = 4,
  PART_FLAG_CELL_INDEX = 8,
  PART_FLAG_POSITION_X = 16,
  PART_FLAG_POSITION_Y = 32,
  PART_FLAG_POSITION_Z = 64,
  PART_FLAG_PIVOT_X = 128,
  PART_FLAG_PIVOT_Y = 256,
  PART_FLAG_ROTATIONX = 512,
  PART_FLAG_ROTATIONY = 1024,
  PART_FLAG_ROTATIONZ = 2048,
  PART_FLAG_SCALE_X = 4096,
  PART_FLAG_SCALE_Y = 8192,
  PART_FLAG_LOCALSCALE_X = 16384,
  PART_FLAG_LOCALSCALE_Y = 32768,
  PART_FLAG_OPACITY = 65536,
  PART_FLAG_LOCALOPACITY = 131072,
  PART_FLAG_PARTS_COLOR = 262144,
  PART_FLAG_VERTEX_TRANSFORM = 524288,
  PART_FLAG_SIZE_X = 1048576,
  PART_FLAG_SIZE_Y = 2097152,
  PART_FLAG_U_MOVE = 4194304,
  PART_FLAG_V_MOVE = 8388608,
  PART_FLAG_UV_ROTATION = 16777216,
  PART_FLAG_U_SCALE = 33554432,
  PART_FLAG_V_SCALE = 67108864,
  PART_FLAG_BOUNDINGRADIUS = 134217728,
  PART_FLAG_MASK = 268435456,
  PART_FLAG_PRIORITY = 536870912,
  PART_FLAG_INSTANCE_KEYFRAME = 1073741824,
  PART_FLAG_EFFECT_KEYFRAME = 2147483648,
  PART_FLAG_NONE = 0,
  PART_FLAG_ANY = 4294967295
};

inline const PART_FLAG (&EnumValuesPART_FLAG())[32] {
  static const PART_FLAG values[] = {
    PART_FLAG_INVISIBLE,
    PART_FLAG_FLIP_H,
    PART_FLAG_FLIP_V,
    PART_FLAG_CELL_INDEX,
    PART_FLAG_POSITION_X,
    PART_FLAG_POSITION_Y,
    PART_FLAG_POSITION_Z,
    PART_FLAG_PIVOT_X,
    PART_FLAG_PIVOT_Y,
    PART_FLAG_ROTATIONX,
    PART_FLAG_ROTATIONY,
    PART_FLAG_ROTATIONZ,
    PART_FLAG_SCALE_X,
    PART_FLAG_SCALE_Y,
    PART_FLAG_LOCALSCALE_X,
    PART_FLAG_LOCALSCALE_Y,
    PART_FLAG_OPACITY,
    PART_FLAG_LOCALOPACITY,
    PART_FLAG_PARTS_COLOR,
    PART_FLAG_VERTEX_TRANSFORM,
    PART_FLAG_SIZE_X,
    PART_FLAG_SIZE_Y,
    PART_FLAG_U_MOVE,
    PART_FLAG_V_MOVE,
    PART_FLAG_UV_ROTATION,
    PART_FLAG_U_SCALE,
    PART_FLAG_V_SCALE,
    PART_FLAG_BOUNDINGRADIUS,
    PART_FLAG_MASK,
    PART_FLAG_PRIORITY,
    PART_FLAG_INSTANCE_KEYFRAME,
    PART_FLAG_EFFECT_KEYFRAME
  };
  return values;
}

inline const char *EnumNamePART_FLAG(PART_FLAG e) {
  switch (e) {
    case PART_FLAG_INVISIBLE: return "INVISIBLE";
    case PART_FLAG_FLIP_H: return "FLIP_H";
    case PART_FLAG_FLIP_V: return "FLIP_V";
    case PART_FLAG_CELL_INDEX: return "CELL_INDEX";
    case PART_FLAG_POSITION_X: return "POSITION_X";
    case PART_FLAG_POSITION_Y: return "POSITION_Y";
    case PART_FLAG_POSITION_Z: return "POSITION_Z";
    case PART_FLAG_PIVOT_X: return "PIVOT_X";
    case PART_FLAG_PIVOT_Y: return "PIVOT_Y";
    case PART_FLAG_ROTATIONX: return "ROTATIONX";
    case PART_FLAG_ROTATIONY: return "ROTATIONY";
    case PART_FLAG_ROTATIONZ: return "ROTATIONZ";
    case PART_FLAG_SCALE_X: return "SCALE_X";
    case PART_FLAG_SCALE_Y: return "SCALE_Y";
    case PART_FLAG_LOCALSCALE_X: return "LOCALSCALE_X";
    case PART_FLAG_LOCALSCALE_Y: return "LOCALSCALE_Y";
    case PART_FLAG_OPACITY: return "OPACITY";
    case PART_FLAG_LOCALOPACITY: return "LOCALOPACITY";
    case PART_FLAG_PARTS_COLOR: return "PARTS_COLOR";
    case PART_FLAG_VERTEX_TRANSFORM: return "VERTEX_TRANSFORM";
    case PART_FLAG_SIZE_X: return "SIZE_X";
    case PART_FLAG_SIZE_Y: return "SIZE_Y";
    case PART_FLAG_U_MOVE: return "U_MOVE";
    case PART_FLAG_V_MOVE: return "V_MOVE";
    case PART_FLAG_UV_ROTATION: return "UV_ROTATION";
    case PART_FLAG_U_SCALE: return "U_SCALE";
    case PART_FLAG_V_SCALE: return "V_SCALE";
    case PART_FLAG_BOUNDINGRADIUS: return "BOUNDINGRADIUS";
    case PART_FLAG_MASK: return "MASK";
    case PART_FLAG_PRIORITY: return "PRIORITY";
    case PART_FLAG_INSTANCE_KEYFRAME: return "INSTANCE_KEYFRAME";
    case PART_FLAG_EFFECT_KEYFRAME: return "EFFECT_KEYFRAME";
    default: return "";
  }
}

enum PART_FLAG2 {
  PART_FLAG2_MESHDATA = 1,
  PART_FLAG2_NONE = 0,
  PART_FLAG2_ANY = 1
};

inline const PART_FLAG2 (&EnumValuesPART_FLAG2())[1] {
  static const PART_FLAG2 values[] = {
    PART_FLAG2_MESHDATA
  };
  return values;
}

inline const char * const *EnumNamesPART_FLAG2() {
  static const char * const names[] = {
    "MESHDATA",
    nullptr
  };
  return names;
}

inline const char *EnumNamePART_FLAG2(PART_FLAG2 e) {
  const size_t index = static_cast<int>(e) - static_cast<int>(PART_FLAG2_MESHDATA);
  return EnumNamesPART_FLAG2()[index];
}

enum VERTEX_FLAG {
  VERTEX_FLAG_LT = 1,
  VERTEX_FLAG_RT = 2,
  VERTEX_FLAG_LB = 4,
  VERTEX_FLAG_RB = 8,
  VERTEX_FLAG_ONE = 16,
  VERTEX_FLAG_NONE = 0,
  VERTEX_FLAG_ANY = 31
};

inline const VERTEX_FLAG (&EnumValuesVERTEX_FLAG())[5] {
  static const VERTEX_FLAG values[] = {
    VERTEX_FLAG_LT,
    VERTEX_FLAG_RT,
    VERTEX_FLAG_LB,
    VERTEX_FLAG_RB,
    VERTEX_FLAG_ONE
  };
  return values;
}

inline const char * const *EnumNamesVERTEX_FLAG() {
  static const char * const names[] = {
    "LT",
    "RT",
    "",
    "LB",
    "",
    "",
    "",
    "RB",
    "",
    "",
    "",
    "",
    "",
    "",
    "",
    "ONE",
    nullptr
  };
  return names;
}

inline const char *EnumNameVERTEX_FLAG(VERTEX_FLAG e) {
  const size_t index = static_cast<int>(e) - static_cast<int>(VERTEX_FLAG_LT);
  return EnumNamesVERTEX_FLAG()[index];
}

enum EffectNodeBehavior {
  EffectNodeBehavior_NONE = 0,
  EffectNodeBehavior_EffectParticleElementBasic = 1,
  EffectNodeBehavior_EffectParticleElementRndSeedChange = 2,
  EffectNodeBehavior_EffectParticleElementDelay = 3,
  EffectNodeBehavior_EffectParticleElementGravity = 4,
  EffectNodeBehavior_EffectParticleElementPosition = 5,
  EffectNodeBehavior_EffectParticleElementRotation = 6,
  EffectNodeBehavior_EffectParticleElementRotationTrans = 7,
  EffectNodeBehavior_EffectParticleElementTransSpeed = 8,
  EffectNodeBehavior_EffectParticleElementTangentialAcceleration = 9,
  EffectNodeBehavior_EffectParticleElementInitColor = 10,
  EffectNodeBehavior_EffectParticleElementTransColor = 11,
  EffectNodeBehavior_EffectParticleElementAlphaFade = 12,
  EffectNodeBehavior_EffectParticleElementSize = 13,
  EffectNodeBehavior_EffectParticleElementTransSize = 14,
  EffectNodeBehavior_EffectParticlePointGravity = 15,
  EffectNodeBehavior_EffectParticleTurnToDirectionEnabled = 16,
  EffectNodeBehavior_EffectParticleInfiniteEmitEnabled = 17,
  EffectNodeBehavior_MIN = EffectNodeBehavior_NONE,
  EffectNodeBehavior_MAX = EffectNodeBehavior_EffectParticleInfiniteEmitEnabled
};

inline const EffectNodeBehavior (&EnumValuesEffectNodeBehavior())[18] {
  static const EffectNodeBehavior values[] = {
    EffectNodeBehavior_NONE,
    EffectNodeBehavior_EffectParticleElementBasic,
    EffectNodeBehavior_EffectParticleElementRndSeedChange,
    EffectNodeBehavior_EffectParticleElementDelay,
    EffectNodeBehavior_EffectParticleElementGravity,
    EffectNodeBehavior_EffectParticleElementPosition,
    EffectNodeBehavior_EffectParticleElementRotation,
    EffectNodeBehavior_EffectParticleElementRotationTrans,
    EffectNodeBehavior_EffectParticleElementTransSpeed,
    EffectNodeBehavior_EffectParticleElementTangentialAcceleration,
    EffectNodeBehavior_EffectParticleElementInitColor,
    EffectNodeBehavior_EffectParticleElementTransColor,
    EffectNodeBehavior_EffectParticleElementAlphaFade,
    EffectNodeBehavior_EffectParticleElementSize,
    EffectNodeBehavior_EffectParticleElementTransSize,
    EffectNodeBehavior_EffectParticlePointGravity,
    EffectNodeBehavior_EffectParticleTurnToDirectionEnabled,
    EffectNodeBehavior_EffectParticleInfiniteEmitEnabled
  };
  return values;
}

inline const char * const *EnumNamesEffectNodeBehavior() {
  static const char * const names[] = {
    "NONE",
    "EffectParticleElementBasic",
    "EffectParticleElementRndSeedChange",
    "EffectParticleElementDelay",
    "EffectParticleElementGravity",
    "EffectParticleElementPosition",
    "EffectParticleElementRotation",
    "EffectParticleElementRotationTrans",
    "EffectParticleElementTransSpeed",
    "EffectParticleElementTangentialAcceleration",
    "EffectParticleElementInitColor",
    "EffectParticleElementTransColor",
    "EffectParticleElementAlphaFade",
    "EffectParticleElementSize",
    "EffectParticleElementTransSize",
    "EffectParticlePointGravity",
    "EffectParticleTurnToDirectionEnabled",
    "EffectParticleInfiniteEmitEnabled",
    nullptr
  };
  return names;
}

inline const char *EnumNameEffectNodeBehavior(EffectNodeBehavior e) {
  const size_t index = static_cast<int>(e);
  return EnumNamesEffectNodeBehavior()[index];
}

template<typename T> struct EffectNodeBehaviorTraits {
  static const EffectNodeBehavior enum_value = EffectNodeBehavior_NONE;
};

template<> struct EffectNodeBehaviorTraits<EffectParticleElementBasic> {
  static const EffectNodeBehavior enum_value = EffectNodeBehavior_EffectParticleElementBasic;
};

template<> struct EffectNodeBehaviorTraits<EffectParticleElementRndSeedChange> {
  static const EffectNodeBehavior enum_value = EffectNodeBehavior_EffectParticleElementRndSeedChange;
};

template<> struct EffectNodeBehaviorTraits<EffectParticleElementDelay> {
  static const EffectNodeBehavior enum_value = EffectNodeBehavior_EffectParticleElementDelay;
};

template<> struct EffectNodeBehaviorTraits<EffectParticleElementGravity> {
  static const EffectNodeBehavior enum_value = EffectNodeBehavior_EffectParticleElementGravity;
};

template<> struct EffectNodeBehaviorTraits<EffectParticleElementPosition> {
  static const EffectNodeBehavior enum_value = EffectNodeBehavior_EffectParticleElementPosition;
};

template<> struct EffectNodeBehaviorTraits<EffectParticleElementRotation> {
  static const EffectNodeBehavior enum_value = EffectNodeBehavior_EffectParticleElementRotation;
};

template<> struct EffectNodeBehaviorTraits<EffectParticleElementRotationTrans> {
  static const EffectNodeBehavior enum_value = EffectNodeBehavior_EffectParticleElementRotationTrans;
};

template<> struct EffectNodeBehaviorTraits<EffectParticleElementTransSpeed> {
  static const EffectNodeBehavior enum_value = EffectNodeBehavior_EffectParticleElementTransSpeed;
};

template<> struct EffectNodeBehaviorTraits<EffectParticleElementTangentialAcceleration> {
  static const EffectNodeBehavior enum_value = EffectNodeBehavior_EffectParticleElementTangentialAcceleration;
};

template<> struct EffectNodeBehaviorTraits<EffectParticleElementInitColor> {
  static const EffectNodeBehavior enum_value = EffectNodeBehavior_EffectParticleElementInitColor;
};

template<> struct EffectNodeBehaviorTraits<EffectParticleElementTransColor> {
  static const EffectNodeBehavior enum_value = EffectNodeBehavior_EffectParticleElementTransColor;
};

template<> struct EffectNodeBehaviorTraits<EffectParticleElementAlphaFade> {
  static const EffectNodeBehavior enum_value = EffectNodeBehavior_EffectParticleElementAlphaFade;
};

template<> struct EffectNodeBehaviorTraits<EffectParticleElementSize> {
  static const EffectNodeBehavior enum_value = EffectNodeBehavior_EffectParticleElementSize;
};

template<> struct EffectNodeBehaviorTraits<EffectParticleElementTransSize> {
  static const EffectNodeBehavior enum_value = EffectNodeBehavior_EffectParticleElementTransSize;
};

template<> struct EffectNodeBehaviorTraits<EffectParticlePointGravity> {
  static const EffectNodeBehavior enum_value = EffectNodeBehavior_EffectParticlePointGravity;
};

template<> struct EffectNodeBehaviorTraits<EffectParticleTurnToDirectionEnabled> {
  static const EffectNodeBehavior enum_value = EffectNodeBehavior_EffectParticleTurnToDirectionEnabled;
};

template<> struct EffectNodeBehaviorTraits<EffectParticleInfiniteEmitEnabled> {
  static const EffectNodeBehavior enum_value = EffectNodeBehavior_EffectParticleInfiniteEmitEnabled;
};

bool VerifyEffectNodeBehavior(flatbuffers::Verifier &verifier, const void *obj, EffectNodeBehavior type);
bool VerifyEffectNodeBehaviorVector(flatbuffers::Verifier &verifier, const flatbuffers::Vector<flatbuffers::Offset<void>> *values, const flatbuffers::Vector<uint8_t> *types);

enum userDataValue {
  userDataValue_NONE = 0,
  userDataValue_userDataInteger = 1,
  userDataValue_userDataRect = 2,
  userDataValue_userDataPoint = 3,
  userDataValue_userDataString = 4,
  userDataValue_MIN = userDataValue_NONE,
  userDataValue_MAX = userDataValue_userDataString
};

inline const userDataValue (&EnumValuesuserDataValue())[5] {
  static const userDataValue values[] = {
    userDataValue_NONE,
    userDataValue_userDataInteger,
    userDataValue_userDataRect,
    userDataValue_userDataPoint,
    userDataValue_userDataString
  };
  return values;
}

inline const char * const *EnumNamesuserDataValue() {
  static const char * const names[] = {
    "NONE",
    "userDataInteger",
    "userDataRect",
    "userDataPoint",
    "userDataString",
    nullptr
  };
  return names;
}

inline const char *EnumNameuserDataValue(userDataValue e) {
  const size_t index = static_cast<int>(e);
  return EnumNamesuserDataValue()[index];
}

template<typename T> struct userDataValueTraits {
  static const userDataValue enum_value = userDataValue_NONE;
};

template<> struct userDataValueTraits<userDataInteger> {
  static const userDataValue enum_value = userDataValue_userDataInteger;
};

template<> struct userDataValueTraits<userDataRect> {
  static const userDataValue enum_value = userDataValue_userDataRect;
};

template<> struct userDataValueTraits<userDataPoint> {
  static const userDataValue enum_value = userDataValue_userDataPoint;
};

template<> struct userDataValueTraits<userDataString> {
  static const userDataValue enum_value = userDataValue_userDataString;
};

bool VerifyuserDataValue(flatbuffers::Verifier &verifier, const void *obj, userDataValue type);
bool VerifyuserDataValueVector(flatbuffers::Verifier &verifier, const flatbuffers::Vector<flatbuffers::Offset<void>> *values, const flatbuffers::Vector<uint8_t> *types);

FLATBUFFERS_MANUALLY_ALIGNED_STRUCT(4) EffectParticleInfiniteEmitEnabled FLATBUFFERS_FINAL_CLASS {
 private:
  int32_t flag_;

 public:
  EffectParticleInfiniteEmitEnabled() {
    memset(this, 0, sizeof(EffectParticleInfiniteEmitEnabled));
  }
  EffectParticleInfiniteEmitEnabled(int32_t _flag)
      : flag_(flatbuffers::EndianScalar(_flag)) {
  }
  int32_t flag() const {
    return flatbuffers::EndianScalar(flag_);
  }
};
FLATBUFFERS_STRUCT_END(EffectParticleInfiniteEmitEnabled, 4);

FLATBUFFERS_MANUALLY_ALIGNED_STRUCT(4) EffectParticleTurnToDirectionEnabled FLATBUFFERS_FINAL_CLASS {
 private:
  float Rotation_;

 public:
  EffectParticleTurnToDirectionEnabled() {
    memset(this, 0, sizeof(EffectParticleTurnToDirectionEnabled));
  }
  EffectParticleTurnToDirectionEnabled(float _Rotation)
      : Rotation_(flatbuffers::EndianScalar(_Rotation)) {
  }
  float Rotation() const {
    return flatbuffers::EndianScalar(Rotation_);
  }
};
FLATBUFFERS_STRUCT_END(EffectParticleTurnToDirectionEnabled, 4);

FLATBUFFERS_MANUALLY_ALIGNED_STRUCT(4) EffectParticlePointGravity FLATBUFFERS_FINAL_CLASS {
 private:
  float Position_x_;
  float Position_y_;
  float Power_;

 public:
  EffectParticlePointGravity() {
    memset(this, 0, sizeof(EffectParticlePointGravity));
  }
  EffectParticlePointGravity(float _Position_x, float _Position_y, float _Power)
      : Position_x_(flatbuffers::EndianScalar(_Position_x)),
        Position_y_(flatbuffers::EndianScalar(_Position_y)),
        Power_(flatbuffers::EndianScalar(_Power)) {
  }
  float Position_x() const {
    return flatbuffers::EndianScalar(Position_x_);
  }
  float Position_y() const {
    return flatbuffers::EndianScalar(Position_y_);
  }
  float Power() const {
    return flatbuffers::EndianScalar(Power_);
  }
};
FLATBUFFERS_STRUCT_END(EffectParticlePointGravity, 12);

FLATBUFFERS_MANUALLY_ALIGNED_STRUCT(4) EffectParticleElementTransSize FLATBUFFERS_FINAL_CLASS {
 private:
  float SizeXMinValue_;
  float SizeXMaxValue_;
  float SizeYMinValue_;
  float SizeYMaxValue_;
  float ScaleFactorMinValue_;
  float ScaleFactorMaxValue_;

 public:
  EffectParticleElementTransSize() {
    memset(this, 0, sizeof(EffectParticleElementTransSize));
  }
  EffectParticleElementTransSize(float _SizeXMinValue, float _SizeXMaxValue, float _SizeYMinValue, float _SizeYMaxValue, float _ScaleFactorMinValue, float _ScaleFactorMaxValue)
      : SizeXMinValue_(flatbuffers::EndianScalar(_SizeXMinValue)),
        SizeXMaxValue_(flatbuffers::EndianScalar(_SizeXMaxValue)),
        SizeYMinValue_(flatbuffers::EndianScalar(_SizeYMinValue)),
        SizeYMaxValue_(flatbuffers::EndianScalar(_SizeYMaxValue)),
        ScaleFactorMinValue_(flatbuffers::EndianScalar(_ScaleFactorMinValue)),
        ScaleFactorMaxValue_(flatbuffers::EndianScalar(_ScaleFactorMaxValue)) {
  }
  float SizeXMinValue() const {
    return flatbuffers::EndianScalar(SizeXMinValue_);
  }
  float SizeXMaxValue() const {
    return flatbuffers::EndianScalar(SizeXMaxValue_);
  }
  float SizeYMinValue() const {
    return flatbuffers::EndianScalar(SizeYMinValue_);
  }
  float SizeYMaxValue() const {
    return flatbuffers::EndianScalar(SizeYMaxValue_);
  }
  float ScaleFactorMinValue() const {
    return flatbuffers::EndianScalar(ScaleFactorMinValue_);
  }
  float ScaleFactorMaxValue() const {
    return flatbuffers::EndianScalar(ScaleFactorMaxValue_);
  }
};
FLATBUFFERS_STRUCT_END(EffectParticleElementTransSize, 24);

FLATBUFFERS_MANUALLY_ALIGNED_STRUCT(4) EffectParticleElementSize FLATBUFFERS_FINAL_CLASS {
 private:
  float SizeXMinValue_;
  float SizeXMaxValue_;
  float SizeYMinValue_;
  float SizeYMaxValue_;
  float ScaleFactorMinValue_;
  float ScaleFactorMaxValue_;

 public:
  EffectParticleElementSize() {
    memset(this, 0, sizeof(EffectParticleElementSize));
  }
  EffectParticleElementSize(float _SizeXMinValue, float _SizeXMaxValue, float _SizeYMinValue, float _SizeYMaxValue, float _ScaleFactorMinValue, float _ScaleFactorMaxValue)
      : SizeXMinValue_(flatbuffers::EndianScalar(_SizeXMinValue)),
        SizeXMaxValue_(flatbuffers::EndianScalar(_SizeXMaxValue)),
        SizeYMinValue_(flatbuffers::EndianScalar(_SizeYMinValue)),
        SizeYMaxValue_(flatbuffers::EndianScalar(_SizeYMaxValue)),
        ScaleFactorMinValue_(flatbuffers::EndianScalar(_ScaleFactorMinValue)),
        ScaleFactorMaxValue_(flatbuffers::EndianScalar(_ScaleFactorMaxValue)) {
  }
  float SizeXMinValue() const {
    return flatbuffers::EndianScalar(SizeXMinValue_);
  }
  float SizeXMaxValue() const {
    return flatbuffers::EndianScalar(SizeXMaxValue_);
  }
  float SizeYMinValue() const {
    return flatbuffers::EndianScalar(SizeYMinValue_);
  }
  float SizeYMaxValue() const {
    return flatbuffers::EndianScalar(SizeYMaxValue_);
  }
  float ScaleFactorMinValue() const {
    return flatbuffers::EndianScalar(ScaleFactorMinValue_);
  }
  float ScaleFactorMaxValue() const {
    return flatbuffers::EndianScalar(ScaleFactorMaxValue_);
  }
};
FLATBUFFERS_STRUCT_END(EffectParticleElementSize, 24);

FLATBUFFERS_MANUALLY_ALIGNED_STRUCT(4) EffectParticleElementAlphaFade FLATBUFFERS_FINAL_CLASS {
 private:
  float disprangeMinValue_;
  float disprangeMaxValue_;

 public:
  EffectParticleElementAlphaFade() {
    memset(this, 0, sizeof(EffectParticleElementAlphaFade));
  }
  EffectParticleElementAlphaFade(float _disprangeMinValue, float _disprangeMaxValue)
      : disprangeMinValue_(flatbuffers::EndianScalar(_disprangeMinValue)),
        disprangeMaxValue_(flatbuffers::EndianScalar(_disprangeMaxValue)) {
  }
  float disprangeMinValue() const {
    return flatbuffers::EndianScalar(disprangeMinValue_);
  }
  float disprangeMaxValue() const {
    return flatbuffers::EndianScalar(disprangeMaxValue_);
  }
};
FLATBUFFERS_STRUCT_END(EffectParticleElementAlphaFade, 8);

FLATBUFFERS_MANUALLY_ALIGNED_STRUCT(4) EffectParticleElementTransColor FLATBUFFERS_FINAL_CLASS {
 private:
  uint32_t ColorMinValue_;
  uint32_t ColorMaxValue_;

 public:
  EffectParticleElementTransColor() {
    memset(this, 0, sizeof(EffectParticleElementTransColor));
  }
  EffectParticleElementTransColor(uint32_t _ColorMinValue, uint32_t _ColorMaxValue)
      : ColorMinValue_(flatbuffers::EndianScalar(_ColorMinValue)),
        ColorMaxValue_(flatbuffers::EndianScalar(_ColorMaxValue)) {
  }
  uint32_t ColorMinValue() const {
    return flatbuffers::EndianScalar(ColorMinValue_);
  }
  uint32_t ColorMaxValue() const {
    return flatbuffers::EndianScalar(ColorMaxValue_);
  }
};
FLATBUFFERS_STRUCT_END(EffectParticleElementTransColor, 8);

FLATBUFFERS_MANUALLY_ALIGNED_STRUCT(4) EffectParticleElementInitColor FLATBUFFERS_FINAL_CLASS {
 private:
  uint32_t ColorMinValue_;
  uint32_t ColorMaxValue_;

 public:
  EffectParticleElementInitColor() {
    memset(this, 0, sizeof(EffectParticleElementInitColor));
  }
  EffectParticleElementInitColor(uint32_t _ColorMinValue, uint32_t _ColorMaxValue)
      : ColorMinValue_(flatbuffers::EndianScalar(_ColorMinValue)),
        ColorMaxValue_(flatbuffers::EndianScalar(_ColorMaxValue)) {
  }
  uint32_t ColorMinValue() const {
    return flatbuffers::EndianScalar(ColorMinValue_);
  }
  uint32_t ColorMaxValue() const {
    return flatbuffers::EndianScalar(ColorMaxValue_);
  }
};
FLATBUFFERS_STRUCT_END(EffectParticleElementInitColor, 8);

FLATBUFFERS_MANUALLY_ALIGNED_STRUCT(4) EffectParticleElementTangentialAcceleration FLATBUFFERS_FINAL_CLASS {
 private:
  float AccelerationMinValue_;
  float AccelerationMaxValue_;

 public:
  EffectParticleElementTangentialAcceleration() {
    memset(this, 0, sizeof(EffectParticleElementTangentialAcceleration));
  }
  EffectParticleElementTangentialAcceleration(float _AccelerationMinValue, float _AccelerationMaxValue)
      : AccelerationMinValue_(flatbuffers::EndianScalar(_AccelerationMinValue)),
        AccelerationMaxValue_(flatbuffers::EndianScalar(_AccelerationMaxValue)) {
  }
  float AccelerationMinValue() const {
    return flatbuffers::EndianScalar(AccelerationMinValue_);
  }
  float AccelerationMaxValue() const {
    return flatbuffers::EndianScalar(AccelerationMaxValue_);
  }
};
FLATBUFFERS_STRUCT_END(EffectParticleElementTangentialAcceleration, 8);

FLATBUFFERS_MANUALLY_ALIGNED_STRUCT(4) EffectParticleElementTransSpeed FLATBUFFERS_FINAL_CLASS {
 private:
  float SpeedMinValue_;
  float SpeedMaxValue_;

 public:
  EffectParticleElementTransSpeed() {
    memset(this, 0, sizeof(EffectParticleElementTransSpeed));
  }
  EffectParticleElementTransSpeed(float _SpeedMinValue, float _SpeedMaxValue)
      : SpeedMinValue_(flatbuffers::EndianScalar(_SpeedMinValue)),
        SpeedMaxValue_(flatbuffers::EndianScalar(_SpeedMaxValue)) {
  }
  float SpeedMinValue() const {
    return flatbuffers::EndianScalar(SpeedMinValue_);
  }
  float SpeedMaxValue() const {
    return flatbuffers::EndianScalar(SpeedMaxValue_);
  }
};
FLATBUFFERS_STRUCT_END(EffectParticleElementTransSpeed, 8);

FLATBUFFERS_MANUALLY_ALIGNED_STRUCT(4) EffectParticleElementRotationTrans FLATBUFFERS_FINAL_CLASS {
 private:
  float RotationFactor_;
  float EndLifeTimePer_;

 public:
  EffectParticleElementRotationTrans() {
    memset(this, 0, sizeof(EffectParticleElementRotationTrans));
  }
  EffectParticleElementRotationTrans(float _RotationFactor, float _EndLifeTimePer)
      : RotationFactor_(flatbuffers::EndianScalar(_RotationFactor)),
        EndLifeTimePer_(flatbuffers::EndianScalar(_EndLifeTimePer)) {
  }
  float RotationFactor() const {
    return flatbuffers::EndianScalar(RotationFactor_);
  }
  float EndLifeTimePer() const {
    return flatbuffers::EndianScalar(EndLifeTimePer_);
  }
};
FLATBUFFERS_STRUCT_END(EffectParticleElementRotationTrans, 8);

FLATBUFFERS_MANUALLY_ALIGNED_STRUCT(4) EffectParticleElementRotation FLATBUFFERS_FINAL_CLASS {
 private:
  float RotationMinValue_;
  float RotationMaxValue_;
  float RotationAddMinValue_;
  float RotationAddMaxValue_;

 public:
  EffectParticleElementRotation() {
    memset(this, 0, sizeof(EffectParticleElementRotation));
  }
  EffectParticleElementRotation(float _RotationMinValue, float _RotationMaxValue, float _RotationAddMinValue, float _RotationAddMaxValue)
      : RotationMinValue_(flatbuffers::EndianScalar(_RotationMinValue)),
        RotationMaxValue_(flatbuffers::EndianScalar(_RotationMaxValue)),
        RotationAddMinValue_(flatbuffers::EndianScalar(_RotationAddMinValue)),
        RotationAddMaxValue_(flatbuffers::EndianScalar(_RotationAddMaxValue)) {
  }
  float RotationMinValue() const {
    return flatbuffers::EndianScalar(RotationMinValue_);
  }
  float RotationMaxValue() const {
    return flatbuffers::EndianScalar(RotationMaxValue_);
  }
  float RotationAddMinValue() const {
    return flatbuffers::EndianScalar(RotationAddMinValue_);
  }
  float RotationAddMaxValue() const {
    return flatbuffers::EndianScalar(RotationAddMaxValue_);
  }
};
FLATBUFFERS_STRUCT_END(EffectParticleElementRotation, 16);

FLATBUFFERS_MANUALLY_ALIGNED_STRUCT(4) EffectParticleElementPosition FLATBUFFERS_FINAL_CLASS {
 private:
  float OffsetXMinValue_;
  float OffsetXMaxValue_;
  float OffsetYMinValue_;
  float OffsetYMaxValue_;

 public:
  EffectParticleElementPosition() {
    memset(this, 0, sizeof(EffectParticleElementPosition));
  }
  EffectParticleElementPosition(float _OffsetXMinValue, float _OffsetXMaxValue, float _OffsetYMinValue, float _OffsetYMaxValue)
      : OffsetXMinValue_(flatbuffers::EndianScalar(_OffsetXMinValue)),
        OffsetXMaxValue_(flatbuffers::EndianScalar(_OffsetXMaxValue)),
        OffsetYMinValue_(flatbuffers::EndianScalar(_OffsetYMinValue)),
        OffsetYMaxValue_(flatbuffers::EndianScalar(_OffsetYMaxValue)) {
  }
  float OffsetXMinValue() const {
    return flatbuffers::EndianScalar(OffsetXMinValue_);
  }
  float OffsetXMaxValue() const {
    return flatbuffers::EndianScalar(OffsetXMaxValue_);
  }
  float OffsetYMinValue() const {
    return flatbuffers::EndianScalar(OffsetYMinValue_);
  }
  float OffsetYMaxValue() const {
    return flatbuffers::EndianScalar(OffsetYMaxValue_);
  }
};
FLATBUFFERS_STRUCT_END(EffectParticleElementPosition, 16);

FLATBUFFERS_MANUALLY_ALIGNED_STRUCT(4) EffectParticleElementGravity FLATBUFFERS_FINAL_CLASS {
 private:
  float Gravity_x_;
  float Gravity_y_;

 public:
  EffectParticleElementGravity() {
    memset(this, 0, sizeof(EffectParticleElementGravity));
  }
  EffectParticleElementGravity(float _Gravity_x, float _Gravity_y)
      : Gravity_x_(flatbuffers::EndianScalar(_Gravity_x)),
        Gravity_y_(flatbuffers::EndianScalar(_Gravity_y)) {
  }
  float Gravity_x() const {
    return flatbuffers::EndianScalar(Gravity_x_);
  }
  float Gravity_y() const {
    return flatbuffers::EndianScalar(Gravity_y_);
  }
};
FLATBUFFERS_STRUCT_END(EffectParticleElementGravity, 8);

FLATBUFFERS_MANUALLY_ALIGNED_STRUCT(4) EffectParticleElementDelay FLATBUFFERS_FINAL_CLASS {
 private:
  int32_t DelayTime_;

 public:
  EffectParticleElementDelay() {
    memset(this, 0, sizeof(EffectParticleElementDelay));
  }
  EffectParticleElementDelay(int32_t _DelayTime)
      : DelayTime_(flatbuffers::EndianScalar(_DelayTime)) {
  }
  int32_t DelayTime() const {
    return flatbuffers::EndianScalar(DelayTime_);
  }
};
FLATBUFFERS_STRUCT_END(EffectParticleElementDelay, 4);

FLATBUFFERS_MANUALLY_ALIGNED_STRUCT(4) EffectParticleElementRndSeedChange FLATBUFFERS_FINAL_CLASS {
 private:
  int32_t Seed_;

 public:
  EffectParticleElementRndSeedChange() {
    memset(this, 0, sizeof(EffectParticleElementRndSeedChange));
  }
  EffectParticleElementRndSeedChange(int32_t _Seed)
      : Seed_(flatbuffers::EndianScalar(_Seed)) {
  }
  int32_t Seed() const {
    return flatbuffers::EndianScalar(Seed_);
  }
};
FLATBUFFERS_STRUCT_END(EffectParticleElementRndSeedChange, 4);

FLATBUFFERS_MANUALLY_ALIGNED_STRUCT(4) EffectParticleElementBasic FLATBUFFERS_FINAL_CLASS {
 private:
  int32_t SsEffectFunctionType_;
  int32_t priority_;
  int32_t maximumParticle_;
  int32_t attimeCreate_;
  int32_t interval_;
  int32_t lifetime_;
  float speedMinValue_;
  float speedMaxValue_;
  int32_t lifespanMinValue_;
  int32_t lifespanMaxValue_;
  float angle_;
  float angleVariance_;

 public:
  EffectParticleElementBasic() {
    memset(this, 0, sizeof(EffectParticleElementBasic));
  }
  EffectParticleElementBasic(int32_t _SsEffectFunctionType, int32_t _priority, int32_t _maximumParticle, int32_t _attimeCreate, int32_t _interval, int32_t _lifetime, float _speedMinValue, float _speedMaxValue, int32_t _lifespanMinValue, int32_t _lifespanMaxValue, float _angle, float _angleVariance)
      : SsEffectFunctionType_(flatbuffers::EndianScalar(_SsEffectFunctionType)),
        priority_(flatbuffers::EndianScalar(_priority)),
        maximumParticle_(flatbuffers::EndianScalar(_maximumParticle)),
        attimeCreate_(flatbuffers::EndianScalar(_attimeCreate)),
        interval_(flatbuffers::EndianScalar(_interval)),
        lifetime_(flatbuffers::EndianScalar(_lifetime)),
        speedMinValue_(flatbuffers::EndianScalar(_speedMinValue)),
        speedMaxValue_(flatbuffers::EndianScalar(_speedMaxValue)),
        lifespanMinValue_(flatbuffers::EndianScalar(_lifespanMinValue)),
        lifespanMaxValue_(flatbuffers::EndianScalar(_lifespanMaxValue)),
        angle_(flatbuffers::EndianScalar(_angle)),
        angleVariance_(flatbuffers::EndianScalar(_angleVariance)) {
  }
  int32_t SsEffectFunctionType() const {
    return flatbuffers::EndianScalar(SsEffectFunctionType_);
  }
  int32_t priority() const {
    return flatbuffers::EndianScalar(priority_);
  }
  int32_t maximumParticle() const {
    return flatbuffers::EndianScalar(maximumParticle_);
  }
  int32_t attimeCreate() const {
    return flatbuffers::EndianScalar(attimeCreate_);
  }
  int32_t interval() const {
    return flatbuffers::EndianScalar(interval_);
  }
  int32_t lifetime() const {
    return flatbuffers::EndianScalar(lifetime_);
  }
  float speedMinValue() const {
    return flatbuffers::EndianScalar(speedMinValue_);
  }
  float speedMaxValue() const {
    return flatbuffers::EndianScalar(speedMaxValue_);
  }
  int32_t lifespanMinValue() const {
    return flatbuffers::EndianScalar(lifespanMinValue_);
  }
  int32_t lifespanMaxValue() const {
    return flatbuffers::EndianScalar(lifespanMaxValue_);
  }
  float angle() const {
    return flatbuffers::EndianScalar(angle_);
  }
  float angleVariance() const {
    return flatbuffers::EndianScalar(angleVariance_);
  }
};
FLATBUFFERS_STRUCT_END(EffectParticleElementBasic, 48);

FLATBUFFERS_MANUALLY_ALIGNED_STRUCT(4) userDataInteger FLATBUFFERS_FINAL_CLASS {
 private:
  int32_t integer_;

 public:
  userDataInteger() {
    memset(this, 0, sizeof(userDataInteger));
  }
  userDataInteger(int32_t _integer)
      : integer_(flatbuffers::EndianScalar(_integer)) {
  }
  int32_t integer() const {
    return flatbuffers::EndianScalar(integer_);
  }
};
FLATBUFFERS_STRUCT_END(userDataInteger, 4);

FLATBUFFERS_MANUALLY_ALIGNED_STRUCT(4) userDataRect FLATBUFFERS_FINAL_CLASS {
 private:
  int32_t x_;
  int32_t y_;
  int32_t w_;
  int32_t h_;

 public:
  userDataRect() {
    memset(this, 0, sizeof(userDataRect));
  }
  userDataRect(int32_t _x, int32_t _y, int32_t _w, int32_t _h)
      : x_(flatbuffers::EndianScalar(_x)),
        y_(flatbuffers::EndianScalar(_y)),
        w_(flatbuffers::EndianScalar(_w)),
        h_(flatbuffers::EndianScalar(_h)) {
  }
  int32_t x() const {
    return flatbuffers::EndianScalar(x_);
  }
  int32_t y() const {
    return flatbuffers::EndianScalar(y_);
  }
  int32_t w() const {
    return flatbuffers::EndianScalar(w_);
  }
  int32_t h() const {
    return flatbuffers::EndianScalar(h_);
  }
};
FLATBUFFERS_STRUCT_END(userDataRect, 16);

FLATBUFFERS_MANUALLY_ALIGNED_STRUCT(4) userDataPoint FLATBUFFERS_FINAL_CLASS {
 private:
  int32_t x_;
  int32_t y_;

 public:
  userDataPoint() {
    memset(this, 0, sizeof(userDataPoint));
  }
  userDataPoint(int32_t _x, int32_t _y)
      : x_(flatbuffers::EndianScalar(_x)),
        y_(flatbuffers::EndianScalar(_y)) {
  }
  int32_t x() const {
    return flatbuffers::EndianScalar(x_);
  }
  int32_t y() const {
    return flatbuffers::EndianScalar(y_);
  }
};
FLATBUFFERS_STRUCT_END(userDataPoint, 8);

struct EffectNode FLATBUFFERS_FINAL_CLASS : private flatbuffers::Table {
  enum {
    VT_ARRAYINDEX = 4,
    VT_PARENTINDEX = 6,
    VT_TYPE = 8,
    VT_CELLINDEX = 10,
    VT_BLENDTYPE = 12,
    VT_NUMBEHAVIOR = 14,
    VT_BEHAVIOR_TYPE = 16,
    VT_BEHAVIOR = 18
  };
  int16_t arrayIndex() const {
    return GetField<int16_t>(VT_ARRAYINDEX, 0);
  }
  int16_t parentIndex() const {
    return GetField<int16_t>(VT_PARENTINDEX, 0);
  }
  int16_t type() const {
    return GetField<int16_t>(VT_TYPE, 0);
  }
  int16_t cellIndex() const {
    return GetField<int16_t>(VT_CELLINDEX, 0);
  }
  int16_t blendType() const {
    return GetField<int16_t>(VT_BLENDTYPE, 0);
  }
  int16_t numBehavior() const {
    return GetField<int16_t>(VT_NUMBEHAVIOR, 0);
  }
  const flatbuffers::Vector<uint8_t> *Behavior_type() const {
    return GetPointer<const flatbuffers::Vector<uint8_t> *>(VT_BEHAVIOR_TYPE);
  }
  const flatbuffers::Vector<flatbuffers::Offset<void>> *Behavior() const {
    return GetPointer<const flatbuffers::Vector<flatbuffers::Offset<void>> *>(VT_BEHAVIOR);
  }
  bool Verify(flatbuffers::Verifier &verifier) const {
    return VerifyTableStart(verifier) &&
           VerifyField<int16_t>(verifier, VT_ARRAYINDEX) &&
           VerifyField<int16_t>(verifier, VT_PARENTINDEX) &&
           VerifyField<int16_t>(verifier, VT_TYPE) &&
           VerifyField<int16_t>(verifier, VT_CELLINDEX) &&
           VerifyField<int16_t>(verifier, VT_BLENDTYPE) &&
           VerifyField<int16_t>(verifier, VT_NUMBEHAVIOR) &&
           VerifyOffset(verifier, VT_BEHAVIOR_TYPE) &&
           verifier.VerifyVector(Behavior_type()) &&
           VerifyOffset(verifier, VT_BEHAVIOR) &&
           verifier.VerifyVector(Behavior()) &&
           VerifyEffectNodeBehaviorVector(verifier, Behavior(), Behavior_type()) &&
           verifier.EndTable();
  }
};

struct EffectNodeBuilder {
  flatbuffers::FlatBufferBuilder &fbb_;
  flatbuffers::uoffset_t start_;
  void add_arrayIndex(int16_t arrayIndex) {
    fbb_.AddElement<int16_t>(EffectNode::VT_ARRAYINDEX, arrayIndex, 0);
  }
  void add_parentIndex(int16_t parentIndex) {
    fbb_.AddElement<int16_t>(EffectNode::VT_PARENTINDEX, parentIndex, 0);
  }
  void add_type(int16_t type) {
    fbb_.AddElement<int16_t>(EffectNode::VT_TYPE, type, 0);
  }
  void add_cellIndex(int16_t cellIndex) {
    fbb_.AddElement<int16_t>(EffectNode::VT_CELLINDEX, cellIndex, 0);
  }
  void add_blendType(int16_t blendType) {
    fbb_.AddElement<int16_t>(EffectNode::VT_BLENDTYPE, blendType, 0);
  }
  void add_numBehavior(int16_t numBehavior) {
    fbb_.AddElement<int16_t>(EffectNode::VT_NUMBEHAVIOR, numBehavior, 0);
  }
  void add_Behavior_type(flatbuffers::Offset<flatbuffers::Vector<uint8_t>> Behavior_type) {
    fbb_.AddOffset(EffectNode::VT_BEHAVIOR_TYPE, Behavior_type);
  }
  void add_Behavior(flatbuffers::Offset<flatbuffers::Vector<flatbuffers::Offset<void>>> Behavior) {
    fbb_.AddOffset(EffectNode::VT_BEHAVIOR, Behavior);
  }
  explicit EffectNodeBuilder(flatbuffers::FlatBufferBuilder &_fbb)
        : fbb_(_fbb) {
    start_ = fbb_.StartTable();
  }
  EffectNodeBuilder &operator=(const EffectNodeBuilder &);
  flatbuffers::Offset<EffectNode> Finish() {
    const auto end = fbb_.EndTable(start_);
    auto o = flatbuffers::Offset<EffectNode>(end);
    return o;
  }
};

inline flatbuffers::Offset<EffectNode> CreateEffectNode(
    flatbuffers::FlatBufferBuilder &_fbb,
    int16_t arrayIndex = 0,
    int16_t parentIndex = 0,
    int16_t type = 0,
    int16_t cellIndex = 0,
    int16_t blendType = 0,
    int16_t numBehavior = 0,
    flatbuffers::Offset<flatbuffers::Vector<uint8_t>> Behavior_type = 0,
    flatbuffers::Offset<flatbuffers::Vector<flatbuffers::Offset<void>>> Behavior = 0) {
  EffectNodeBuilder builder_(_fbb);
  builder_.add_Behavior(Behavior);
  builder_.add_Behavior_type(Behavior_type);
  builder_.add_numBehavior(numBehavior);
  builder_.add_blendType(blendType);
  builder_.add_cellIndex(cellIndex);
  builder_.add_type(type);
  builder_.add_parentIndex(parentIndex);
  builder_.add_arrayIndex(arrayIndex);
  return builder_.Finish();
}

inline flatbuffers::Offset<EffectNode> CreateEffectNodeDirect(
    flatbuffers::FlatBufferBuilder &_fbb,
    int16_t arrayIndex = 0,
    int16_t parentIndex = 0,
    int16_t type = 0,
    int16_t cellIndex = 0,
    int16_t blendType = 0,
    int16_t numBehavior = 0,
    const std::vector<uint8_t> *Behavior_type = nullptr,
    const std::vector<flatbuffers::Offset<void>> *Behavior = nullptr) {
  return ss::ssfb::CreateEffectNode(
      _fbb,
      arrayIndex,
      parentIndex,
      type,
      cellIndex,
      blendType,
      numBehavior,
      Behavior_type ? _fbb.CreateVector<uint8_t>(*Behavior_type) : 0,
      Behavior ? _fbb.CreateVector<flatbuffers::Offset<void>>(*Behavior) : 0);
}

struct EffectFile FLATBUFFERS_FINAL_CLASS : private flatbuffers::Table {
  enum {
    VT_NAME = 4,
    VT_FPS = 6,
    VT_ISLOCKRANDSEED = 8,
    VT_LOCKRANDSEED = 10,
    VT_LAYOUTSCALEX = 12,
    VT_LAYOUTSCALEY = 14,
    VT_NUMNODELIST = 16,
    VT_EFFECTNODE = 18
  };
  const flatbuffers::String *name() const {
    return GetPointer<const flatbuffers::String *>(VT_NAME);
  }
  int16_t fps() const {
    return GetField<int16_t>(VT_FPS, 0);
  }
  int16_t isLockRandSeed() const {
    return GetField<int16_t>(VT_ISLOCKRANDSEED, 0);
  }
  int16_t lockRandSeed() const {
    return GetField<int16_t>(VT_LOCKRANDSEED, 0);
  }
  int16_t layoutScaleX() const {
    return GetField<int16_t>(VT_LAYOUTSCALEX, 0);
  }
  int16_t layoutScaleY() const {
    return GetField<int16_t>(VT_LAYOUTSCALEY, 0);
  }
  int16_t numNodeList() const {
    return GetField<int16_t>(VT_NUMNODELIST, 0);
  }
  const flatbuffers::Vector<flatbuffers::Offset<EffectNode>> *effectNode() const {
    return GetPointer<const flatbuffers::Vector<flatbuffers::Offset<EffectNode>> *>(VT_EFFECTNODE);
  }
  bool Verify(flatbuffers::Verifier &verifier) const {
    return VerifyTableStart(verifier) &&
           VerifyOffset(verifier, VT_NAME) &&
           verifier.VerifyString(name()) &&
           VerifyField<int16_t>(verifier, VT_FPS) &&
           VerifyField<int16_t>(verifier, VT_ISLOCKRANDSEED) &&
           VerifyField<int16_t>(verifier, VT_LOCKRANDSEED) &&
           VerifyField<int16_t>(verifier, VT_LAYOUTSCALEX) &&
           VerifyField<int16_t>(verifier, VT_LAYOUTSCALEY) &&
           VerifyField<int16_t>(verifier, VT_NUMNODELIST) &&
           VerifyOffset(verifier, VT_EFFECTNODE) &&
           verifier.VerifyVector(effectNode()) &&
           verifier.VerifyVectorOfTables(effectNode()) &&
           verifier.EndTable();
  }
};

struct EffectFileBuilder {
  flatbuffers::FlatBufferBuilder &fbb_;
  flatbuffers::uoffset_t start_;
  void add_name(flatbuffers::Offset<flatbuffers::String> name) {
    fbb_.AddOffset(EffectFile::VT_NAME, name);
  }
  void add_fps(int16_t fps) {
    fbb_.AddElement<int16_t>(EffectFile::VT_FPS, fps, 0);
  }
  void add_isLockRandSeed(int16_t isLockRandSeed) {
    fbb_.AddElement<int16_t>(EffectFile::VT_ISLOCKRANDSEED, isLockRandSeed, 0);
  }
  void add_lockRandSeed(int16_t lockRandSeed) {
    fbb_.AddElement<int16_t>(EffectFile::VT_LOCKRANDSEED, lockRandSeed, 0);
  }
  void add_layoutScaleX(int16_t layoutScaleX) {
    fbb_.AddElement<int16_t>(EffectFile::VT_LAYOUTSCALEX, layoutScaleX, 0);
  }
  void add_layoutScaleY(int16_t layoutScaleY) {
    fbb_.AddElement<int16_t>(EffectFile::VT_LAYOUTSCALEY, layoutScaleY, 0);
  }
  void add_numNodeList(int16_t numNodeList) {
    fbb_.AddElement<int16_t>(EffectFile::VT_NUMNODELIST, numNodeList, 0);
  }
  void add_effectNode(flatbuffers::Offset<flatbuffers::Vector<flatbuffers::Offset<EffectNode>>> effectNode) {
    fbb_.AddOffset(EffectFile::VT_EFFECTNODE, effectNode);
  }
  explicit EffectFileBuilder(flatbuffers::FlatBufferBuilder &_fbb)
        : fbb_(_fbb) {
    start_ = fbb_.StartTable();
  }
  EffectFileBuilder &operator=(const EffectFileBuilder &);
  flatbuffers::Offset<EffectFile> Finish() {
    const auto end = fbb_.EndTable(start_);
    auto o = flatbuffers::Offset<EffectFile>(end);
    return o;
  }
};

inline flatbuffers::Offset<EffectFile> CreateEffectFile(
    flatbuffers::FlatBufferBuilder &_fbb,
    flatbuffers::Offset<flatbuffers::String> name = 0,
    int16_t fps = 0,
    int16_t isLockRandSeed = 0,
    int16_t lockRandSeed = 0,
    int16_t layoutScaleX = 0,
    int16_t layoutScaleY = 0,
    int16_t numNodeList = 0,
    flatbuffers::Offset<flatbuffers::Vector<flatbuffers::Offset<EffectNode>>> effectNode = 0) {
  EffectFileBuilder builder_(_fbb);
  builder_.add_effectNode(effectNode);
  builder_.add_name(name);
  builder_.add_numNodeList(numNodeList);
  builder_.add_layoutScaleY(layoutScaleY);
  builder_.add_layoutScaleX(layoutScaleX);
  builder_.add_lockRandSeed(lockRandSeed);
  builder_.add_isLockRandSeed(isLockRandSeed);
  builder_.add_fps(fps);
  return builder_.Finish();
}

inline flatbuffers::Offset<EffectFile> CreateEffectFileDirect(
    flatbuffers::FlatBufferBuilder &_fbb,
    const char *name = nullptr,
    int16_t fps = 0,
    int16_t isLockRandSeed = 0,
    int16_t lockRandSeed = 0,
    int16_t layoutScaleX = 0,
    int16_t layoutScaleY = 0,
    int16_t numNodeList = 0,
    const std::vector<flatbuffers::Offset<EffectNode>> *effectNode = nullptr) {
  return ss::ssfb::CreateEffectFile(
      _fbb,
      name ? _fbb.CreateString(name) : 0,
      fps,
      isLockRandSeed,
      lockRandSeed,
      layoutScaleX,
      layoutScaleY,
      numNodeList,
      effectNode ? _fbb.CreateVector<flatbuffers::Offset<EffectNode>>(*effectNode) : 0);
}

struct CellMap FLATBUFFERS_FINAL_CLASS : private flatbuffers::Table {
  enum {
    VT_NAME = 4,
    VT_IMAGEPATH = 6,
    VT_INDEX = 8,
    VT_WRAPMODE = 10,
    VT_FILTERMODE = 12
  };
  const flatbuffers::String *name() const {
    return GetPointer<const flatbuffers::String *>(VT_NAME);
  }
  const flatbuffers::String *imagePath() const {
    return GetPointer<const flatbuffers::String *>(VT_IMAGEPATH);
  }
  int16_t index() const {
    return GetField<int16_t>(VT_INDEX, 0);
  }
  int16_t wrapmode() const {
    return GetField<int16_t>(VT_WRAPMODE, 0);
  }
  int16_t filtermode() const {
    return GetField<int16_t>(VT_FILTERMODE, 0);
  }
  bool Verify(flatbuffers::Verifier &verifier) const {
    return VerifyTableStart(verifier) &&
           VerifyOffset(verifier, VT_NAME) &&
           verifier.VerifyString(name()) &&
           VerifyOffset(verifier, VT_IMAGEPATH) &&
           verifier.VerifyString(imagePath()) &&
           VerifyField<int16_t>(verifier, VT_INDEX) &&
           VerifyField<int16_t>(verifier, VT_WRAPMODE) &&
           VerifyField<int16_t>(verifier, VT_FILTERMODE) &&
           verifier.EndTable();
  }
};

struct CellMapBuilder {
  flatbuffers::FlatBufferBuilder &fbb_;
  flatbuffers::uoffset_t start_;
  void add_name(flatbuffers::Offset<flatbuffers::String> name) {
    fbb_.AddOffset(CellMap::VT_NAME, name);
  }
  void add_imagePath(flatbuffers::Offset<flatbuffers::String> imagePath) {
    fbb_.AddOffset(CellMap::VT_IMAGEPATH, imagePath);
  }
  void add_index(int16_t index) {
    fbb_.AddElement<int16_t>(CellMap::VT_INDEX, index, 0);
  }
  void add_wrapmode(int16_t wrapmode) {
    fbb_.AddElement<int16_t>(CellMap::VT_WRAPMODE, wrapmode, 0);
  }
  void add_filtermode(int16_t filtermode) {
    fbb_.AddElement<int16_t>(CellMap::VT_FILTERMODE, filtermode, 0);
  }
  explicit CellMapBuilder(flatbuffers::FlatBufferBuilder &_fbb)
        : fbb_(_fbb) {
    start_ = fbb_.StartTable();
  }
  CellMapBuilder &operator=(const CellMapBuilder &);
  flatbuffers::Offset<CellMap> Finish() {
    const auto end = fbb_.EndTable(start_);
    auto o = flatbuffers::Offset<CellMap>(end);
    return o;
  }
};

inline flatbuffers::Offset<CellMap> CreateCellMap(
    flatbuffers::FlatBufferBuilder &_fbb,
    flatbuffers::Offset<flatbuffers::String> name = 0,
    flatbuffers::Offset<flatbuffers::String> imagePath = 0,
    int16_t index = 0,
    int16_t wrapmode = 0,
    int16_t filtermode = 0) {
  CellMapBuilder builder_(_fbb);
  builder_.add_imagePath(imagePath);
  builder_.add_name(name);
  builder_.add_filtermode(filtermode);
  builder_.add_wrapmode(wrapmode);
  builder_.add_index(index);
  return builder_.Finish();
}

inline flatbuffers::Offset<CellMap> CreateCellMapDirect(
    flatbuffers::FlatBufferBuilder &_fbb,
    const char *name = nullptr,
    const char *imagePath = nullptr,
    int16_t index = 0,
    int16_t wrapmode = 0,
    int16_t filtermode = 0) {
  return ss::ssfb::CreateCellMap(
      _fbb,
      name ? _fbb.CreateString(name) : 0,
      imagePath ? _fbb.CreateString(imagePath) : 0,
      index,
      wrapmode,
      filtermode);
}

struct Cell FLATBUFFERS_FINAL_CLASS : private flatbuffers::Table {
  enum {
    VT_NAME = 4,
    VT_CELLMAP = 6,
    VT_INDEXINCELLMAP = 8,
    VT_X = 10,
    VT_Y = 12,
    VT_WIDTH = 14,
    VT_HEIGHT = 16,
    VT_PIVOT_X = 18,
    VT_PIVOT_Y = 20,
    VT_U1 = 22,
    VT_V1 = 24,
    VT_U2 = 26,
    VT_V2 = 28
  };
  const flatbuffers::String *name() const {
    return GetPointer<const flatbuffers::String *>(VT_NAME);
  }
  const CellMap *cellMap() const {
    return GetPointer<const CellMap *>(VT_CELLMAP);
  }
  int16_t indexInCellMap() const {
    return GetField<int16_t>(VT_INDEXINCELLMAP, 0);
  }
  int16_t x() const {
    return GetField<int16_t>(VT_X, 0);
  }
  int16_t y() const {
    return GetField<int16_t>(VT_Y, 0);
  }
  int16_t width() const {
    return GetField<int16_t>(VT_WIDTH, 0);
  }
  int16_t height() const {
    return GetField<int16_t>(VT_HEIGHT, 0);
  }
  float pivot_x() const {
    return GetField<float>(VT_PIVOT_X, 0.0f);
  }
  float pivot_y() const {
    return GetField<float>(VT_PIVOT_Y, 0.0f);
  }
  float u1() const {
    return GetField<float>(VT_U1, 0.0f);
  }
  float v1() const {
    return GetField<float>(VT_V1, 0.0f);
  }
  float u2() const {
    return GetField<float>(VT_U2, 0.0f);
  }
  float v2() const {
    return GetField<float>(VT_V2, 0.0f);
  }
  bool Verify(flatbuffers::Verifier &verifier) const {
    return VerifyTableStart(verifier) &&
           VerifyOffset(verifier, VT_NAME) &&
           verifier.VerifyString(name()) &&
           VerifyOffset(verifier, VT_CELLMAP) &&
           verifier.VerifyTable(cellMap()) &&
           VerifyField<int16_t>(verifier, VT_INDEXINCELLMAP) &&
           VerifyField<int16_t>(verifier, VT_X) &&
           VerifyField<int16_t>(verifier, VT_Y) &&
           VerifyField<int16_t>(verifier, VT_WIDTH) &&
           VerifyField<int16_t>(verifier, VT_HEIGHT) &&
           VerifyField<float>(verifier, VT_PIVOT_X) &&
           VerifyField<float>(verifier, VT_PIVOT_Y) &&
           VerifyField<float>(verifier, VT_U1) &&
           VerifyField<float>(verifier, VT_V1) &&
           VerifyField<float>(verifier, VT_U2) &&
           VerifyField<float>(verifier, VT_V2) &&
           verifier.EndTable();
  }
};

struct CellBuilder {
  flatbuffers::FlatBufferBuilder &fbb_;
  flatbuffers::uoffset_t start_;
  void add_name(flatbuffers::Offset<flatbuffers::String> name) {
    fbb_.AddOffset(Cell::VT_NAME, name);
  }
  void add_cellMap(flatbuffers::Offset<CellMap> cellMap) {
    fbb_.AddOffset(Cell::VT_CELLMAP, cellMap);
  }
  void add_indexInCellMap(int16_t indexInCellMap) {
    fbb_.AddElement<int16_t>(Cell::VT_INDEXINCELLMAP, indexInCellMap, 0);
  }
  void add_x(int16_t x) {
    fbb_.AddElement<int16_t>(Cell::VT_X, x, 0);
  }
  void add_y(int16_t y) {
    fbb_.AddElement<int16_t>(Cell::VT_Y, y, 0);
  }
  void add_width(int16_t width) {
    fbb_.AddElement<int16_t>(Cell::VT_WIDTH, width, 0);
  }
  void add_height(int16_t height) {
    fbb_.AddElement<int16_t>(Cell::VT_HEIGHT, height, 0);
  }
  void add_pivot_x(float pivot_x) {
    fbb_.AddElement<float>(Cell::VT_PIVOT_X, pivot_x, 0.0f);
  }
  void add_pivot_y(float pivot_y) {
    fbb_.AddElement<float>(Cell::VT_PIVOT_Y, pivot_y, 0.0f);
  }
  void add_u1(float u1) {
    fbb_.AddElement<float>(Cell::VT_U1, u1, 0.0f);
  }
  void add_v1(float v1) {
    fbb_.AddElement<float>(Cell::VT_V1, v1, 0.0f);
  }
  void add_u2(float u2) {
    fbb_.AddElement<float>(Cell::VT_U2, u2, 0.0f);
  }
  void add_v2(float v2) {
    fbb_.AddElement<float>(Cell::VT_V2, v2, 0.0f);
  }
  explicit CellBuilder(flatbuffers::FlatBufferBuilder &_fbb)
        : fbb_(_fbb) {
    start_ = fbb_.StartTable();
  }
  CellBuilder &operator=(const CellBuilder &);
  flatbuffers::Offset<Cell> Finish() {
    const auto end = fbb_.EndTable(start_);
    auto o = flatbuffers::Offset<Cell>(end);
    return o;
  }
};

inline flatbuffers::Offset<Cell> CreateCell(
    flatbuffers::FlatBufferBuilder &_fbb,
    flatbuffers::Offset<flatbuffers::String> name = 0,
    flatbuffers::Offset<CellMap> cellMap = 0,
    int16_t indexInCellMap = 0,
    int16_t x = 0,
    int16_t y = 0,
    int16_t width = 0,
    int16_t height = 0,
    float pivot_x = 0.0f,
    float pivot_y = 0.0f,
    float u1 = 0.0f,
    float v1 = 0.0f,
    float u2 = 0.0f,
    float v2 = 0.0f) {
  CellBuilder builder_(_fbb);
  builder_.add_v2(v2);
  builder_.add_u2(u2);
  builder_.add_v1(v1);
  builder_.add_u1(u1);
  builder_.add_pivot_y(pivot_y);
  builder_.add_pivot_x(pivot_x);
  builder_.add_cellMap(cellMap);
  builder_.add_name(name);
  builder_.add_height(height);
  builder_.add_width(width);
  builder_.add_y(y);
  builder_.add_x(x);
  builder_.add_indexInCellMap(indexInCellMap);
  return builder_.Finish();
}

inline flatbuffers::Offset<Cell> CreateCellDirect(
    flatbuffers::FlatBufferBuilder &_fbb,
    const char *name = nullptr,
    flatbuffers::Offset<CellMap> cellMap = 0,
    int16_t indexInCellMap = 0,
    int16_t x = 0,
    int16_t y = 0,
    int16_t width = 0,
    int16_t height = 0,
    float pivot_x = 0.0f,
    float pivot_y = 0.0f,
    float u1 = 0.0f,
    float v1 = 0.0f,
    float u2 = 0.0f,
    float v2 = 0.0f) {
  return ss::ssfb::CreateCell(
      _fbb,
      name ? _fbb.CreateString(name) : 0,
      cellMap,
      indexInCellMap,
      x,
      y,
      width,
      height,
      pivot_x,
      pivot_y,
      u1,
      v1,
      u2,
      v2);
}

struct meshDataUV FLATBUFFERS_FINAL_CLASS : private flatbuffers::Table {
  enum {
    VT_UV = 4
  };
  const flatbuffers::Vector<float> *uv() const {
    return GetPointer<const flatbuffers::Vector<float> *>(VT_UV);
  }
  bool Verify(flatbuffers::Verifier &verifier) const {
    return VerifyTableStart(verifier) &&
           VerifyOffset(verifier, VT_UV) &&
           verifier.VerifyVector(uv()) &&
           verifier.EndTable();
  }
};

struct meshDataUVBuilder {
  flatbuffers::FlatBufferBuilder &fbb_;
  flatbuffers::uoffset_t start_;
  void add_uv(flatbuffers::Offset<flatbuffers::Vector<float>> uv) {
    fbb_.AddOffset(meshDataUV::VT_UV, uv);
  }
  explicit meshDataUVBuilder(flatbuffers::FlatBufferBuilder &_fbb)
        : fbb_(_fbb) {
    start_ = fbb_.StartTable();
  }
  meshDataUVBuilder &operator=(const meshDataUVBuilder &);
  flatbuffers::Offset<meshDataUV> Finish() {
    const auto end = fbb_.EndTable(start_);
    auto o = flatbuffers::Offset<meshDataUV>(end);
    return o;
  }
};

inline flatbuffers::Offset<meshDataUV> CreatemeshDataUV(
    flatbuffers::FlatBufferBuilder &_fbb,
    flatbuffers::Offset<flatbuffers::Vector<float>> uv = 0) {
  meshDataUVBuilder builder_(_fbb);
  builder_.add_uv(uv);
  return builder_.Finish();
}

inline flatbuffers::Offset<meshDataUV> CreatemeshDataUVDirect(
    flatbuffers::FlatBufferBuilder &_fbb,
    const std::vector<float> *uv = nullptr) {
  return ss::ssfb::CreatemeshDataUV(
      _fbb,
      uv ? _fbb.CreateVector<float>(*uv) : 0);
}

struct meshDataIndices FLATBUFFERS_FINAL_CLASS : private flatbuffers::Table {
  enum {
    VT_INDICES = 4
  };
  const flatbuffers::Vector<float> *indices() const {
    return GetPointer<const flatbuffers::Vector<float> *>(VT_INDICES);
  }
  bool Verify(flatbuffers::Verifier &verifier) const {
    return VerifyTableStart(verifier) &&
           VerifyOffset(verifier, VT_INDICES) &&
           verifier.VerifyVector(indices()) &&
           verifier.EndTable();
  }
};

struct meshDataIndicesBuilder {
  flatbuffers::FlatBufferBuilder &fbb_;
  flatbuffers::uoffset_t start_;
  void add_indices(flatbuffers::Offset<flatbuffers::Vector<float>> indices) {
    fbb_.AddOffset(meshDataIndices::VT_INDICES, indices);
  }
  explicit meshDataIndicesBuilder(flatbuffers::FlatBufferBuilder &_fbb)
        : fbb_(_fbb) {
    start_ = fbb_.StartTable();
  }
  meshDataIndicesBuilder &operator=(const meshDataIndicesBuilder &);
  flatbuffers::Offset<meshDataIndices> Finish() {
    const auto end = fbb_.EndTable(start_);
    auto o = flatbuffers::Offset<meshDataIndices>(end);
    return o;
  }
};

inline flatbuffers::Offset<meshDataIndices> CreatemeshDataIndices(
    flatbuffers::FlatBufferBuilder &_fbb,
    flatbuffers::Offset<flatbuffers::Vector<float>> indices = 0) {
  meshDataIndicesBuilder builder_(_fbb);
  builder_.add_indices(indices);
  return builder_.Finish();
}

inline flatbuffers::Offset<meshDataIndices> CreatemeshDataIndicesDirect(
    flatbuffers::FlatBufferBuilder &_fbb,
    const std::vector<float> *indices = nullptr) {
  return ss::ssfb::CreatemeshDataIndices(
      _fbb,
      indices ? _fbb.CreateVector<float>(*indices) : 0);
}

struct frameDataIndex FLATBUFFERS_FINAL_CLASS : private flatbuffers::Table {
  enum {
    VT_DATA = 4
  };
  const flatbuffers::Vector<uint32_t> *data() const {
    return GetPointer<const flatbuffers::Vector<uint32_t> *>(VT_DATA);
  }
  bool Verify(flatbuffers::Verifier &verifier) const {
    return VerifyTableStart(verifier) &&
           VerifyOffset(verifier, VT_DATA) &&
           verifier.VerifyVector(data()) &&
           verifier.EndTable();
  }
};

struct frameDataIndexBuilder {
  flatbuffers::FlatBufferBuilder &fbb_;
  flatbuffers::uoffset_t start_;
  void add_data(flatbuffers::Offset<flatbuffers::Vector<uint32_t>> data) {
    fbb_.AddOffset(frameDataIndex::VT_DATA, data);
  }
  explicit frameDataIndexBuilder(flatbuffers::FlatBufferBuilder &_fbb)
        : fbb_(_fbb) {
    start_ = fbb_.StartTable();
  }
  frameDataIndexBuilder &operator=(const frameDataIndexBuilder &);
  flatbuffers::Offset<frameDataIndex> Finish() {
    const auto end = fbb_.EndTable(start_);
    auto o = flatbuffers::Offset<frameDataIndex>(end);
    return o;
  }
};

inline flatbuffers::Offset<frameDataIndex> CreateframeDataIndex(
    flatbuffers::FlatBufferBuilder &_fbb,
    flatbuffers::Offset<flatbuffers::Vector<uint32_t>> data = 0) {
  frameDataIndexBuilder builder_(_fbb);
  builder_.add_data(data);
  return builder_.Finish();
}

inline flatbuffers::Offset<frameDataIndex> CreateframeDataIndexDirect(
    flatbuffers::FlatBufferBuilder &_fbb,
    const std::vector<uint32_t> *data = nullptr) {
  return ss::ssfb::CreateframeDataIndex(
      _fbb,
      data ? _fbb.CreateVector<uint32_t>(*data) : 0);
}

struct userDataString FLATBUFFERS_FINAL_CLASS : private flatbuffers::Table {
  enum {
    VT_LENGTH = 4,
    VT_DATA = 6
  };
  int32_t length() const {
    return GetField<int32_t>(VT_LENGTH, 0);
  }
  const flatbuffers::String *data() const {
    return GetPointer<const flatbuffers::String *>(VT_DATA);
  }
  bool Verify(flatbuffers::Verifier &verifier) const {
    return VerifyTableStart(verifier) &&
           VerifyField<int32_t>(verifier, VT_LENGTH) &&
           VerifyOffset(verifier, VT_DATA) &&
           verifier.VerifyString(data()) &&
           verifier.EndTable();
  }
};

struct userDataStringBuilder {
  flatbuffers::FlatBufferBuilder &fbb_;
  flatbuffers::uoffset_t start_;
  void add_length(int32_t length) {
    fbb_.AddElement<int32_t>(userDataString::VT_LENGTH, length, 0);
  }
  void add_data(flatbuffers::Offset<flatbuffers::String> data) {
    fbb_.AddOffset(userDataString::VT_DATA, data);
  }
  explicit userDataStringBuilder(flatbuffers::FlatBufferBuilder &_fbb)
        : fbb_(_fbb) {
    start_ = fbb_.StartTable();
  }
  userDataStringBuilder &operator=(const userDataStringBuilder &);
  flatbuffers::Offset<userDataString> Finish() {
    const auto end = fbb_.EndTable(start_);
    auto o = flatbuffers::Offset<userDataString>(end);
    return o;
  }
};

inline flatbuffers::Offset<userDataString> CreateuserDataString(
    flatbuffers::FlatBufferBuilder &_fbb,
    int32_t length = 0,
    flatbuffers::Offset<flatbuffers::String> data = 0) {
  userDataStringBuilder builder_(_fbb);
  builder_.add_data(data);
  builder_.add_length(length);
  return builder_.Finish();
}

inline flatbuffers::Offset<userDataString> CreateuserDataStringDirect(
    flatbuffers::FlatBufferBuilder &_fbb,
    int32_t length = 0,
    const char *data = nullptr) {
  return ss::ssfb::CreateuserDataString(
      _fbb,
      length,
      data ? _fbb.CreateString(data) : 0);
}

struct userDataItem FLATBUFFERS_FINAL_CLASS : private flatbuffers::Table {
  enum {
    VT_FLAGS = 4,
    VT_ARRAYINDEX = 6,
    VT_DATA_TYPE = 8,
    VT_DATA = 10
  };
  int16_t flags() const {
    return GetField<int16_t>(VT_FLAGS, 0);
  }
  int16_t arrayIndex() const {
    return GetField<int16_t>(VT_ARRAYINDEX, 0);
  }
  const flatbuffers::Vector<uint8_t> *data_type() const {
    return GetPointer<const flatbuffers::Vector<uint8_t> *>(VT_DATA_TYPE);
  }
  const flatbuffers::Vector<flatbuffers::Offset<void>> *data() const {
    return GetPointer<const flatbuffers::Vector<flatbuffers::Offset<void>> *>(VT_DATA);
  }
  bool Verify(flatbuffers::Verifier &verifier) const {
    return VerifyTableStart(verifier) &&
           VerifyField<int16_t>(verifier, VT_FLAGS) &&
           VerifyField<int16_t>(verifier, VT_ARRAYINDEX) &&
           VerifyOffset(verifier, VT_DATA_TYPE) &&
           verifier.VerifyVector(data_type()) &&
           VerifyOffset(verifier, VT_DATA) &&
           verifier.VerifyVector(data()) &&
           VerifyuserDataValueVector(verifier, data(), data_type()) &&
           verifier.EndTable();
  }
};

struct userDataItemBuilder {
  flatbuffers::FlatBufferBuilder &fbb_;
  flatbuffers::uoffset_t start_;
  void add_flags(int16_t flags) {
    fbb_.AddElement<int16_t>(userDataItem::VT_FLAGS, flags, 0);
  }
  void add_arrayIndex(int16_t arrayIndex) {
    fbb_.AddElement<int16_t>(userDataItem::VT_ARRAYINDEX, arrayIndex, 0);
  }
  void add_data_type(flatbuffers::Offset<flatbuffers::Vector<uint8_t>> data_type) {
    fbb_.AddOffset(userDataItem::VT_DATA_TYPE, data_type);
  }
  void add_data(flatbuffers::Offset<flatbuffers::Vector<flatbuffers::Offset<void>>> data) {
    fbb_.AddOffset(userDataItem::VT_DATA, data);
  }
  explicit userDataItemBuilder(flatbuffers::FlatBufferBuilder &_fbb)
        : fbb_(_fbb) {
    start_ = fbb_.StartTable();
  }
  userDataItemBuilder &operator=(const userDataItemBuilder &);
  flatbuffers::Offset<userDataItem> Finish() {
    const auto end = fbb_.EndTable(start_);
    auto o = flatbuffers::Offset<userDataItem>(end);
    return o;
  }
};

inline flatbuffers::Offset<userDataItem> CreateuserDataItem(
    flatbuffers::FlatBufferBuilder &_fbb,
    int16_t flags = 0,
    int16_t arrayIndex = 0,
    flatbuffers::Offset<flatbuffers::Vector<uint8_t>> data_type = 0,
    flatbuffers::Offset<flatbuffers::Vector<flatbuffers::Offset<void>>> data = 0) {
  userDataItemBuilder builder_(_fbb);
  builder_.add_data(data);
  builder_.add_data_type(data_type);
  builder_.add_arrayIndex(arrayIndex);
  builder_.add_flags(flags);
  return builder_.Finish();
}

inline flatbuffers::Offset<userDataItem> CreateuserDataItemDirect(
    flatbuffers::FlatBufferBuilder &_fbb,
    int16_t flags = 0,
    int16_t arrayIndex = 0,
    const std::vector<uint8_t> *data_type = nullptr,
    const std::vector<flatbuffers::Offset<void>> *data = nullptr) {
  return ss::ssfb::CreateuserDataItem(
      _fbb,
      flags,
      arrayIndex,
      data_type ? _fbb.CreateVector<uint8_t>(*data_type) : 0,
      data ? _fbb.CreateVector<flatbuffers::Offset<void>>(*data) : 0);
}

struct userDataPerFrame FLATBUFFERS_FINAL_CLASS : private flatbuffers::Table {
  enum {
    VT_FRAMEINDEX = 4,
    VT_DATA = 6
  };
  int16_t frameIndex() const {
    return GetField<int16_t>(VT_FRAMEINDEX, 0);
  }
  const flatbuffers::Vector<flatbuffers::Offset<userDataItem>> *data() const {
    return GetPointer<const flatbuffers::Vector<flatbuffers::Offset<userDataItem>> *>(VT_DATA);
  }
  bool Verify(flatbuffers::Verifier &verifier) const {
    return VerifyTableStart(verifier) &&
           VerifyField<int16_t>(verifier, VT_FRAMEINDEX) &&
           VerifyOffset(verifier, VT_DATA) &&
           verifier.VerifyVector(data()) &&
           verifier.VerifyVectorOfTables(data()) &&
           verifier.EndTable();
  }
};

struct userDataPerFrameBuilder {
  flatbuffers::FlatBufferBuilder &fbb_;
  flatbuffers::uoffset_t start_;
  void add_frameIndex(int16_t frameIndex) {
    fbb_.AddElement<int16_t>(userDataPerFrame::VT_FRAMEINDEX, frameIndex, 0);
  }
  void add_data(flatbuffers::Offset<flatbuffers::Vector<flatbuffers::Offset<userDataItem>>> data) {
    fbb_.AddOffset(userDataPerFrame::VT_DATA, data);
  }
  explicit userDataPerFrameBuilder(flatbuffers::FlatBufferBuilder &_fbb)
        : fbb_(_fbb) {
    start_ = fbb_.StartTable();
  }
  userDataPerFrameBuilder &operator=(const userDataPerFrameBuilder &);
  flatbuffers::Offset<userDataPerFrame> Finish() {
    const auto end = fbb_.EndTable(start_);
    auto o = flatbuffers::Offset<userDataPerFrame>(end);
    return o;
  }
};

inline flatbuffers::Offset<userDataPerFrame> CreateuserDataPerFrame(
    flatbuffers::FlatBufferBuilder &_fbb,
    int16_t frameIndex = 0,
    flatbuffers::Offset<flatbuffers::Vector<flatbuffers::Offset<userDataItem>>> data = 0) {
  userDataPerFrameBuilder builder_(_fbb);
  builder_.add_data(data);
  builder_.add_frameIndex(frameIndex);
  return builder_.Finish();
}

inline flatbuffers::Offset<userDataPerFrame> CreateuserDataPerFrameDirect(
    flatbuffers::FlatBufferBuilder &_fbb,
    int16_t frameIndex = 0,
    const std::vector<flatbuffers::Offset<userDataItem>> *data = nullptr) {
  return ss::ssfb::CreateuserDataPerFrame(
      _fbb,
      frameIndex,
      data ? _fbb.CreateVector<flatbuffers::Offset<userDataItem>>(*data) : 0);
}

struct labelDataItem FLATBUFFERS_FINAL_CLASS : private flatbuffers::Table {
  enum {
    VT_LABEL = 4,
    VT_FRAMEINDEX = 6
  };
  const flatbuffers::String *label() const {
    return GetPointer<const flatbuffers::String *>(VT_LABEL);
  }
  int16_t frameIndex() const {
    return GetField<int16_t>(VT_FRAMEINDEX, 0);
  }
  bool Verify(flatbuffers::Verifier &verifier) const {
    return VerifyTableStart(verifier) &&
           VerifyOffset(verifier, VT_LABEL) &&
           verifier.VerifyString(label()) &&
           VerifyField<int16_t>(verifier, VT_FRAMEINDEX) &&
           verifier.EndTable();
  }
};

struct labelDataItemBuilder {
  flatbuffers::FlatBufferBuilder &fbb_;
  flatbuffers::uoffset_t start_;
  void add_label(flatbuffers::Offset<flatbuffers::String> label) {
    fbb_.AddOffset(labelDataItem::VT_LABEL, label);
  }
  void add_frameIndex(int16_t frameIndex) {
    fbb_.AddElement<int16_t>(labelDataItem::VT_FRAMEINDEX, frameIndex, 0);
  }
  explicit labelDataItemBuilder(flatbuffers::FlatBufferBuilder &_fbb)
        : fbb_(_fbb) {
    start_ = fbb_.StartTable();
  }
  labelDataItemBuilder &operator=(const labelDataItemBuilder &);
  flatbuffers::Offset<labelDataItem> Finish() {
    const auto end = fbb_.EndTable(start_);
    auto o = flatbuffers::Offset<labelDataItem>(end);
    return o;
  }
};

inline flatbuffers::Offset<labelDataItem> CreatelabelDataItem(
    flatbuffers::FlatBufferBuilder &_fbb,
    flatbuffers::Offset<flatbuffers::String> label = 0,
    int16_t frameIndex = 0) {
  labelDataItemBuilder builder_(_fbb);
  builder_.add_label(label);
  builder_.add_frameIndex(frameIndex);
  return builder_.Finish();
}

inline flatbuffers::Offset<labelDataItem> CreatelabelDataItemDirect(
    flatbuffers::FlatBufferBuilder &_fbb,
    const char *label = nullptr,
    int16_t frameIndex = 0) {
  return ss::ssfb::CreatelabelDataItem(
      _fbb,
      label ? _fbb.CreateString(label) : 0,
      frameIndex);
}

struct AnimationData FLATBUFFERS_FINAL_CLASS : private flatbuffers::Table {
  enum {
    VT_NAME = 4,
    VT_DEFAULTDATA = 6,
    VT_FRAMEDATA = 8,
    VT_USERDATA = 10,
    VT_LABELDATA = 12,
    VT_MESHSDATAUV = 14,
    VT_MESHSDATAINDICES = 16,
    VT_STARTFRAMES = 18,
    VT_ENDFRAMES = 20,
    VT_TOTALFRAMES = 22,
    VT_FPS = 24,
    VT_LABELNUM = 26,
    VT_CANVASSIZEW = 28,
    VT_CANVASSIZEH = 30,
    VT_CANVASPVOTX = 32,
    VT_CANVASPVOTY = 34
  };
  const flatbuffers::String *name() const {
    return GetPointer<const flatbuffers::String *>(VT_NAME);
  }
  const flatbuffers::Vector<flatbuffers::Offset<AnimationInitialData>> *defaultData() const {
    return GetPointer<const flatbuffers::Vector<flatbuffers::Offset<AnimationInitialData>> *>(VT_DEFAULTDATA);
  }
  const flatbuffers::Vector<flatbuffers::Offset<frameDataIndex>> *frameData() const {
    return GetPointer<const flatbuffers::Vector<flatbuffers::Offset<frameDataIndex>> *>(VT_FRAMEDATA);
  }
  const flatbuffers::Vector<flatbuffers::Offset<userDataPerFrame>> *userData() const {
    return GetPointer<const flatbuffers::Vector<flatbuffers::Offset<userDataPerFrame>> *>(VT_USERDATA);
  }
  const flatbuffers::Vector<flatbuffers::Offset<labelDataItem>> *labelData() const {
    return GetPointer<const flatbuffers::Vector<flatbuffers::Offset<labelDataItem>> *>(VT_LABELDATA);
  }
  const flatbuffers::Vector<flatbuffers::Offset<meshDataUV>> *meshsDataUV() const {
    return GetPointer<const flatbuffers::Vector<flatbuffers::Offset<meshDataUV>> *>(VT_MESHSDATAUV);
  }
  const flatbuffers::Vector<flatbuffers::Offset<meshDataIndices>> *meshsDataIndices() const {
    return GetPointer<const flatbuffers::Vector<flatbuffers::Offset<meshDataIndices>> *>(VT_MESHSDATAINDICES);
  }
  int16_t startFrames() const {
    return GetField<int16_t>(VT_STARTFRAMES, 0);
  }
  int16_t endFrames() const {
    return GetField<int16_t>(VT_ENDFRAMES, 0);
  }
  int16_t totalFrames() const {
    return GetField<int16_t>(VT_TOTALFRAMES, 0);
  }
  int16_t fps() const {
    return GetField<int16_t>(VT_FPS, 0);
  }
  int16_t labelNum() const {
    return GetField<int16_t>(VT_LABELNUM, 0);
  }
  int16_t canvasSizeW() const {
    return GetField<int16_t>(VT_CANVASSIZEW, 0);
  }
  int16_t canvasSizeH() const {
    return GetField<int16_t>(VT_CANVASSIZEH, 0);
  }
  float canvasPvotX() const {
    return GetField<float>(VT_CANVASPVOTX, 0.0f);
  }
  float canvasPvotY() const {
    return GetField<float>(VT_CANVASPVOTY, 0.0f);
  }
  bool Verify(flatbuffers::Verifier &verifier) const {
    return VerifyTableStart(verifier) &&
           VerifyOffset(verifier, VT_NAME) &&
           verifier.VerifyString(name()) &&
           VerifyOffset(verifier, VT_DEFAULTDATA) &&
           verifier.VerifyVector(defaultData()) &&
           verifier.VerifyVectorOfTables(defaultData()) &&
           VerifyOffset(verifier, VT_FRAMEDATA) &&
           verifier.VerifyVector(frameData()) &&
           verifier.VerifyVectorOfTables(frameData()) &&
           VerifyOffset(verifier, VT_USERDATA) &&
           verifier.VerifyVector(userData()) &&
           verifier.VerifyVectorOfTables(userData()) &&
           VerifyOffset(verifier, VT_LABELDATA) &&
           verifier.VerifyVector(labelData()) &&
           verifier.VerifyVectorOfTables(labelData()) &&
           VerifyOffset(verifier, VT_MESHSDATAUV) &&
           verifier.VerifyVector(meshsDataUV()) &&
           verifier.VerifyVectorOfTables(meshsDataUV()) &&
           VerifyOffset(verifier, VT_MESHSDATAINDICES) &&
           verifier.VerifyVector(meshsDataIndices()) &&
           verifier.VerifyVectorOfTables(meshsDataIndices()) &&
           VerifyField<int16_t>(verifier, VT_STARTFRAMES) &&
           VerifyField<int16_t>(verifier, VT_ENDFRAMES) &&
           VerifyField<int16_t>(verifier, VT_TOTALFRAMES) &&
           VerifyField<int16_t>(verifier, VT_FPS) &&
           VerifyField<int16_t>(verifier, VT_LABELNUM) &&
           VerifyField<int16_t>(verifier, VT_CANVASSIZEW) &&
           VerifyField<int16_t>(verifier, VT_CANVASSIZEH) &&
           VerifyField<float>(verifier, VT_CANVASPVOTX) &&
           VerifyField<float>(verifier, VT_CANVASPVOTY) &&
           verifier.EndTable();
  }
};

struct AnimationDataBuilder {
  flatbuffers::FlatBufferBuilder &fbb_;
  flatbuffers::uoffset_t start_;
  void add_name(flatbuffers::Offset<flatbuffers::String> name) {
    fbb_.AddOffset(AnimationData::VT_NAME, name);
  }
  void add_defaultData(flatbuffers::Offset<flatbuffers::Vector<flatbuffers::Offset<AnimationInitialData>>> defaultData) {
    fbb_.AddOffset(AnimationData::VT_DEFAULTDATA, defaultData);
  }
  void add_frameData(flatbuffers::Offset<flatbuffers::Vector<flatbuffers::Offset<frameDataIndex>>> frameData) {
    fbb_.AddOffset(AnimationData::VT_FRAMEDATA, frameData);
  }
  void add_userData(flatbuffers::Offset<flatbuffers::Vector<flatbuffers::Offset<userDataPerFrame>>> userData) {
    fbb_.AddOffset(AnimationData::VT_USERDATA, userData);
  }
  void add_labelData(flatbuffers::Offset<flatbuffers::Vector<flatbuffers::Offset<labelDataItem>>> labelData) {
    fbb_.AddOffset(AnimationData::VT_LABELDATA, labelData);
  }
  void add_meshsDataUV(flatbuffers::Offset<flatbuffers::Vector<flatbuffers::Offset<meshDataUV>>> meshsDataUV) {
    fbb_.AddOffset(AnimationData::VT_MESHSDATAUV, meshsDataUV);
  }
  void add_meshsDataIndices(flatbuffers::Offset<flatbuffers::Vector<flatbuffers::Offset<meshDataIndices>>> meshsDataIndices) {
    fbb_.AddOffset(AnimationData::VT_MESHSDATAINDICES, meshsDataIndices);
  }
  void add_startFrames(int16_t startFrames) {
    fbb_.AddElement<int16_t>(AnimationData::VT_STARTFRAMES, startFrames, 0);
  }
  void add_endFrames(int16_t endFrames) {
    fbb_.AddElement<int16_t>(AnimationData::VT_ENDFRAMES, endFrames, 0);
  }
  void add_totalFrames(int16_t totalFrames) {
    fbb_.AddElement<int16_t>(AnimationData::VT_TOTALFRAMES, totalFrames, 0);
  }
  void add_fps(int16_t fps) {
    fbb_.AddElement<int16_t>(AnimationData::VT_FPS, fps, 0);
  }
  void add_labelNum(int16_t labelNum) {
    fbb_.AddElement<int16_t>(AnimationData::VT_LABELNUM, labelNum, 0);
  }
  void add_canvasSizeW(int16_t canvasSizeW) {
    fbb_.AddElement<int16_t>(AnimationData::VT_CANVASSIZEW, canvasSizeW, 0);
  }
  void add_canvasSizeH(int16_t canvasSizeH) {
    fbb_.AddElement<int16_t>(AnimationData::VT_CANVASSIZEH, canvasSizeH, 0);
  }
  void add_canvasPvotX(float canvasPvotX) {
    fbb_.AddElement<float>(AnimationData::VT_CANVASPVOTX, canvasPvotX, 0.0f);
  }
  void add_canvasPvotY(float canvasPvotY) {
    fbb_.AddElement<float>(AnimationData::VT_CANVASPVOTY, canvasPvotY, 0.0f);
  }
  explicit AnimationDataBuilder(flatbuffers::FlatBufferBuilder &_fbb)
        : fbb_(_fbb) {
    start_ = fbb_.StartTable();
  }
  AnimationDataBuilder &operator=(const AnimationDataBuilder &);
  flatbuffers::Offset<AnimationData> Finish() {
    const auto end = fbb_.EndTable(start_);
    auto o = flatbuffers::Offset<AnimationData>(end);
    return o;
  }
};

inline flatbuffers::Offset<AnimationData> CreateAnimationData(
    flatbuffers::FlatBufferBuilder &_fbb,
    flatbuffers::Offset<flatbuffers::String> name = 0,
    flatbuffers::Offset<flatbuffers::Vector<flatbuffers::Offset<AnimationInitialData>>> defaultData = 0,
    flatbuffers::Offset<flatbuffers::Vector<flatbuffers::Offset<frameDataIndex>>> frameData = 0,
    flatbuffers::Offset<flatbuffers::Vector<flatbuffers::Offset<userDataPerFrame>>> userData = 0,
    flatbuffers::Offset<flatbuffers::Vector<flatbuffers::Offset<labelDataItem>>> labelData = 0,
    flatbuffers::Offset<flatbuffers::Vector<flatbuffers::Offset<meshDataUV>>> meshsDataUV = 0,
    flatbuffers::Offset<flatbuffers::Vector<flatbuffers::Offset<meshDataIndices>>> meshsDataIndices = 0,
    int16_t startFrames = 0,
    int16_t endFrames = 0,
    int16_t totalFrames = 0,
    int16_t fps = 0,
    int16_t labelNum = 0,
    int16_t canvasSizeW = 0,
    int16_t canvasSizeH = 0,
    float canvasPvotX = 0.0f,
    float canvasPvotY = 0.0f) {
  AnimationDataBuilder builder_(_fbb);
  builder_.add_canvasPvotY(canvasPvotY);
  builder_.add_canvasPvotX(canvasPvotX);
  builder_.add_meshsDataIndices(meshsDataIndices);
  builder_.add_meshsDataUV(meshsDataUV);
  builder_.add_labelData(labelData);
  builder_.add_userData(userData);
  builder_.add_frameData(frameData);
  builder_.add_defaultData(defaultData);
  builder_.add_name(name);
  builder_.add_canvasSizeH(canvasSizeH);
  builder_.add_canvasSizeW(canvasSizeW);
  builder_.add_labelNum(labelNum);
  builder_.add_fps(fps);
  builder_.add_totalFrames(totalFrames);
  builder_.add_endFrames(endFrames);
  builder_.add_startFrames(startFrames);
  return builder_.Finish();
}

inline flatbuffers::Offset<AnimationData> CreateAnimationDataDirect(
    flatbuffers::FlatBufferBuilder &_fbb,
    const char *name = nullptr,
    const std::vector<flatbuffers::Offset<AnimationInitialData>> *defaultData = nullptr,
    const std::vector<flatbuffers::Offset<frameDataIndex>> *frameData = nullptr,
    const std::vector<flatbuffers::Offset<userDataPerFrame>> *userData = nullptr,
    const std::vector<flatbuffers::Offset<labelDataItem>> *labelData = nullptr,
    const std::vector<flatbuffers::Offset<meshDataUV>> *meshsDataUV = nullptr,
    const std::vector<flatbuffers::Offset<meshDataIndices>> *meshsDataIndices = nullptr,
    int16_t startFrames = 0,
    int16_t endFrames = 0,
    int16_t totalFrames = 0,
    int16_t fps = 0,
    int16_t labelNum = 0,
    int16_t canvasSizeW = 0,
    int16_t canvasSizeH = 0,
    float canvasPvotX = 0.0f,
    float canvasPvotY = 0.0f) {
  return ss::ssfb::CreateAnimationData(
      _fbb,
      name ? _fbb.CreateString(name) : 0,
      defaultData ? _fbb.CreateVector<flatbuffers::Offset<AnimationInitialData>>(*defaultData) : 0,
      frameData ? _fbb.CreateVector<flatbuffers::Offset<frameDataIndex>>(*frameData) : 0,
      userData ? _fbb.CreateVector<flatbuffers::Offset<userDataPerFrame>>(*userData) : 0,
      labelData ? _fbb.CreateVector<flatbuffers::Offset<labelDataItem>>(*labelData) : 0,
      meshsDataUV ? _fbb.CreateVector<flatbuffers::Offset<meshDataUV>>(*meshsDataUV) : 0,
      meshsDataIndices ? _fbb.CreateVector<flatbuffers::Offset<meshDataIndices>>(*meshsDataIndices) : 0,
      startFrames,
      endFrames,
      totalFrames,
      fps,
      labelNum,
      canvasSizeW,
      canvasSizeH,
      canvasPvotX,
      canvasPvotY);
}

struct AnimationInitialData FLATBUFFERS_FINAL_CLASS : private flatbuffers::Table {
  enum {
    VT_INDEX = 4,
    VT_LOWFLAG = 6,
    VT_HIGHFLAG = 8,
    VT_PRIORITY = 10,
    VT_CELLINDEX = 12,
    VT_OPACITY = 14,
    VT_LOCALOPACITY = 16,
    VT_MASKLIMEN = 18,
    VT_POSITIONX = 20,
    VT_POSITIONY = 22,
    VT_POSITIONZ = 24,
    VT_PIVOTX = 26,
    VT_PIVOTY = 28,
    VT_ROTATIONX = 30,
    VT_ROTATIONY = 32,
    VT_ROTATIONZ = 34,
    VT_SCALEX = 36,
    VT_SCALEY = 38,
    VT_LOCALSCALEX = 40,
    VT_LOCALSCALEY = 42,
    VT_SIZE_X = 44,
    VT_SIZE_Y = 46,
    VT_UV_MOVE_X = 48,
    VT_UV_MOVE_Y = 50,
    VT_UV_ROTATION = 52,
    VT_UV_SCALE_X = 54,
    VT_UV_SCALE_Y = 56,
    VT_BOUNDINGRADIUS = 58,
    VT_INSTANCEVALUE_CURKEYFRAME = 60,
    VT_INSTANCEVALUE_STARTFRAME = 62,
    VT_INSTANCEVALUE_ENDFRAME = 64,
    VT_INSTANCEVALUE_LOOPNUM = 66,
    VT_INSTANCEVALUE_SPEED = 68,
    VT_INSTANCEVALUE_LOOPFLAG = 70,
    VT_EFFECTVALUE_CURKEYFRAME = 72,
    VT_EFFECTVALUE_STARTTIME = 74,
    VT_EFFECTVALUE_SPEED = 76,
    VT_EFFECTVALUE_LOOPFLAG = 78
  };
  int16_t index() const {
    return GetField<int16_t>(VT_INDEX, 0);
  }
  int32_t lowflag() const {
    return GetField<int32_t>(VT_LOWFLAG, 0);
  }
  int32_t highflag() const {
    return GetField<int32_t>(VT_HIGHFLAG, 0);
  }
  int16_t priority() const {
    return GetField<int16_t>(VT_PRIORITY, 0);
  }
  int16_t cellIndex() const {
    return GetField<int16_t>(VT_CELLINDEX, 0);
  }
  int16_t opacity() const {
    return GetField<int16_t>(VT_OPACITY, 0);
  }
  int16_t localopacity() const {
    return GetField<int16_t>(VT_LOCALOPACITY, 0);
  }
  int16_t masklimen() const {
    return GetField<int16_t>(VT_MASKLIMEN, 0);
  }
  float positionX() const {
    return GetField<float>(VT_POSITIONX, 0.0f);
  }
  float positionY() const {
    return GetField<float>(VT_POSITIONY, 0.0f);
  }
  float positionZ() const {
    return GetField<float>(VT_POSITIONZ, 0.0f);
  }
  float pivotX() const {
    return GetField<float>(VT_PIVOTX, 0.0f);
  }
  float pivotY() const {
    return GetField<float>(VT_PIVOTY, 0.0f);
  }
  float rotationX() const {
    return GetField<float>(VT_ROTATIONX, 0.0f);
  }
  float rotationY() const {
    return GetField<float>(VT_ROTATIONY, 0.0f);
  }
  float rotationZ() const {
    return GetField<float>(VT_ROTATIONZ, 0.0f);
  }
  float scaleX() const {
    return GetField<float>(VT_SCALEX, 0.0f);
  }
  float scaleY() const {
    return GetField<float>(VT_SCALEY, 0.0f);
  }
  float localscaleX() const {
    return GetField<float>(VT_LOCALSCALEX, 0.0f);
  }
  float localscaleY() const {
    return GetField<float>(VT_LOCALSCALEY, 0.0f);
  }
  float size_X() const {
    return GetField<float>(VT_SIZE_X, 0.0f);
  }
  float size_Y() const {
    return GetField<float>(VT_SIZE_Y, 0.0f);
  }
  float uv_move_X() const {
    return GetField<float>(VT_UV_MOVE_X, 0.0f);
  }
  float uv_move_Y() const {
    return GetField<float>(VT_UV_MOVE_Y, 0.0f);
  }
  float uv_rotation() const {
    return GetField<float>(VT_UV_ROTATION, 0.0f);
  }
  float uv_scale_X() const {
    return GetField<float>(VT_UV_SCALE_X, 0.0f);
  }
  float uv_scale_Y() const {
    return GetField<float>(VT_UV_SCALE_Y, 0.0f);
  }
  float boundingRadius() const {
    return GetField<float>(VT_BOUNDINGRADIUS, 0.0f);
  }
  int32_t instanceValue_curKeyframe() const {
    return GetField<int32_t>(VT_INSTANCEVALUE_CURKEYFRAME, 0);
  }
  int32_t instanceValue_startFrame() const {
    return GetField<int32_t>(VT_INSTANCEVALUE_STARTFRAME, 0);
  }
  int32_t instanceValue_endFrame() const {
    return GetField<int32_t>(VT_INSTANCEVALUE_ENDFRAME, 0);
  }
  int32_t instanceValue_loopNum() const {
    return GetField<int32_t>(VT_INSTANCEVALUE_LOOPNUM, 0);
  }
  float instanceValue_speed() const {
    return GetField<float>(VT_INSTANCEVALUE_SPEED, 0.0f);
  }
  int32_t instanceValue_loopflag() const {
    return GetField<int32_t>(VT_INSTANCEVALUE_LOOPFLAG, 0);
  }
  int32_t effectValue_curKeyframe() const {
    return GetField<int32_t>(VT_EFFECTVALUE_CURKEYFRAME, 0);
  }
  int32_t effectValue_startTime() const {
    return GetField<int32_t>(VT_EFFECTVALUE_STARTTIME, 0);
  }
  float effectValue_speed() const {
    return GetField<float>(VT_EFFECTVALUE_SPEED, 0.0f);
  }
  int32_t effectValue_loopflag() const {
    return GetField<int32_t>(VT_EFFECTVALUE_LOOPFLAG, 0);
  }
  bool Verify(flatbuffers::Verifier &verifier) const {
    return VerifyTableStart(verifier) &&
           VerifyField<int16_t>(verifier, VT_INDEX) &&
           VerifyField<int32_t>(verifier, VT_LOWFLAG) &&
           VerifyField<int32_t>(verifier, VT_HIGHFLAG) &&
           VerifyField<int16_t>(verifier, VT_PRIORITY) &&
           VerifyField<int16_t>(verifier, VT_CELLINDEX) &&
           VerifyField<int16_t>(verifier, VT_OPACITY) &&
           VerifyField<int16_t>(verifier, VT_LOCALOPACITY) &&
           VerifyField<int16_t>(verifier, VT_MASKLIMEN) &&
           VerifyField<float>(verifier, VT_POSITIONX) &&
           VerifyField<float>(verifier, VT_POSITIONY) &&
           VerifyField<float>(verifier, VT_POSITIONZ) &&
           VerifyField<float>(verifier, VT_PIVOTX) &&
           VerifyField<float>(verifier, VT_PIVOTY) &&
           VerifyField<float>(verifier, VT_ROTATIONX) &&
           VerifyField<float>(verifier, VT_ROTATIONY) &&
           VerifyField<float>(verifier, VT_ROTATIONZ) &&
           VerifyField<float>(verifier, VT_SCALEX) &&
           VerifyField<float>(verifier, VT_SCALEY) &&
           VerifyField<float>(verifier, VT_LOCALSCALEX) &&
           VerifyField<float>(verifier, VT_LOCALSCALEY) &&
           VerifyField<float>(verifier, VT_SIZE_X) &&
           VerifyField<float>(verifier, VT_SIZE_Y) &&
           VerifyField<float>(verifier, VT_UV_MOVE_X) &&
           VerifyField<float>(verifier, VT_UV_MOVE_Y) &&
           VerifyField<float>(verifier, VT_UV_ROTATION) &&
           VerifyField<float>(verifier, VT_UV_SCALE_X) &&
           VerifyField<float>(verifier, VT_UV_SCALE_Y) &&
           VerifyField<float>(verifier, VT_BOUNDINGRADIUS) &&
           VerifyField<int32_t>(verifier, VT_INSTANCEVALUE_CURKEYFRAME) &&
           VerifyField<int32_t>(verifier, VT_INSTANCEVALUE_STARTFRAME) &&
           VerifyField<int32_t>(verifier, VT_INSTANCEVALUE_ENDFRAME) &&
           VerifyField<int32_t>(verifier, VT_INSTANCEVALUE_LOOPNUM) &&
           VerifyField<float>(verifier, VT_INSTANCEVALUE_SPEED) &&
           VerifyField<int32_t>(verifier, VT_INSTANCEVALUE_LOOPFLAG) &&
           VerifyField<int32_t>(verifier, VT_EFFECTVALUE_CURKEYFRAME) &&
           VerifyField<int32_t>(verifier, VT_EFFECTVALUE_STARTTIME) &&
           VerifyField<float>(verifier, VT_EFFECTVALUE_SPEED) &&
           VerifyField<int32_t>(verifier, VT_EFFECTVALUE_LOOPFLAG) &&
           verifier.EndTable();
  }
};

struct AnimationInitialDataBuilder {
  flatbuffers::FlatBufferBuilder &fbb_;
  flatbuffers::uoffset_t start_;
  void add_index(int16_t index) {
    fbb_.AddElement<int16_t>(AnimationInitialData::VT_INDEX, index, 0);
  }
  void add_lowflag(int32_t lowflag) {
    fbb_.AddElement<int32_t>(AnimationInitialData::VT_LOWFLAG, lowflag, 0);
  }
  void add_highflag(int32_t highflag) {
    fbb_.AddElement<int32_t>(AnimationInitialData::VT_HIGHFLAG, highflag, 0);
  }
  void add_priority(int16_t priority) {
    fbb_.AddElement<int16_t>(AnimationInitialData::VT_PRIORITY, priority, 0);
  }
  void add_cellIndex(int16_t cellIndex) {
    fbb_.AddElement<int16_t>(AnimationInitialData::VT_CELLINDEX, cellIndex, 0);
  }
  void add_opacity(int16_t opacity) {
    fbb_.AddElement<int16_t>(AnimationInitialData::VT_OPACITY, opacity, 0);
  }
  void add_localopacity(int16_t localopacity) {
    fbb_.AddElement<int16_t>(AnimationInitialData::VT_LOCALOPACITY, localopacity, 0);
  }
  void add_masklimen(int16_t masklimen) {
    fbb_.AddElement<int16_t>(AnimationInitialData::VT_MASKLIMEN, masklimen, 0);
  }
  void add_positionX(float positionX) {
    fbb_.AddElement<float>(AnimationInitialData::VT_POSITIONX, positionX, 0.0f);
  }
  void add_positionY(float positionY) {
    fbb_.AddElement<float>(AnimationInitialData::VT_POSITIONY, positionY, 0.0f);
  }
  void add_positionZ(float positionZ) {
    fbb_.AddElement<float>(AnimationInitialData::VT_POSITIONZ, positionZ, 0.0f);
  }
  void add_pivotX(float pivotX) {
    fbb_.AddElement<float>(AnimationInitialData::VT_PIVOTX, pivotX, 0.0f);
  }
  void add_pivotY(float pivotY) {
    fbb_.AddElement<float>(AnimationInitialData::VT_PIVOTY, pivotY, 0.0f);
  }
  void add_rotationX(float rotationX) {
    fbb_.AddElement<float>(AnimationInitialData::VT_ROTATIONX, rotationX, 0.0f);
  }
  void add_rotationY(float rotationY) {
    fbb_.AddElement<float>(AnimationInitialData::VT_ROTATIONY, rotationY, 0.0f);
  }
  void add_rotationZ(float rotationZ) {
    fbb_.AddElement<float>(AnimationInitialData::VT_ROTATIONZ, rotationZ, 0.0f);
  }
  void add_scaleX(float scaleX) {
    fbb_.AddElement<float>(AnimationInitialData::VT_SCALEX, scaleX, 0.0f);
  }
  void add_scaleY(float scaleY) {
    fbb_.AddElement<float>(AnimationInitialData::VT_SCALEY, scaleY, 0.0f);
  }
  void add_localscaleX(float localscaleX) {
    fbb_.AddElement<float>(AnimationInitialData::VT_LOCALSCALEX, localscaleX, 0.0f);
  }
  void add_localscaleY(float localscaleY) {
    fbb_.AddElement<float>(AnimationInitialData::VT_LOCALSCALEY, localscaleY, 0.0f);
  }
  void add_size_X(float size_X) {
    fbb_.AddElement<float>(AnimationInitialData::VT_SIZE_X, size_X, 0.0f);
  }
  void add_size_Y(float size_Y) {
    fbb_.AddElement<float>(AnimationInitialData::VT_SIZE_Y, size_Y, 0.0f);
  }
  void add_uv_move_X(float uv_move_X) {
    fbb_.AddElement<float>(AnimationInitialData::VT_UV_MOVE_X, uv_move_X, 0.0f);
  }
  void add_uv_move_Y(float uv_move_Y) {
    fbb_.AddElement<float>(AnimationInitialData::VT_UV_MOVE_Y, uv_move_Y, 0.0f);
  }
  void add_uv_rotation(float uv_rotation) {
    fbb_.AddElement<float>(AnimationInitialData::VT_UV_ROTATION, uv_rotation, 0.0f);
  }
  void add_uv_scale_X(float uv_scale_X) {
    fbb_.AddElement<float>(AnimationInitialData::VT_UV_SCALE_X, uv_scale_X, 0.0f);
  }
  void add_uv_scale_Y(float uv_scale_Y) {
    fbb_.AddElement<float>(AnimationInitialData::VT_UV_SCALE_Y, uv_scale_Y, 0.0f);
  }
  void add_boundingRadius(float boundingRadius) {
    fbb_.AddElement<float>(AnimationInitialData::VT_BOUNDINGRADIUS, boundingRadius, 0.0f);
  }
  void add_instanceValue_curKeyframe(int32_t instanceValue_curKeyframe) {
    fbb_.AddElement<int32_t>(AnimationInitialData::VT_INSTANCEVALUE_CURKEYFRAME, instanceValue_curKeyframe, 0);
  }
  void add_instanceValue_startFrame(int32_t instanceValue_startFrame) {
    fbb_.AddElement<int32_t>(AnimationInitialData::VT_INSTANCEVALUE_STARTFRAME, instanceValue_startFrame, 0);
  }
  void add_instanceValue_endFrame(int32_t instanceValue_endFrame) {
    fbb_.AddElement<int32_t>(AnimationInitialData::VT_INSTANCEVALUE_ENDFRAME, instanceValue_endFrame, 0);
  }
  void add_instanceValue_loopNum(int32_t instanceValue_loopNum) {
    fbb_.AddElement<int32_t>(AnimationInitialData::VT_INSTANCEVALUE_LOOPNUM, instanceValue_loopNum, 0);
  }
  void add_instanceValue_speed(float instanceValue_speed) {
    fbb_.AddElement<float>(AnimationInitialData::VT_INSTANCEVALUE_SPEED, instanceValue_speed, 0.0f);
  }
  void add_instanceValue_loopflag(int32_t instanceValue_loopflag) {
    fbb_.AddElement<int32_t>(AnimationInitialData::VT_INSTANCEVALUE_LOOPFLAG, instanceValue_loopflag, 0);
  }
  void add_effectValue_curKeyframe(int32_t effectValue_curKeyframe) {
    fbb_.AddElement<int32_t>(AnimationInitialData::VT_EFFECTVALUE_CURKEYFRAME, effectValue_curKeyframe, 0);
  }
  void add_effectValue_startTime(int32_t effectValue_startTime) {
    fbb_.AddElement<int32_t>(AnimationInitialData::VT_EFFECTVALUE_STARTTIME, effectValue_startTime, 0);
  }
  void add_effectValue_speed(float effectValue_speed) {
    fbb_.AddElement<float>(AnimationInitialData::VT_EFFECTVALUE_SPEED, effectValue_speed, 0.0f);
  }
  void add_effectValue_loopflag(int32_t effectValue_loopflag) {
    fbb_.AddElement<int32_t>(AnimationInitialData::VT_EFFECTVALUE_LOOPFLAG, effectValue_loopflag, 0);
  }
  explicit AnimationInitialDataBuilder(flatbuffers::FlatBufferBuilder &_fbb)
        : fbb_(_fbb) {
    start_ = fbb_.StartTable();
  }
  AnimationInitialDataBuilder &operator=(const AnimationInitialDataBuilder &);
  flatbuffers::Offset<AnimationInitialData> Finish() {
    const auto end = fbb_.EndTable(start_);
    auto o = flatbuffers::Offset<AnimationInitialData>(end);
    return o;
  }
};

inline flatbuffers::Offset<AnimationInitialData> CreateAnimationInitialData(
    flatbuffers::FlatBufferBuilder &_fbb,
    int16_t index = 0,
    int32_t lowflag = 0,
    int32_t highflag = 0,
    int16_t priority = 0,
    int16_t cellIndex = 0,
    int16_t opacity = 0,
    int16_t localopacity = 0,
    int16_t masklimen = 0,
    float positionX = 0.0f,
    float positionY = 0.0f,
    float positionZ = 0.0f,
    float pivotX = 0.0f,
    float pivotY = 0.0f,
    float rotationX = 0.0f,
    float rotationY = 0.0f,
    float rotationZ = 0.0f,
    float scaleX = 0.0f,
    float scaleY = 0.0f,
    float localscaleX = 0.0f,
    float localscaleY = 0.0f,
    float size_X = 0.0f,
    float size_Y = 0.0f,
    float uv_move_X = 0.0f,
    float uv_move_Y = 0.0f,
    float uv_rotation = 0.0f,
    float uv_scale_X = 0.0f,
    float uv_scale_Y = 0.0f,
    float boundingRadius = 0.0f,
    int32_t instanceValue_curKeyframe = 0,
    int32_t instanceValue_startFrame = 0,
    int32_t instanceValue_endFrame = 0,
    int32_t instanceValue_loopNum = 0,
    float instanceValue_speed = 0.0f,
    int32_t instanceValue_loopflag = 0,
    int32_t effectValue_curKeyframe = 0,
    int32_t effectValue_startTime = 0,
    float effectValue_speed = 0.0f,
    int32_t effectValue_loopflag = 0) {
  AnimationInitialDataBuilder builder_(_fbb);
  builder_.add_effectValue_loopflag(effectValue_loopflag);
  builder_.add_effectValue_speed(effectValue_speed);
  builder_.add_effectValue_startTime(effectValue_startTime);
  builder_.add_effectValue_curKeyframe(effectValue_curKeyframe);
  builder_.add_instanceValue_loopflag(instanceValue_loopflag);
  builder_.add_instanceValue_speed(instanceValue_speed);
  builder_.add_instanceValue_loopNum(instanceValue_loopNum);
  builder_.add_instanceValue_endFrame(instanceValue_endFrame);
  builder_.add_instanceValue_startFrame(instanceValue_startFrame);
  builder_.add_instanceValue_curKeyframe(instanceValue_curKeyframe);
  builder_.add_boundingRadius(boundingRadius);
  builder_.add_uv_scale_Y(uv_scale_Y);
  builder_.add_uv_scale_X(uv_scale_X);
  builder_.add_uv_rotation(uv_rotation);
  builder_.add_uv_move_Y(uv_move_Y);
  builder_.add_uv_move_X(uv_move_X);
  builder_.add_size_Y(size_Y);
  builder_.add_size_X(size_X);
  builder_.add_localscaleY(localscaleY);
  builder_.add_localscaleX(localscaleX);
  builder_.add_scaleY(scaleY);
  builder_.add_scaleX(scaleX);
  builder_.add_rotationZ(rotationZ);
  builder_.add_rotationY(rotationY);
  builder_.add_rotationX(rotationX);
  builder_.add_pivotY(pivotY);
  builder_.add_pivotX(pivotX);
  builder_.add_positionZ(positionZ);
  builder_.add_positionY(positionY);
  builder_.add_positionX(positionX);
  builder_.add_highflag(highflag);
  builder_.add_lowflag(lowflag);
  builder_.add_masklimen(masklimen);
  builder_.add_localopacity(localopacity);
  builder_.add_opacity(opacity);
  builder_.add_cellIndex(cellIndex);
  builder_.add_priority(priority);
  builder_.add_index(index);
  return builder_.Finish();
}

struct PartData FLATBUFFERS_FINAL_CLASS : private flatbuffers::Table {
  enum {
    VT_NAME = 4,
    VT_INDEX = 6,
    VT_PARENTINDEX = 8,
    VT_TYPE = 10,
    VT_BOUNDSTYPE = 12,
    VT_ALPHABLENDTYPE = 14,
    VT_REFNAME = 16,
    VT_EFFECTFILENAME = 18,
    VT_COLORLABEL = 20,
    VT_MASKINFLUENCE = 22
  };
  const flatbuffers::String *name() const {
    return GetPointer<const flatbuffers::String *>(VT_NAME);
  }
  int16_t index() const {
    return GetField<int16_t>(VT_INDEX, 0);
  }
  int16_t parentIndex() const {
    return GetField<int16_t>(VT_PARENTINDEX, 0);
  }
  SsPartType type() const {
    return static_cast<SsPartType>(GetField<int8_t>(VT_TYPE, 0));
  }
  int16_t boundsType() const {
    return GetField<int16_t>(VT_BOUNDSTYPE, 0);
  }
  int16_t alphaBlendType() const {
    return GetField<int16_t>(VT_ALPHABLENDTYPE, 0);
  }
  const flatbuffers::String *refname() const {
    return GetPointer<const flatbuffers::String *>(VT_REFNAME);
  }
  const flatbuffers::String *effectfilename() const {
    return GetPointer<const flatbuffers::String *>(VT_EFFECTFILENAME);
  }
  const flatbuffers::String *colorLabel() const {
    return GetPointer<const flatbuffers::String *>(VT_COLORLABEL);
  }
  int16_t maskInfluence() const {
    return GetField<int16_t>(VT_MASKINFLUENCE, 0);
  }
  bool Verify(flatbuffers::Verifier &verifier) const {
    return VerifyTableStart(verifier) &&
           VerifyOffset(verifier, VT_NAME) &&
           verifier.VerifyString(name()) &&
           VerifyField<int16_t>(verifier, VT_INDEX) &&
           VerifyField<int16_t>(verifier, VT_PARENTINDEX) &&
           VerifyField<int8_t>(verifier, VT_TYPE) &&
           VerifyField<int16_t>(verifier, VT_BOUNDSTYPE) &&
           VerifyField<int16_t>(verifier, VT_ALPHABLENDTYPE) &&
           VerifyOffset(verifier, VT_REFNAME) &&
           verifier.VerifyString(refname()) &&
           VerifyOffset(verifier, VT_EFFECTFILENAME) &&
           verifier.VerifyString(effectfilename()) &&
           VerifyOffset(verifier, VT_COLORLABEL) &&
           verifier.VerifyString(colorLabel()) &&
           VerifyField<int16_t>(verifier, VT_MASKINFLUENCE) &&
           verifier.EndTable();
  }
};

struct PartDataBuilder {
  flatbuffers::FlatBufferBuilder &fbb_;
  flatbuffers::uoffset_t start_;
  void add_name(flatbuffers::Offset<flatbuffers::String> name) {
    fbb_.AddOffset(PartData::VT_NAME, name);
  }
  void add_index(int16_t index) {
    fbb_.AddElement<int16_t>(PartData::VT_INDEX, index, 0);
  }
  void add_parentIndex(int16_t parentIndex) {
    fbb_.AddElement<int16_t>(PartData::VT_PARENTINDEX, parentIndex, 0);
  }
  void add_type(SsPartType type) {
    fbb_.AddElement<int8_t>(PartData::VT_TYPE, static_cast<int8_t>(type), 0);
  }
  void add_boundsType(int16_t boundsType) {
    fbb_.AddElement<int16_t>(PartData::VT_BOUNDSTYPE, boundsType, 0);
  }
  void add_alphaBlendType(int16_t alphaBlendType) {
    fbb_.AddElement<int16_t>(PartData::VT_ALPHABLENDTYPE, alphaBlendType, 0);
  }
  void add_refname(flatbuffers::Offset<flatbuffers::String> refname) {
    fbb_.AddOffset(PartData::VT_REFNAME, refname);
  }
  void add_effectfilename(flatbuffers::Offset<flatbuffers::String> effectfilename) {
    fbb_.AddOffset(PartData::VT_EFFECTFILENAME, effectfilename);
  }
  void add_colorLabel(flatbuffers::Offset<flatbuffers::String> colorLabel) {
    fbb_.AddOffset(PartData::VT_COLORLABEL, colorLabel);
  }
  void add_maskInfluence(int16_t maskInfluence) {
    fbb_.AddElement<int16_t>(PartData::VT_MASKINFLUENCE, maskInfluence, 0);
  }
  explicit PartDataBuilder(flatbuffers::FlatBufferBuilder &_fbb)
        : fbb_(_fbb) {
    start_ = fbb_.StartTable();
  }
  PartDataBuilder &operator=(const PartDataBuilder &);
  flatbuffers::Offset<PartData> Finish() {
    const auto end = fbb_.EndTable(start_);
    auto o = flatbuffers::Offset<PartData>(end);
    return o;
  }
};

inline flatbuffers::Offset<PartData> CreatePartData(
    flatbuffers::FlatBufferBuilder &_fbb,
    flatbuffers::Offset<flatbuffers::String> name = 0,
    int16_t index = 0,
    int16_t parentIndex = 0,
    SsPartType type = SsPartType_Nulltype,
    int16_t boundsType = 0,
    int16_t alphaBlendType = 0,
    flatbuffers::Offset<flatbuffers::String> refname = 0,
    flatbuffers::Offset<flatbuffers::String> effectfilename = 0,
    flatbuffers::Offset<flatbuffers::String> colorLabel = 0,
    int16_t maskInfluence = 0) {
  PartDataBuilder builder_(_fbb);
  builder_.add_colorLabel(colorLabel);
  builder_.add_effectfilename(effectfilename);
  builder_.add_refname(refname);
  builder_.add_name(name);
  builder_.add_maskInfluence(maskInfluence);
  builder_.add_alphaBlendType(alphaBlendType);
  builder_.add_boundsType(boundsType);
  builder_.add_parentIndex(parentIndex);
  builder_.add_index(index);
  builder_.add_type(type);
  return builder_.Finish();
}

inline flatbuffers::Offset<PartData> CreatePartDataDirect(
    flatbuffers::FlatBufferBuilder &_fbb,
    const char *name = nullptr,
    int16_t index = 0,
    int16_t parentIndex = 0,
    SsPartType type = SsPartType_Nulltype,
    int16_t boundsType = 0,
    int16_t alphaBlendType = 0,
    const char *refname = nullptr,
    const char *effectfilename = nullptr,
    const char *colorLabel = nullptr,
    int16_t maskInfluence = 0) {
  return ss::ssfb::CreatePartData(
      _fbb,
      name ? _fbb.CreateString(name) : 0,
      index,
      parentIndex,
      type,
      boundsType,
      alphaBlendType,
      refname ? _fbb.CreateString(refname) : 0,
      effectfilename ? _fbb.CreateString(effectfilename) : 0,
      colorLabel ? _fbb.CreateString(colorLabel) : 0,
      maskInfluence);
}

struct AnimePackData FLATBUFFERS_FINAL_CLASS : private flatbuffers::Table {
  enum {
    VT_NAME = 4,
    VT_PARTS = 6,
    VT_ANIMATIONS = 8
  };
  const flatbuffers::String *name() const {
    return GetPointer<const flatbuffers::String *>(VT_NAME);
  }
  const flatbuffers::Vector<flatbuffers::Offset<PartData>> *parts() const {
    return GetPointer<const flatbuffers::Vector<flatbuffers::Offset<PartData>> *>(VT_PARTS);
  }
  const flatbuffers::Vector<flatbuffers::Offset<AnimationData>> *animations() const {
    return GetPointer<const flatbuffers::Vector<flatbuffers::Offset<AnimationData>> *>(VT_ANIMATIONS);
  }
  bool Verify(flatbuffers::Verifier &verifier) const {
    return VerifyTableStart(verifier) &&
           VerifyOffset(verifier, VT_NAME) &&
           verifier.VerifyString(name()) &&
           VerifyOffset(verifier, VT_PARTS) &&
           verifier.VerifyVector(parts()) &&
           verifier.VerifyVectorOfTables(parts()) &&
           VerifyOffset(verifier, VT_ANIMATIONS) &&
           verifier.VerifyVector(animations()) &&
           verifier.VerifyVectorOfTables(animations()) &&
           verifier.EndTable();
  }
};

struct AnimePackDataBuilder {
  flatbuffers::FlatBufferBuilder &fbb_;
  flatbuffers::uoffset_t start_;
  void add_name(flatbuffers::Offset<flatbuffers::String> name) {
    fbb_.AddOffset(AnimePackData::VT_NAME, name);
  }
  void add_parts(flatbuffers::Offset<flatbuffers::Vector<flatbuffers::Offset<PartData>>> parts) {
    fbb_.AddOffset(AnimePackData::VT_PARTS, parts);
  }
  void add_animations(flatbuffers::Offset<flatbuffers::Vector<flatbuffers::Offset<AnimationData>>> animations) {
    fbb_.AddOffset(AnimePackData::VT_ANIMATIONS, animations);
  }
  explicit AnimePackDataBuilder(flatbuffers::FlatBufferBuilder &_fbb)
        : fbb_(_fbb) {
    start_ = fbb_.StartTable();
  }
  AnimePackDataBuilder &operator=(const AnimePackDataBuilder &);
  flatbuffers::Offset<AnimePackData> Finish() {
    const auto end = fbb_.EndTable(start_);
    auto o = flatbuffers::Offset<AnimePackData>(end);
    return o;
  }
};

inline flatbuffers::Offset<AnimePackData> CreateAnimePackData(
    flatbuffers::FlatBufferBuilder &_fbb,
    flatbuffers::Offset<flatbuffers::String> name = 0,
    flatbuffers::Offset<flatbuffers::Vector<flatbuffers::Offset<PartData>>> parts = 0,
    flatbuffers::Offset<flatbuffers::Vector<flatbuffers::Offset<AnimationData>>> animations = 0) {
  AnimePackDataBuilder builder_(_fbb);
  builder_.add_animations(animations);
  builder_.add_parts(parts);
  builder_.add_name(name);
  return builder_.Finish();
}

inline flatbuffers::Offset<AnimePackData> CreateAnimePackDataDirect(
    flatbuffers::FlatBufferBuilder &_fbb,
    const char *name = nullptr,
    const std::vector<flatbuffers::Offset<PartData>> *parts = nullptr,
    const std::vector<flatbuffers::Offset<AnimationData>> *animations = nullptr) {
  return ss::ssfb::CreateAnimePackData(
      _fbb,
      name ? _fbb.CreateString(name) : 0,
      parts ? _fbb.CreateVector<flatbuffers::Offset<PartData>>(*parts) : 0,
      animations ? _fbb.CreateVector<flatbuffers::Offset<AnimationData>>(*animations) : 0);
}

struct ProjectData FLATBUFFERS_FINAL_CLASS : private flatbuffers::Table {
  enum {
    VT_DATAID = 4,
    VT_VERSION = 6,
    VT_FLAGS = 8,
    VT_IMAGEBASEDIR = 10,
    VT_CELLS = 12,
    VT_ANIMEPACKS = 14,
    VT_EFFECTFILELIST = 16,
    VT_NUMCELLS = 18,
    VT_NUMANIMEPACKS = 20,
    VT_NUMEFFECTFILELIST = 22
  };
  uint32_t dataId() const {
    return GetField<uint32_t>(VT_DATAID, 0);
  }
  uint32_t version() const {
    return GetField<uint32_t>(VT_VERSION, 0);
  }
  uint32_t flags() const {
    return GetField<uint32_t>(VT_FLAGS, 0);
  }
  const flatbuffers::String *imageBaseDir() const {
    return GetPointer<const flatbuffers::String *>(VT_IMAGEBASEDIR);
  }
  const flatbuffers::Vector<flatbuffers::Offset<Cell>> *cells() const {
    return GetPointer<const flatbuffers::Vector<flatbuffers::Offset<Cell>> *>(VT_CELLS);
  }
  const flatbuffers::Vector<flatbuffers::Offset<AnimePackData>> *animePacks() const {
    return GetPointer<const flatbuffers::Vector<flatbuffers::Offset<AnimePackData>> *>(VT_ANIMEPACKS);
  }
  const flatbuffers::Vector<flatbuffers::Offset<EffectFile>> *effectFileList() const {
    return GetPointer<const flatbuffers::Vector<flatbuffers::Offset<EffectFile>> *>(VT_EFFECTFILELIST);
  }
  int16_t numCells() const {
    return GetField<int16_t>(VT_NUMCELLS, 0);
  }
  int16_t numAnimePacks() const {
    return GetField<int16_t>(VT_NUMANIMEPACKS, 0);
  }
  int16_t numEffectFileList() const {
    return GetField<int16_t>(VT_NUMEFFECTFILELIST, 0);
  }
  bool Verify(flatbuffers::Verifier &verifier) const {
    return VerifyTableStart(verifier) &&
           VerifyField<uint32_t>(verifier, VT_DATAID) &&
           VerifyField<uint32_t>(verifier, VT_VERSION) &&
           VerifyField<uint32_t>(verifier, VT_FLAGS) &&
           VerifyOffset(verifier, VT_IMAGEBASEDIR) &&
           verifier.VerifyString(imageBaseDir()) &&
           VerifyOffset(verifier, VT_CELLS) &&
           verifier.VerifyVector(cells()) &&
           verifier.VerifyVectorOfTables(cells()) &&
           VerifyOffset(verifier, VT_ANIMEPACKS) &&
           verifier.VerifyVector(animePacks()) &&
           verifier.VerifyVectorOfTables(animePacks()) &&
           VerifyOffset(verifier, VT_EFFECTFILELIST) &&
           verifier.VerifyVector(effectFileList()) &&
           verifier.VerifyVectorOfTables(effectFileList()) &&
           VerifyField<int16_t>(verifier, VT_NUMCELLS) &&
           VerifyField<int16_t>(verifier, VT_NUMANIMEPACKS) &&
           VerifyField<int16_t>(verifier, VT_NUMEFFECTFILELIST) &&
           verifier.EndTable();
  }
};

struct ProjectDataBuilder {
  flatbuffers::FlatBufferBuilder &fbb_;
  flatbuffers::uoffset_t start_;
  void add_dataId(uint32_t dataId) {
    fbb_.AddElement<uint32_t>(ProjectData::VT_DATAID, dataId, 0);
  }
  void add_version(uint32_t version) {
    fbb_.AddElement<uint32_t>(ProjectData::VT_VERSION, version, 0);
  }
  void add_flags(uint32_t flags) {
    fbb_.AddElement<uint32_t>(ProjectData::VT_FLAGS, flags, 0);
  }
  void add_imageBaseDir(flatbuffers::Offset<flatbuffers::String> imageBaseDir) {
    fbb_.AddOffset(ProjectData::VT_IMAGEBASEDIR, imageBaseDir);
  }
  void add_cells(flatbuffers::Offset<flatbuffers::Vector<flatbuffers::Offset<Cell>>> cells) {
    fbb_.AddOffset(ProjectData::VT_CELLS, cells);
  }
  void add_animePacks(flatbuffers::Offset<flatbuffers::Vector<flatbuffers::Offset<AnimePackData>>> animePacks) {
    fbb_.AddOffset(ProjectData::VT_ANIMEPACKS, animePacks);
  }
  void add_effectFileList(flatbuffers::Offset<flatbuffers::Vector<flatbuffers::Offset<EffectFile>>> effectFileList) {
    fbb_.AddOffset(ProjectData::VT_EFFECTFILELIST, effectFileList);
  }
  void add_numCells(int16_t numCells) {
    fbb_.AddElement<int16_t>(ProjectData::VT_NUMCELLS, numCells, 0);
  }
  void add_numAnimePacks(int16_t numAnimePacks) {
    fbb_.AddElement<int16_t>(ProjectData::VT_NUMANIMEPACKS, numAnimePacks, 0);
  }
  void add_numEffectFileList(int16_t numEffectFileList) {
    fbb_.AddElement<int16_t>(ProjectData::VT_NUMEFFECTFILELIST, numEffectFileList, 0);
  }
  explicit ProjectDataBuilder(flatbuffers::FlatBufferBuilder &_fbb)
        : fbb_(_fbb) {
    start_ = fbb_.StartTable();
  }
  ProjectDataBuilder &operator=(const ProjectDataBuilder &);
  flatbuffers::Offset<ProjectData> Finish() {
    const auto end = fbb_.EndTable(start_);
    auto o = flatbuffers::Offset<ProjectData>(end);
    return o;
  }
};

inline flatbuffers::Offset<ProjectData> CreateProjectData(
    flatbuffers::FlatBufferBuilder &_fbb,
    uint32_t dataId = 0,
    uint32_t version = 0,
    uint32_t flags = 0,
    flatbuffers::Offset<flatbuffers::String> imageBaseDir = 0,
    flatbuffers::Offset<flatbuffers::Vector<flatbuffers::Offset<Cell>>> cells = 0,
    flatbuffers::Offset<flatbuffers::Vector<flatbuffers::Offset<AnimePackData>>> animePacks = 0,
    flatbuffers::Offset<flatbuffers::Vector<flatbuffers::Offset<EffectFile>>> effectFileList = 0,
    int16_t numCells = 0,
    int16_t numAnimePacks = 0,
    int16_t numEffectFileList = 0) {
  ProjectDataBuilder builder_(_fbb);
  builder_.add_effectFileList(effectFileList);
  builder_.add_animePacks(animePacks);
  builder_.add_cells(cells);
  builder_.add_imageBaseDir(imageBaseDir);
  builder_.add_flags(flags);
  builder_.add_version(version);
  builder_.add_dataId(dataId);
  builder_.add_numEffectFileList(numEffectFileList);
  builder_.add_numAnimePacks(numAnimePacks);
  builder_.add_numCells(numCells);
  return builder_.Finish();
}

inline flatbuffers::Offset<ProjectData> CreateProjectDataDirect(
    flatbuffers::FlatBufferBuilder &_fbb,
    uint32_t dataId = 0,
    uint32_t version = 0,
    uint32_t flags = 0,
    const char *imageBaseDir = nullptr,
    const std::vector<flatbuffers::Offset<Cell>> *cells = nullptr,
    const std::vector<flatbuffers::Offset<AnimePackData>> *animePacks = nullptr,
    const std::vector<flatbuffers::Offset<EffectFile>> *effectFileList = nullptr,
    int16_t numCells = 0,
    int16_t numAnimePacks = 0,
    int16_t numEffectFileList = 0) {
  return ss::ssfb::CreateProjectData(
      _fbb,
      dataId,
      version,
      flags,
      imageBaseDir ? _fbb.CreateString(imageBaseDir) : 0,
      cells ? _fbb.CreateVector<flatbuffers::Offset<Cell>>(*cells) : 0,
      animePacks ? _fbb.CreateVector<flatbuffers::Offset<AnimePackData>>(*animePacks) : 0,
      effectFileList ? _fbb.CreateVector<flatbuffers::Offset<EffectFile>>(*effectFileList) : 0,
      numCells,
      numAnimePacks,
      numEffectFileList);
}

inline bool VerifyEffectNodeBehavior(flatbuffers::Verifier &verifier, const void *obj, EffectNodeBehavior type) {
  switch (type) {
    case EffectNodeBehavior_NONE: {
      return true;
    }
    case EffectNodeBehavior_EffectParticleElementBasic: {
      return true;
    }
    case EffectNodeBehavior_EffectParticleElementRndSeedChange: {
      return true;
    }
    case EffectNodeBehavior_EffectParticleElementDelay: {
      return true;
    }
    case EffectNodeBehavior_EffectParticleElementGravity: {
      return true;
    }
    case EffectNodeBehavior_EffectParticleElementPosition: {
      return true;
    }
    case EffectNodeBehavior_EffectParticleElementRotation: {
      return true;
    }
    case EffectNodeBehavior_EffectParticleElementRotationTrans: {
      return true;
    }
    case EffectNodeBehavior_EffectParticleElementTransSpeed: {
      return true;
    }
    case EffectNodeBehavior_EffectParticleElementTangentialAcceleration: {
      return true;
    }
    case EffectNodeBehavior_EffectParticleElementInitColor: {
      return true;
    }
    case EffectNodeBehavior_EffectParticleElementTransColor: {
      return true;
    }
    case EffectNodeBehavior_EffectParticleElementAlphaFade: {
      return true;
    }
    case EffectNodeBehavior_EffectParticleElementSize: {
      return true;
    }
    case EffectNodeBehavior_EffectParticleElementTransSize: {
      return true;
    }
    case EffectNodeBehavior_EffectParticlePointGravity: {
      return true;
    }
    case EffectNodeBehavior_EffectParticleTurnToDirectionEnabled: {
      return true;
    }
    case EffectNodeBehavior_EffectParticleInfiniteEmitEnabled: {
      return true;
    }
    default: return false;
  }
}

inline bool VerifyEffectNodeBehaviorVector(flatbuffers::Verifier &verifier, const flatbuffers::Vector<flatbuffers::Offset<void>> *values, const flatbuffers::Vector<uint8_t> *types) {
  if (!values || !types) return !values && !types;
  if (values->size() != types->size()) return false;
  for (flatbuffers::uoffset_t i = 0; i < values->size(); ++i) {
    if (!VerifyEffectNodeBehavior(
        verifier,  values->Get(i), types->GetEnum<EffectNodeBehavior>(i))) {
      return false;
    }
  }
  return true;
}

inline bool VerifyuserDataValue(flatbuffers::Verifier &verifier, const void *obj, userDataValue type) {
  switch (type) {
    case userDataValue_NONE: {
      return true;
    }
    case userDataValue_userDataInteger: {
      return true;
    }
    case userDataValue_userDataRect: {
      return true;
    }
    case userDataValue_userDataPoint: {
      return true;
    }
    case userDataValue_userDataString: {
      auto ptr = reinterpret_cast<const userDataString *>(obj);
      return verifier.VerifyTable(ptr);
    }
    default: return false;
  }
}

inline bool VerifyuserDataValueVector(flatbuffers::Verifier &verifier, const flatbuffers::Vector<flatbuffers::Offset<void>> *values, const flatbuffers::Vector<uint8_t> *types) {
  if (!values || !types) return !values && !types;
  if (values->size() != types->size()) return false;
  for (flatbuffers::uoffset_t i = 0; i < values->size(); ++i) {
    if (!VerifyuserDataValue(
        verifier,  values->Get(i), types->GetEnum<userDataValue>(i))) {
      return false;
    }
  }
  return true;
}

inline const ss::ssfb::ProjectData *GetProjectData(const void *buf) {
  return flatbuffers::GetRoot<ss::ssfb::ProjectData>(buf);
}

inline const ss::ssfb::ProjectData *GetSizePrefixedProjectData(const void *buf) {
  return flatbuffers::GetSizePrefixedRoot<ss::ssfb::ProjectData>(buf);
}

inline const char *ProjectDataIdentifier() {
  return "SSFB";
}

inline bool ProjectDataBufferHasIdentifier(const void *buf) {
  return flatbuffers::BufferHasIdentifier(
      buf, ProjectDataIdentifier());
}

inline bool VerifyProjectDataBuffer(
    flatbuffers::Verifier &verifier) {
  return verifier.VerifyBuffer<ss::ssfb::ProjectData>(ProjectDataIdentifier());
}

inline bool VerifySizePrefixedProjectDataBuffer(
    flatbuffers::Verifier &verifier) {
  return verifier.VerifySizePrefixedBuffer<ss::ssfb::ProjectData>(ProjectDataIdentifier());
}

inline void FinishProjectDataBuffer(
    flatbuffers::FlatBufferBuilder &fbb,
    flatbuffers::Offset<ss::ssfb::ProjectData> root) {
  fbb.Finish(root, ProjectDataIdentifier());
}

inline void FinishSizePrefixedProjectDataBuffer(
    flatbuffers::FlatBufferBuilder &fbb,
    flatbuffers::Offset<ss::ssfb::ProjectData> root) {
  fbb.FinishSizePrefixed(root, ProjectDataIdentifier());
}

}  // namespace ssfb
}  // namespace ss

#endif  // FLATBUFFERS_GENERATED_SSFB_SS_SSFB_H_
