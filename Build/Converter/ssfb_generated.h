// automatically generated by the FlatBuffers compiler, do not modify


#ifndef FLATBUFFERS_GENERATED_SSFB_SS_SSFB_H_
#define FLATBUFFERS_GENERATED_SSFB_SS_SSFB_H_

#include "flatbuffers/flatbuffers.h"

namespace ss {
namespace ssfb {

struct EffectParticleInfiniteEmitEnabled;

struct EffectParticleTurnToDirectionEnabled;

struct EffectParticlePointGravity;

struct EffectParticleElementTransSize;

struct EffectParticleElementSize;

struct EffectParticleElementAlphaFade;

struct EffectParticleElementTransColor;

struct EffectParticleElementInitColor;

struct EffectParticleElementTangentialAcceleration;

struct EffectParticleElementTransSpeed;

struct EffectParticleElementRotationTrans;

struct EffectParticleElementRotation;

struct EffectParticleElementPosition;

struct EffectParticleElementGravity;

struct EffectParticleElementDelay;

struct EffectParticleElementRndSeedChange;

struct EffectParticleElementBasic;

struct EffectNode;
struct EffectNodeT;

struct EffectFile;
struct EffectFileT;

struct CellMap;
struct CellMapT;

struct Cell;
struct CellT;

struct meshDataUV;
struct meshDataUVT;

struct meshDataIndices;
struct meshDataIndicesT;

struct partState;
struct partStateT;

struct frameDataIndex;
struct frameDataIndexT;

struct userDataInteger;

struct userDataRect;

struct userDataPoint;

struct userDataString;
struct userDataStringT;

struct userDataItem;
struct userDataItemT;

struct userDataPerFrame;
struct userDataPerFrameT;

struct labelDataItem;
struct labelDataItemT;

struct AnimationData;
struct AnimationDataT;

struct AnimationInitialData;
struct AnimationInitialDataT;

struct PartData;
struct PartDataT;

struct AnimePackData;
struct AnimePackDataT;

struct ProjectData;
struct ProjectDataT;

bool operator==(const EffectParticleInfiniteEmitEnabled &lhs, const EffectParticleInfiniteEmitEnabled &rhs);
bool operator==(const EffectParticleTurnToDirectionEnabled &lhs, const EffectParticleTurnToDirectionEnabled &rhs);
bool operator==(const EffectParticlePointGravity &lhs, const EffectParticlePointGravity &rhs);
bool operator==(const EffectParticleElementTransSize &lhs, const EffectParticleElementTransSize &rhs);
bool operator==(const EffectParticleElementSize &lhs, const EffectParticleElementSize &rhs);
bool operator==(const EffectParticleElementAlphaFade &lhs, const EffectParticleElementAlphaFade &rhs);
bool operator==(const EffectParticleElementTransColor &lhs, const EffectParticleElementTransColor &rhs);
bool operator==(const EffectParticleElementInitColor &lhs, const EffectParticleElementInitColor &rhs);
bool operator==(const EffectParticleElementTangentialAcceleration &lhs, const EffectParticleElementTangentialAcceleration &rhs);
bool operator==(const EffectParticleElementTransSpeed &lhs, const EffectParticleElementTransSpeed &rhs);
bool operator==(const EffectParticleElementRotationTrans &lhs, const EffectParticleElementRotationTrans &rhs);
bool operator==(const EffectParticleElementRotation &lhs, const EffectParticleElementRotation &rhs);
bool operator==(const EffectParticleElementPosition &lhs, const EffectParticleElementPosition &rhs);
bool operator==(const EffectParticleElementGravity &lhs, const EffectParticleElementGravity &rhs);
bool operator==(const EffectParticleElementDelay &lhs, const EffectParticleElementDelay &rhs);
bool operator==(const EffectParticleElementRndSeedChange &lhs, const EffectParticleElementRndSeedChange &rhs);
bool operator==(const EffectParticleElementBasic &lhs, const EffectParticleElementBasic &rhs);
bool operator==(const EffectNodeT &lhs, const EffectNodeT &rhs);
bool operator==(const EffectFileT &lhs, const EffectFileT &rhs);
bool operator==(const CellMapT &lhs, const CellMapT &rhs);
bool operator==(const CellT &lhs, const CellT &rhs);
bool operator==(const meshDataUVT &lhs, const meshDataUVT &rhs);
bool operator==(const meshDataIndicesT &lhs, const meshDataIndicesT &rhs);
bool operator==(const partStateT &lhs, const partStateT &rhs);
bool operator==(const frameDataIndexT &lhs, const frameDataIndexT &rhs);
bool operator==(const userDataInteger &lhs, const userDataInteger &rhs);
bool operator==(const userDataRect &lhs, const userDataRect &rhs);
bool operator==(const userDataPoint &lhs, const userDataPoint &rhs);
bool operator==(const userDataStringT &lhs, const userDataStringT &rhs);
bool operator==(const userDataItemT &lhs, const userDataItemT &rhs);
bool operator==(const userDataPerFrameT &lhs, const userDataPerFrameT &rhs);
bool operator==(const labelDataItemT &lhs, const labelDataItemT &rhs);
bool operator==(const AnimationDataT &lhs, const AnimationDataT &rhs);
bool operator==(const AnimationInitialDataT &lhs, const AnimationInitialDataT &rhs);
bool operator==(const PartDataT &lhs, const PartDataT &rhs);
bool operator==(const AnimePackDataT &lhs, const AnimePackDataT &rhs);
bool operator==(const ProjectDataT &lhs, const ProjectDataT &rhs);

enum SsPartType {
  SsPartType_Invalid = -1,
  SsPartType_Nulltype = 0,
  SsPartType_Normal = 1,
  SsPartType_Text = 2,
  SsPartType_Instance = 3,
  SsPartType_Armature = 4,
  SsPartType_Effect = 5,
  SsPartType_Mesh = 6,
  SsPartType_Movenode = 7,
  SsPartType_Constraint = 8,
  SsPartType_Mask = 9,
  SsPartType_Joint = 10,
  SsPartType_Bonepoint = 11,
  SsPartType_MIN = SsPartType_Invalid,
  SsPartType_MAX = SsPartType_Bonepoint
};

inline const SsPartType (&EnumValuesSsPartType())[13] {
  static const SsPartType values[] = {
    SsPartType_Invalid,
    SsPartType_Nulltype,
    SsPartType_Normal,
    SsPartType_Text,
    SsPartType_Instance,
    SsPartType_Armature,
    SsPartType_Effect,
    SsPartType_Mesh,
    SsPartType_Movenode,
    SsPartType_Constraint,
    SsPartType_Mask,
    SsPartType_Joint,
    SsPartType_Bonepoint
  };
  return values;
}

inline const char * const *EnumNamesSsPartType() {
  static const char * const names[] = {
    "Invalid",
    "Nulltype",
    "Normal",
    "Text",
    "Instance",
    "Armature",
    "Effect",
    "Mesh",
    "Movenode",
    "Constraint",
    "Mask",
    "Joint",
    "Bonepoint",
    nullptr
  };
  return names;
}

inline const char *EnumNameSsPartType(SsPartType e) {
  const size_t index = static_cast<int>(e) - static_cast<int>(SsPartType_Invalid);
  return EnumNamesSsPartType()[index];
}

enum PART_FLAG {
  PART_FLAG_INVISIBLE = 1,
  PART_FLAG_FLIP_H = 2,
  PART_FLAG_FLIP_V = 4,
  PART_FLAG_CELL_INDEX = 8,
  PART_FLAG_POSITION_X = 16,
  PART_FLAG_POSITION_Y = 32,
  PART_FLAG_POSITION_Z = 64,
  PART_FLAG_PIVOT_X = 128,
  PART_FLAG_PIVOT_Y = 256,
  PART_FLAG_ROTATIONX = 512,
  PART_FLAG_ROTATIONY = 1024,
  PART_FLAG_ROTATIONZ = 2048,
  PART_FLAG_SCALE_X = 4096,
  PART_FLAG_SCALE_Y = 8192,
  PART_FLAG_LOCALSCALE_X = 16384,
  PART_FLAG_LOCALSCALE_Y = 32768,
  PART_FLAG_OPACITY = 65536,
  PART_FLAG_LOCALOPACITY = 131072,
  PART_FLAG_PARTS_COLOR = 262144,
  PART_FLAG_VERTEX_TRANSFORM = 524288,
  PART_FLAG_SIZE_X = 1048576,
  PART_FLAG_SIZE_Y = 2097152,
  PART_FLAG_U_MOVE = 4194304,
  PART_FLAG_V_MOVE = 8388608,
  PART_FLAG_UV_ROTATION = 16777216,
  PART_FLAG_U_SCALE = 33554432,
  PART_FLAG_V_SCALE = 67108864,
  PART_FLAG_BOUNDINGRADIUS = 134217728,
  PART_FLAG_MASK = 268435456,
  PART_FLAG_PRIORITY = 536870912,
  PART_FLAG_INSTANCE_KEYFRAME = 1073741824,
  PART_FLAG_EFFECT_KEYFRAME = 2147483648,
  PART_FLAG_NONE = 0,
  PART_FLAG_ANY = 4294967295
};

inline const PART_FLAG (&EnumValuesPART_FLAG())[32] {
  static const PART_FLAG values[] = {
    PART_FLAG_INVISIBLE,
    PART_FLAG_FLIP_H,
    PART_FLAG_FLIP_V,
    PART_FLAG_CELL_INDEX,
    PART_FLAG_POSITION_X,
    PART_FLAG_POSITION_Y,
    PART_FLAG_POSITION_Z,
    PART_FLAG_PIVOT_X,
    PART_FLAG_PIVOT_Y,
    PART_FLAG_ROTATIONX,
    PART_FLAG_ROTATIONY,
    PART_FLAG_ROTATIONZ,
    PART_FLAG_SCALE_X,
    PART_FLAG_SCALE_Y,
    PART_FLAG_LOCALSCALE_X,
    PART_FLAG_LOCALSCALE_Y,
    PART_FLAG_OPACITY,
    PART_FLAG_LOCALOPACITY,
    PART_FLAG_PARTS_COLOR,
    PART_FLAG_VERTEX_TRANSFORM,
    PART_FLAG_SIZE_X,
    PART_FLAG_SIZE_Y,
    PART_FLAG_U_MOVE,
    PART_FLAG_V_MOVE,
    PART_FLAG_UV_ROTATION,
    PART_FLAG_U_SCALE,
    PART_FLAG_V_SCALE,
    PART_FLAG_BOUNDINGRADIUS,
    PART_FLAG_MASK,
    PART_FLAG_PRIORITY,
    PART_FLAG_INSTANCE_KEYFRAME,
    PART_FLAG_EFFECT_KEYFRAME
  };
  return values;
}

inline const char *EnumNamePART_FLAG(PART_FLAG e) {
  switch (e) {
    case PART_FLAG_INVISIBLE: return "INVISIBLE";
    case PART_FLAG_FLIP_H: return "FLIP_H";
    case PART_FLAG_FLIP_V: return "FLIP_V";
    case PART_FLAG_CELL_INDEX: return "CELL_INDEX";
    case PART_FLAG_POSITION_X: return "POSITION_X";
    case PART_FLAG_POSITION_Y: return "POSITION_Y";
    case PART_FLAG_POSITION_Z: return "POSITION_Z";
    case PART_FLAG_PIVOT_X: return "PIVOT_X";
    case PART_FLAG_PIVOT_Y: return "PIVOT_Y";
    case PART_FLAG_ROTATIONX: return "ROTATIONX";
    case PART_FLAG_ROTATIONY: return "ROTATIONY";
    case PART_FLAG_ROTATIONZ: return "ROTATIONZ";
    case PART_FLAG_SCALE_X: return "SCALE_X";
    case PART_FLAG_SCALE_Y: return "SCALE_Y";
    case PART_FLAG_LOCALSCALE_X: return "LOCALSCALE_X";
    case PART_FLAG_LOCALSCALE_Y: return "LOCALSCALE_Y";
    case PART_FLAG_OPACITY: return "OPACITY";
    case PART_FLAG_LOCALOPACITY: return "LOCALOPACITY";
    case PART_FLAG_PARTS_COLOR: return "PARTS_COLOR";
    case PART_FLAG_VERTEX_TRANSFORM: return "VERTEX_TRANSFORM";
    case PART_FLAG_SIZE_X: return "SIZE_X";
    case PART_FLAG_SIZE_Y: return "SIZE_Y";
    case PART_FLAG_U_MOVE: return "U_MOVE";
    case PART_FLAG_V_MOVE: return "V_MOVE";
    case PART_FLAG_UV_ROTATION: return "UV_ROTATION";
    case PART_FLAG_U_SCALE: return "U_SCALE";
    case PART_FLAG_V_SCALE: return "V_SCALE";
    case PART_FLAG_BOUNDINGRADIUS: return "BOUNDINGRADIUS";
    case PART_FLAG_MASK: return "MASK";
    case PART_FLAG_PRIORITY: return "PRIORITY";
    case PART_FLAG_INSTANCE_KEYFRAME: return "INSTANCE_KEYFRAME";
    case PART_FLAG_EFFECT_KEYFRAME: return "EFFECT_KEYFRAME";
    default: return "";
  }
}

enum PART_FLAG2 {
  PART_FLAG2_MESHDATA = 1,
  PART_FLAG2_NONE = 0,
  PART_FLAG2_ANY = 1
};

inline const PART_FLAG2 (&EnumValuesPART_FLAG2())[1] {
  static const PART_FLAG2 values[] = {
    PART_FLAG2_MESHDATA
  };
  return values;
}

inline const char * const *EnumNamesPART_FLAG2() {
  static const char * const names[] = {
    "MESHDATA",
    nullptr
  };
  return names;
}

inline const char *EnumNamePART_FLAG2(PART_FLAG2 e) {
  const size_t index = static_cast<int>(e) - static_cast<int>(PART_FLAG2_MESHDATA);
  return EnumNamesPART_FLAG2()[index];
}

enum VERTEX_FLAG {
  VERTEX_FLAG_LT = 1,
  VERTEX_FLAG_RT = 2,
  VERTEX_FLAG_LB = 4,
  VERTEX_FLAG_RB = 8,
  VERTEX_FLAG_ONE = 16,
  VERTEX_FLAG_NONE = 0,
  VERTEX_FLAG_ANY = 31
};

inline const VERTEX_FLAG (&EnumValuesVERTEX_FLAG())[5] {
  static const VERTEX_FLAG values[] = {
    VERTEX_FLAG_LT,
    VERTEX_FLAG_RT,
    VERTEX_FLAG_LB,
    VERTEX_FLAG_RB,
    VERTEX_FLAG_ONE
  };
  return values;
}

inline const char * const *EnumNamesVERTEX_FLAG() {
  static const char * const names[] = {
    "LT",
    "RT",
    "",
    "LB",
    "",
    "",
    "",
    "RB",
    "",
    "",
    "",
    "",
    "",
    "",
    "",
    "ONE",
    nullptr
  };
  return names;
}

inline const char *EnumNameVERTEX_FLAG(VERTEX_FLAG e) {
  const size_t index = static_cast<int>(e) - static_cast<int>(VERTEX_FLAG_LT);
  return EnumNamesVERTEX_FLAG()[index];
}

enum EffectNodeBehavior {
  EffectNodeBehavior_NONE = 0,
  EffectNodeBehavior_EffectParticleElementBasic = 1,
  EffectNodeBehavior_EffectParticleElementRndSeedChange = 2,
  EffectNodeBehavior_EffectParticleElementDelay = 3,
  EffectNodeBehavior_EffectParticleElementGravity = 4,
  EffectNodeBehavior_EffectParticleElementPosition = 5,
  EffectNodeBehavior_EffectParticleElementRotation = 6,
  EffectNodeBehavior_EffectParticleElementRotationTrans = 7,
  EffectNodeBehavior_EffectParticleElementTransSpeed = 8,
  EffectNodeBehavior_EffectParticleElementTangentialAcceleration = 9,
  EffectNodeBehavior_EffectParticleElementInitColor = 10,
  EffectNodeBehavior_EffectParticleElementTransColor = 11,
  EffectNodeBehavior_EffectParticleElementAlphaFade = 12,
  EffectNodeBehavior_EffectParticleElementSize = 13,
  EffectNodeBehavior_EffectParticleElementTransSize = 14,
  EffectNodeBehavior_EffectParticlePointGravity = 15,
  EffectNodeBehavior_EffectParticleTurnToDirectionEnabled = 16,
  EffectNodeBehavior_EffectParticleInfiniteEmitEnabled = 17,
  EffectNodeBehavior_MIN = EffectNodeBehavior_NONE,
  EffectNodeBehavior_MAX = EffectNodeBehavior_EffectParticleInfiniteEmitEnabled
};

inline const EffectNodeBehavior (&EnumValuesEffectNodeBehavior())[18] {
  static const EffectNodeBehavior values[] = {
    EffectNodeBehavior_NONE,
    EffectNodeBehavior_EffectParticleElementBasic,
    EffectNodeBehavior_EffectParticleElementRndSeedChange,
    EffectNodeBehavior_EffectParticleElementDelay,
    EffectNodeBehavior_EffectParticleElementGravity,
    EffectNodeBehavior_EffectParticleElementPosition,
    EffectNodeBehavior_EffectParticleElementRotation,
    EffectNodeBehavior_EffectParticleElementRotationTrans,
    EffectNodeBehavior_EffectParticleElementTransSpeed,
    EffectNodeBehavior_EffectParticleElementTangentialAcceleration,
    EffectNodeBehavior_EffectParticleElementInitColor,
    EffectNodeBehavior_EffectParticleElementTransColor,
    EffectNodeBehavior_EffectParticleElementAlphaFade,
    EffectNodeBehavior_EffectParticleElementSize,
    EffectNodeBehavior_EffectParticleElementTransSize,
    EffectNodeBehavior_EffectParticlePointGravity,
    EffectNodeBehavior_EffectParticleTurnToDirectionEnabled,
    EffectNodeBehavior_EffectParticleInfiniteEmitEnabled
  };
  return values;
}

inline const char * const *EnumNamesEffectNodeBehavior() {
  static const char * const names[] = {
    "NONE",
    "EffectParticleElementBasic",
    "EffectParticleElementRndSeedChange",
    "EffectParticleElementDelay",
    "EffectParticleElementGravity",
    "EffectParticleElementPosition",
    "EffectParticleElementRotation",
    "EffectParticleElementRotationTrans",
    "EffectParticleElementTransSpeed",
    "EffectParticleElementTangentialAcceleration",
    "EffectParticleElementInitColor",
    "EffectParticleElementTransColor",
    "EffectParticleElementAlphaFade",
    "EffectParticleElementSize",
    "EffectParticleElementTransSize",
    "EffectParticlePointGravity",
    "EffectParticleTurnToDirectionEnabled",
    "EffectParticleInfiniteEmitEnabled",
    nullptr
  };
  return names;
}

inline const char *EnumNameEffectNodeBehavior(EffectNodeBehavior e) {
  const size_t index = static_cast<int>(e);
  return EnumNamesEffectNodeBehavior()[index];
}

template<typename T> struct EffectNodeBehaviorTraits {
  static const EffectNodeBehavior enum_value = EffectNodeBehavior_NONE;
};

template<> struct EffectNodeBehaviorTraits<EffectParticleElementBasic> {
  static const EffectNodeBehavior enum_value = EffectNodeBehavior_EffectParticleElementBasic;
};

template<> struct EffectNodeBehaviorTraits<EffectParticleElementRndSeedChange> {
  static const EffectNodeBehavior enum_value = EffectNodeBehavior_EffectParticleElementRndSeedChange;
};

template<> struct EffectNodeBehaviorTraits<EffectParticleElementDelay> {
  static const EffectNodeBehavior enum_value = EffectNodeBehavior_EffectParticleElementDelay;
};

template<> struct EffectNodeBehaviorTraits<EffectParticleElementGravity> {
  static const EffectNodeBehavior enum_value = EffectNodeBehavior_EffectParticleElementGravity;
};

template<> struct EffectNodeBehaviorTraits<EffectParticleElementPosition> {
  static const EffectNodeBehavior enum_value = EffectNodeBehavior_EffectParticleElementPosition;
};

template<> struct EffectNodeBehaviorTraits<EffectParticleElementRotation> {
  static const EffectNodeBehavior enum_value = EffectNodeBehavior_EffectParticleElementRotation;
};

template<> struct EffectNodeBehaviorTraits<EffectParticleElementRotationTrans> {
  static const EffectNodeBehavior enum_value = EffectNodeBehavior_EffectParticleElementRotationTrans;
};

template<> struct EffectNodeBehaviorTraits<EffectParticleElementTransSpeed> {
  static const EffectNodeBehavior enum_value = EffectNodeBehavior_EffectParticleElementTransSpeed;
};

template<> struct EffectNodeBehaviorTraits<EffectParticleElementTangentialAcceleration> {
  static const EffectNodeBehavior enum_value = EffectNodeBehavior_EffectParticleElementTangentialAcceleration;
};

template<> struct EffectNodeBehaviorTraits<EffectParticleElementInitColor> {
  static const EffectNodeBehavior enum_value = EffectNodeBehavior_EffectParticleElementInitColor;
};

template<> struct EffectNodeBehaviorTraits<EffectParticleElementTransColor> {
  static const EffectNodeBehavior enum_value = EffectNodeBehavior_EffectParticleElementTransColor;
};

template<> struct EffectNodeBehaviorTraits<EffectParticleElementAlphaFade> {
  static const EffectNodeBehavior enum_value = EffectNodeBehavior_EffectParticleElementAlphaFade;
};

template<> struct EffectNodeBehaviorTraits<EffectParticleElementSize> {
  static const EffectNodeBehavior enum_value = EffectNodeBehavior_EffectParticleElementSize;
};

template<> struct EffectNodeBehaviorTraits<EffectParticleElementTransSize> {
  static const EffectNodeBehavior enum_value = EffectNodeBehavior_EffectParticleElementTransSize;
};

template<> struct EffectNodeBehaviorTraits<EffectParticlePointGravity> {
  static const EffectNodeBehavior enum_value = EffectNodeBehavior_EffectParticlePointGravity;
};

template<> struct EffectNodeBehaviorTraits<EffectParticleTurnToDirectionEnabled> {
  static const EffectNodeBehavior enum_value = EffectNodeBehavior_EffectParticleTurnToDirectionEnabled;
};

template<> struct EffectNodeBehaviorTraits<EffectParticleInfiniteEmitEnabled> {
  static const EffectNodeBehavior enum_value = EffectNodeBehavior_EffectParticleInfiniteEmitEnabled;
};

struct EffectNodeBehaviorUnion {
  EffectNodeBehavior type;
  void *value;

  EffectNodeBehaviorUnion() : type(EffectNodeBehavior_NONE), value(nullptr) {}
  EffectNodeBehaviorUnion(EffectNodeBehaviorUnion&& u) FLATBUFFERS_NOEXCEPT :
    type(EffectNodeBehavior_NONE), value(nullptr)
    { std::swap(type, u.type); std::swap(value, u.value); }
  EffectNodeBehaviorUnion(const EffectNodeBehaviorUnion &) FLATBUFFERS_NOEXCEPT;
  EffectNodeBehaviorUnion &operator=(const EffectNodeBehaviorUnion &u) FLATBUFFERS_NOEXCEPT
    { EffectNodeBehaviorUnion t(u); std::swap(type, t.type); std::swap(value, t.value); return *this; }
  EffectNodeBehaviorUnion &operator=(EffectNodeBehaviorUnion &&u) FLATBUFFERS_NOEXCEPT
    { std::swap(type, u.type); std::swap(value, u.value); return *this; }
  ~EffectNodeBehaviorUnion() { Reset(); }

  void Reset();

#ifndef FLATBUFFERS_CPP98_STL
  template <typename T>
  void Set(T&& val) {
    Reset();
    type = EffectNodeBehaviorTraits<typename T::TableType>::enum_value;
    if (type != EffectNodeBehavior_NONE) {
      value = new T(std::forward<T>(val));
    }
  }
#endif  // FLATBUFFERS_CPP98_STL

  static void *UnPack(const void *obj, EffectNodeBehavior type, const flatbuffers::resolver_function_t *resolver);
  flatbuffers::Offset<void> Pack(flatbuffers::FlatBufferBuilder &_fbb, const flatbuffers::rehasher_function_t *_rehasher = nullptr) const;

  EffectParticleElementBasic *AsEffectParticleElementBasic() {
    return type == EffectNodeBehavior_EffectParticleElementBasic ?
      reinterpret_cast<EffectParticleElementBasic *>(value) : nullptr;
  }
  const EffectParticleElementBasic *AsEffectParticleElementBasic() const {
    return type == EffectNodeBehavior_EffectParticleElementBasic ?
      reinterpret_cast<const EffectParticleElementBasic *>(value) : nullptr;
  }
  EffectParticleElementRndSeedChange *AsEffectParticleElementRndSeedChange() {
    return type == EffectNodeBehavior_EffectParticleElementRndSeedChange ?
      reinterpret_cast<EffectParticleElementRndSeedChange *>(value) : nullptr;
  }
  const EffectParticleElementRndSeedChange *AsEffectParticleElementRndSeedChange() const {
    return type == EffectNodeBehavior_EffectParticleElementRndSeedChange ?
      reinterpret_cast<const EffectParticleElementRndSeedChange *>(value) : nullptr;
  }
  EffectParticleElementDelay *AsEffectParticleElementDelay() {
    return type == EffectNodeBehavior_EffectParticleElementDelay ?
      reinterpret_cast<EffectParticleElementDelay *>(value) : nullptr;
  }
  const EffectParticleElementDelay *AsEffectParticleElementDelay() const {
    return type == EffectNodeBehavior_EffectParticleElementDelay ?
      reinterpret_cast<const EffectParticleElementDelay *>(value) : nullptr;
  }
  EffectParticleElementGravity *AsEffectParticleElementGravity() {
    return type == EffectNodeBehavior_EffectParticleElementGravity ?
      reinterpret_cast<EffectParticleElementGravity *>(value) : nullptr;
  }
  const EffectParticleElementGravity *AsEffectParticleElementGravity() const {
    return type == EffectNodeBehavior_EffectParticleElementGravity ?
      reinterpret_cast<const EffectParticleElementGravity *>(value) : nullptr;
  }
  EffectParticleElementPosition *AsEffectParticleElementPosition() {
    return type == EffectNodeBehavior_EffectParticleElementPosition ?
      reinterpret_cast<EffectParticleElementPosition *>(value) : nullptr;
  }
  const EffectParticleElementPosition *AsEffectParticleElementPosition() const {
    return type == EffectNodeBehavior_EffectParticleElementPosition ?
      reinterpret_cast<const EffectParticleElementPosition *>(value) : nullptr;
  }
  EffectParticleElementRotation *AsEffectParticleElementRotation() {
    return type == EffectNodeBehavior_EffectParticleElementRotation ?
      reinterpret_cast<EffectParticleElementRotation *>(value) : nullptr;
  }
  const EffectParticleElementRotation *AsEffectParticleElementRotation() const {
    return type == EffectNodeBehavior_EffectParticleElementRotation ?
      reinterpret_cast<const EffectParticleElementRotation *>(value) : nullptr;
  }
  EffectParticleElementRotationTrans *AsEffectParticleElementRotationTrans() {
    return type == EffectNodeBehavior_EffectParticleElementRotationTrans ?
      reinterpret_cast<EffectParticleElementRotationTrans *>(value) : nullptr;
  }
  const EffectParticleElementRotationTrans *AsEffectParticleElementRotationTrans() const {
    return type == EffectNodeBehavior_EffectParticleElementRotationTrans ?
      reinterpret_cast<const EffectParticleElementRotationTrans *>(value) : nullptr;
  }
  EffectParticleElementTransSpeed *AsEffectParticleElementTransSpeed() {
    return type == EffectNodeBehavior_EffectParticleElementTransSpeed ?
      reinterpret_cast<EffectParticleElementTransSpeed *>(value) : nullptr;
  }
  const EffectParticleElementTransSpeed *AsEffectParticleElementTransSpeed() const {
    return type == EffectNodeBehavior_EffectParticleElementTransSpeed ?
      reinterpret_cast<const EffectParticleElementTransSpeed *>(value) : nullptr;
  }
  EffectParticleElementTangentialAcceleration *AsEffectParticleElementTangentialAcceleration() {
    return type == EffectNodeBehavior_EffectParticleElementTangentialAcceleration ?
      reinterpret_cast<EffectParticleElementTangentialAcceleration *>(value) : nullptr;
  }
  const EffectParticleElementTangentialAcceleration *AsEffectParticleElementTangentialAcceleration() const {
    return type == EffectNodeBehavior_EffectParticleElementTangentialAcceleration ?
      reinterpret_cast<const EffectParticleElementTangentialAcceleration *>(value) : nullptr;
  }
  EffectParticleElementInitColor *AsEffectParticleElementInitColor() {
    return type == EffectNodeBehavior_EffectParticleElementInitColor ?
      reinterpret_cast<EffectParticleElementInitColor *>(value) : nullptr;
  }
  const EffectParticleElementInitColor *AsEffectParticleElementInitColor() const {
    return type == EffectNodeBehavior_EffectParticleElementInitColor ?
      reinterpret_cast<const EffectParticleElementInitColor *>(value) : nullptr;
  }
  EffectParticleElementTransColor *AsEffectParticleElementTransColor() {
    return type == EffectNodeBehavior_EffectParticleElementTransColor ?
      reinterpret_cast<EffectParticleElementTransColor *>(value) : nullptr;
  }
  const EffectParticleElementTransColor *AsEffectParticleElementTransColor() const {
    return type == EffectNodeBehavior_EffectParticleElementTransColor ?
      reinterpret_cast<const EffectParticleElementTransColor *>(value) : nullptr;
  }
  EffectParticleElementAlphaFade *AsEffectParticleElementAlphaFade() {
    return type == EffectNodeBehavior_EffectParticleElementAlphaFade ?
      reinterpret_cast<EffectParticleElementAlphaFade *>(value) : nullptr;
  }
  const EffectParticleElementAlphaFade *AsEffectParticleElementAlphaFade() const {
    return type == EffectNodeBehavior_EffectParticleElementAlphaFade ?
      reinterpret_cast<const EffectParticleElementAlphaFade *>(value) : nullptr;
  }
  EffectParticleElementSize *AsEffectParticleElementSize() {
    return type == EffectNodeBehavior_EffectParticleElementSize ?
      reinterpret_cast<EffectParticleElementSize *>(value) : nullptr;
  }
  const EffectParticleElementSize *AsEffectParticleElementSize() const {
    return type == EffectNodeBehavior_EffectParticleElementSize ?
      reinterpret_cast<const EffectParticleElementSize *>(value) : nullptr;
  }
  EffectParticleElementTransSize *AsEffectParticleElementTransSize() {
    return type == EffectNodeBehavior_EffectParticleElementTransSize ?
      reinterpret_cast<EffectParticleElementTransSize *>(value) : nullptr;
  }
  const EffectParticleElementTransSize *AsEffectParticleElementTransSize() const {
    return type == EffectNodeBehavior_EffectParticleElementTransSize ?
      reinterpret_cast<const EffectParticleElementTransSize *>(value) : nullptr;
  }
  EffectParticlePointGravity *AsEffectParticlePointGravity() {
    return type == EffectNodeBehavior_EffectParticlePointGravity ?
      reinterpret_cast<EffectParticlePointGravity *>(value) : nullptr;
  }
  const EffectParticlePointGravity *AsEffectParticlePointGravity() const {
    return type == EffectNodeBehavior_EffectParticlePointGravity ?
      reinterpret_cast<const EffectParticlePointGravity *>(value) : nullptr;
  }
  EffectParticleTurnToDirectionEnabled *AsEffectParticleTurnToDirectionEnabled() {
    return type == EffectNodeBehavior_EffectParticleTurnToDirectionEnabled ?
      reinterpret_cast<EffectParticleTurnToDirectionEnabled *>(value) : nullptr;
  }
  const EffectParticleTurnToDirectionEnabled *AsEffectParticleTurnToDirectionEnabled() const {
    return type == EffectNodeBehavior_EffectParticleTurnToDirectionEnabled ?
      reinterpret_cast<const EffectParticleTurnToDirectionEnabled *>(value) : nullptr;
  }
  EffectParticleInfiniteEmitEnabled *AsEffectParticleInfiniteEmitEnabled() {
    return type == EffectNodeBehavior_EffectParticleInfiniteEmitEnabled ?
      reinterpret_cast<EffectParticleInfiniteEmitEnabled *>(value) : nullptr;
  }
  const EffectParticleInfiniteEmitEnabled *AsEffectParticleInfiniteEmitEnabled() const {
    return type == EffectNodeBehavior_EffectParticleInfiniteEmitEnabled ?
      reinterpret_cast<const EffectParticleInfiniteEmitEnabled *>(value) : nullptr;
  }
};


inline bool operator==(const EffectNodeBehaviorUnion &lhs, const EffectNodeBehaviorUnion &rhs) {
  if (lhs.type != rhs.type) return false;
  switch (lhs.type) {
    case EffectNodeBehavior_NONE: {
      return true;
    }
    case EffectNodeBehavior_EffectParticleElementBasic: {
      return *(reinterpret_cast<const EffectParticleElementBasic *>(lhs.value)) ==
             *(reinterpret_cast<const EffectParticleElementBasic *>(rhs.value));
    }
    case EffectNodeBehavior_EffectParticleElementRndSeedChange: {
      return *(reinterpret_cast<const EffectParticleElementRndSeedChange *>(lhs.value)) ==
             *(reinterpret_cast<const EffectParticleElementRndSeedChange *>(rhs.value));
    }
    case EffectNodeBehavior_EffectParticleElementDelay: {
      return *(reinterpret_cast<const EffectParticleElementDelay *>(lhs.value)) ==
             *(reinterpret_cast<const EffectParticleElementDelay *>(rhs.value));
    }
    case EffectNodeBehavior_EffectParticleElementGravity: {
      return *(reinterpret_cast<const EffectParticleElementGravity *>(lhs.value)) ==
             *(reinterpret_cast<const EffectParticleElementGravity *>(rhs.value));
    }
    case EffectNodeBehavior_EffectParticleElementPosition: {
      return *(reinterpret_cast<const EffectParticleElementPosition *>(lhs.value)) ==
             *(reinterpret_cast<const EffectParticleElementPosition *>(rhs.value));
    }
    case EffectNodeBehavior_EffectParticleElementRotation: {
      return *(reinterpret_cast<const EffectParticleElementRotation *>(lhs.value)) ==
             *(reinterpret_cast<const EffectParticleElementRotation *>(rhs.value));
    }
    case EffectNodeBehavior_EffectParticleElementRotationTrans: {
      return *(reinterpret_cast<const EffectParticleElementRotationTrans *>(lhs.value)) ==
             *(reinterpret_cast<const EffectParticleElementRotationTrans *>(rhs.value));
    }
    case EffectNodeBehavior_EffectParticleElementTransSpeed: {
      return *(reinterpret_cast<const EffectParticleElementTransSpeed *>(lhs.value)) ==
             *(reinterpret_cast<const EffectParticleElementTransSpeed *>(rhs.value));
    }
    case EffectNodeBehavior_EffectParticleElementTangentialAcceleration: {
      return *(reinterpret_cast<const EffectParticleElementTangentialAcceleration *>(lhs.value)) ==
             *(reinterpret_cast<const EffectParticleElementTangentialAcceleration *>(rhs.value));
    }
    case EffectNodeBehavior_EffectParticleElementInitColor: {
      return *(reinterpret_cast<const EffectParticleElementInitColor *>(lhs.value)) ==
             *(reinterpret_cast<const EffectParticleElementInitColor *>(rhs.value));
    }
    case EffectNodeBehavior_EffectParticleElementTransColor: {
      return *(reinterpret_cast<const EffectParticleElementTransColor *>(lhs.value)) ==
             *(reinterpret_cast<const EffectParticleElementTransColor *>(rhs.value));
    }
    case EffectNodeBehavior_EffectParticleElementAlphaFade: {
      return *(reinterpret_cast<const EffectParticleElementAlphaFade *>(lhs.value)) ==
             *(reinterpret_cast<const EffectParticleElementAlphaFade *>(rhs.value));
    }
    case EffectNodeBehavior_EffectParticleElementSize: {
      return *(reinterpret_cast<const EffectParticleElementSize *>(lhs.value)) ==
             *(reinterpret_cast<const EffectParticleElementSize *>(rhs.value));
    }
    case EffectNodeBehavior_EffectParticleElementTransSize: {
      return *(reinterpret_cast<const EffectParticleElementTransSize *>(lhs.value)) ==
             *(reinterpret_cast<const EffectParticleElementTransSize *>(rhs.value));
    }
    case EffectNodeBehavior_EffectParticlePointGravity: {
      return *(reinterpret_cast<const EffectParticlePointGravity *>(lhs.value)) ==
             *(reinterpret_cast<const EffectParticlePointGravity *>(rhs.value));
    }
    case EffectNodeBehavior_EffectParticleTurnToDirectionEnabled: {
      return *(reinterpret_cast<const EffectParticleTurnToDirectionEnabled *>(lhs.value)) ==
             *(reinterpret_cast<const EffectParticleTurnToDirectionEnabled *>(rhs.value));
    }
    case EffectNodeBehavior_EffectParticleInfiniteEmitEnabled: {
      return *(reinterpret_cast<const EffectParticleInfiniteEmitEnabled *>(lhs.value)) ==
             *(reinterpret_cast<const EffectParticleInfiniteEmitEnabled *>(rhs.value));
    }
    default: {
      return false;
    }
  }
}
bool VerifyEffectNodeBehavior(flatbuffers::Verifier &verifier, const void *obj, EffectNodeBehavior type);
bool VerifyEffectNodeBehaviorVector(flatbuffers::Verifier &verifier, const flatbuffers::Vector<flatbuffers::Offset<void>> *values, const flatbuffers::Vector<uint8_t> *types);

enum userDataValue {
  userDataValue_NONE = 0,
  userDataValue_userDataInteger = 1,
  userDataValue_userDataRect = 2,
  userDataValue_userDataPoint = 3,
  userDataValue_userDataString = 4,
  userDataValue_MIN = userDataValue_NONE,
  userDataValue_MAX = userDataValue_userDataString
};

inline const userDataValue (&EnumValuesuserDataValue())[5] {
  static const userDataValue values[] = {
    userDataValue_NONE,
    userDataValue_userDataInteger,
    userDataValue_userDataRect,
    userDataValue_userDataPoint,
    userDataValue_userDataString
  };
  return values;
}

inline const char * const *EnumNamesuserDataValue() {
  static const char * const names[] = {
    "NONE",
    "userDataInteger",
    "userDataRect",
    "userDataPoint",
    "userDataString",
    nullptr
  };
  return names;
}

inline const char *EnumNameuserDataValue(userDataValue e) {
  const size_t index = static_cast<int>(e);
  return EnumNamesuserDataValue()[index];
}

template<typename T> struct userDataValueTraits {
  static const userDataValue enum_value = userDataValue_NONE;
};

template<> struct userDataValueTraits<userDataInteger> {
  static const userDataValue enum_value = userDataValue_userDataInteger;
};

template<> struct userDataValueTraits<userDataRect> {
  static const userDataValue enum_value = userDataValue_userDataRect;
};

template<> struct userDataValueTraits<userDataPoint> {
  static const userDataValue enum_value = userDataValue_userDataPoint;
};

template<> struct userDataValueTraits<userDataString> {
  static const userDataValue enum_value = userDataValue_userDataString;
};

struct userDataValueUnion {
  userDataValue type;
  void *value;

  userDataValueUnion() : type(userDataValue_NONE), value(nullptr) {}
  userDataValueUnion(userDataValueUnion&& u) FLATBUFFERS_NOEXCEPT :
    type(userDataValue_NONE), value(nullptr)
    { std::swap(type, u.type); std::swap(value, u.value); }
  userDataValueUnion(const userDataValueUnion &) FLATBUFFERS_NOEXCEPT;
  userDataValueUnion &operator=(const userDataValueUnion &u) FLATBUFFERS_NOEXCEPT
    { userDataValueUnion t(u); std::swap(type, t.type); std::swap(value, t.value); return *this; }
  userDataValueUnion &operator=(userDataValueUnion &&u) FLATBUFFERS_NOEXCEPT
    { std::swap(type, u.type); std::swap(value, u.value); return *this; }
  ~userDataValueUnion() { Reset(); }

  void Reset();

#ifndef FLATBUFFERS_CPP98_STL
  template <typename T>
  void Set(T&& val) {
    Reset();
    type = userDataValueTraits<typename T::TableType>::enum_value;
    if (type != userDataValue_NONE) {
      value = new T(std::forward<T>(val));
    }
  }
#endif  // FLATBUFFERS_CPP98_STL

  static void *UnPack(const void *obj, userDataValue type, const flatbuffers::resolver_function_t *resolver);
  flatbuffers::Offset<void> Pack(flatbuffers::FlatBufferBuilder &_fbb, const flatbuffers::rehasher_function_t *_rehasher = nullptr) const;

  userDataInteger *AsuserDataInteger() {
    return type == userDataValue_userDataInteger ?
      reinterpret_cast<userDataInteger *>(value) : nullptr;
  }
  const userDataInteger *AsuserDataInteger() const {
    return type == userDataValue_userDataInteger ?
      reinterpret_cast<const userDataInteger *>(value) : nullptr;
  }
  userDataRect *AsuserDataRect() {
    return type == userDataValue_userDataRect ?
      reinterpret_cast<userDataRect *>(value) : nullptr;
  }
  const userDataRect *AsuserDataRect() const {
    return type == userDataValue_userDataRect ?
      reinterpret_cast<const userDataRect *>(value) : nullptr;
  }
  userDataPoint *AsuserDataPoint() {
    return type == userDataValue_userDataPoint ?
      reinterpret_cast<userDataPoint *>(value) : nullptr;
  }
  const userDataPoint *AsuserDataPoint() const {
    return type == userDataValue_userDataPoint ?
      reinterpret_cast<const userDataPoint *>(value) : nullptr;
  }
  userDataStringT *AsuserDataString() {
    return type == userDataValue_userDataString ?
      reinterpret_cast<userDataStringT *>(value) : nullptr;
  }
  const userDataStringT *AsuserDataString() const {
    return type == userDataValue_userDataString ?
      reinterpret_cast<const userDataStringT *>(value) : nullptr;
  }
};


inline bool operator==(const userDataValueUnion &lhs, const userDataValueUnion &rhs) {
  if (lhs.type != rhs.type) return false;
  switch (lhs.type) {
    case userDataValue_NONE: {
      return true;
    }
    case userDataValue_userDataInteger: {
      return *(reinterpret_cast<const userDataInteger *>(lhs.value)) ==
             *(reinterpret_cast<const userDataInteger *>(rhs.value));
    }
    case userDataValue_userDataRect: {
      return *(reinterpret_cast<const userDataRect *>(lhs.value)) ==
             *(reinterpret_cast<const userDataRect *>(rhs.value));
    }
    case userDataValue_userDataPoint: {
      return *(reinterpret_cast<const userDataPoint *>(lhs.value)) ==
             *(reinterpret_cast<const userDataPoint *>(rhs.value));
    }
    case userDataValue_userDataString: {
      return *(reinterpret_cast<const userDataStringT *>(lhs.value)) ==
             *(reinterpret_cast<const userDataStringT *>(rhs.value));
    }
    default: {
      return false;
    }
  }
}
bool VerifyuserDataValue(flatbuffers::Verifier &verifier, const void *obj, userDataValue type);
bool VerifyuserDataValueVector(flatbuffers::Verifier &verifier, const flatbuffers::Vector<flatbuffers::Offset<void>> *values, const flatbuffers::Vector<uint8_t> *types);

FLATBUFFERS_MANUALLY_ALIGNED_STRUCT(4) EffectParticleInfiniteEmitEnabled FLATBUFFERS_FINAL_CLASS {
 private:
  int32_t flag_;

 public:
  EffectParticleInfiniteEmitEnabled() {
    memset(this, 0, sizeof(EffectParticleInfiniteEmitEnabled));
  }
  EffectParticleInfiniteEmitEnabled(int32_t _flag)
      : flag_(flatbuffers::EndianScalar(_flag)) {
  }
  int32_t flag() const {
    return flatbuffers::EndianScalar(flag_);
  }
};
FLATBUFFERS_STRUCT_END(EffectParticleInfiniteEmitEnabled, 4);

inline bool operator==(const EffectParticleInfiniteEmitEnabled &lhs, const EffectParticleInfiniteEmitEnabled &rhs) {
  return
      (lhs.flag() == rhs.flag());
}

FLATBUFFERS_MANUALLY_ALIGNED_STRUCT(4) EffectParticleTurnToDirectionEnabled FLATBUFFERS_FINAL_CLASS {
 private:
  float Rotation_;

 public:
  EffectParticleTurnToDirectionEnabled() {
    memset(this, 0, sizeof(EffectParticleTurnToDirectionEnabled));
  }
  EffectParticleTurnToDirectionEnabled(float _Rotation)
      : Rotation_(flatbuffers::EndianScalar(_Rotation)) {
  }
  float Rotation() const {
    return flatbuffers::EndianScalar(Rotation_);
  }
};
FLATBUFFERS_STRUCT_END(EffectParticleTurnToDirectionEnabled, 4);

inline bool operator==(const EffectParticleTurnToDirectionEnabled &lhs, const EffectParticleTurnToDirectionEnabled &rhs) {
  return
      (lhs.Rotation() == rhs.Rotation());
}

FLATBUFFERS_MANUALLY_ALIGNED_STRUCT(4) EffectParticlePointGravity FLATBUFFERS_FINAL_CLASS {
 private:
  float Position_x_;
  float Position_y_;
  float Power_;

 public:
  EffectParticlePointGravity() {
    memset(this, 0, sizeof(EffectParticlePointGravity));
  }
  EffectParticlePointGravity(float _Position_x, float _Position_y, float _Power)
      : Position_x_(flatbuffers::EndianScalar(_Position_x)),
        Position_y_(flatbuffers::EndianScalar(_Position_y)),
        Power_(flatbuffers::EndianScalar(_Power)) {
  }
  float Position_x() const {
    return flatbuffers::EndianScalar(Position_x_);
  }
  float Position_y() const {
    return flatbuffers::EndianScalar(Position_y_);
  }
  float Power() const {
    return flatbuffers::EndianScalar(Power_);
  }
};
FLATBUFFERS_STRUCT_END(EffectParticlePointGravity, 12);

inline bool operator==(const EffectParticlePointGravity &lhs, const EffectParticlePointGravity &rhs) {
  return
      (lhs.Position_x() == rhs.Position_x()) &&
      (lhs.Position_y() == rhs.Position_y()) &&
      (lhs.Power() == rhs.Power());
}

FLATBUFFERS_MANUALLY_ALIGNED_STRUCT(4) EffectParticleElementTransSize FLATBUFFERS_FINAL_CLASS {
 private:
  float SizeXMinValue_;
  float SizeXMaxValue_;
  float SizeYMinValue_;
  float SizeYMaxValue_;
  float ScaleFactorMinValue_;
  float ScaleFactorMaxValue_;

 public:
  EffectParticleElementTransSize() {
    memset(this, 0, sizeof(EffectParticleElementTransSize));
  }
  EffectParticleElementTransSize(float _SizeXMinValue, float _SizeXMaxValue, float _SizeYMinValue, float _SizeYMaxValue, float _ScaleFactorMinValue, float _ScaleFactorMaxValue)
      : SizeXMinValue_(flatbuffers::EndianScalar(_SizeXMinValue)),
        SizeXMaxValue_(flatbuffers::EndianScalar(_SizeXMaxValue)),
        SizeYMinValue_(flatbuffers::EndianScalar(_SizeYMinValue)),
        SizeYMaxValue_(flatbuffers::EndianScalar(_SizeYMaxValue)),
        ScaleFactorMinValue_(flatbuffers::EndianScalar(_ScaleFactorMinValue)),
        ScaleFactorMaxValue_(flatbuffers::EndianScalar(_ScaleFactorMaxValue)) {
  }
  float SizeXMinValue() const {
    return flatbuffers::EndianScalar(SizeXMinValue_);
  }
  float SizeXMaxValue() const {
    return flatbuffers::EndianScalar(SizeXMaxValue_);
  }
  float SizeYMinValue() const {
    return flatbuffers::EndianScalar(SizeYMinValue_);
  }
  float SizeYMaxValue() const {
    return flatbuffers::EndianScalar(SizeYMaxValue_);
  }
  float ScaleFactorMinValue() const {
    return flatbuffers::EndianScalar(ScaleFactorMinValue_);
  }
  float ScaleFactorMaxValue() const {
    return flatbuffers::EndianScalar(ScaleFactorMaxValue_);
  }
};
FLATBUFFERS_STRUCT_END(EffectParticleElementTransSize, 24);

inline bool operator==(const EffectParticleElementTransSize &lhs, const EffectParticleElementTransSize &rhs) {
  return
      (lhs.SizeXMinValue() == rhs.SizeXMinValue()) &&
      (lhs.SizeXMaxValue() == rhs.SizeXMaxValue()) &&
      (lhs.SizeYMinValue() == rhs.SizeYMinValue()) &&
      (lhs.SizeYMaxValue() == rhs.SizeYMaxValue()) &&
      (lhs.ScaleFactorMinValue() == rhs.ScaleFactorMinValue()) &&
      (lhs.ScaleFactorMaxValue() == rhs.ScaleFactorMaxValue());
}

FLATBUFFERS_MANUALLY_ALIGNED_STRUCT(4) EffectParticleElementSize FLATBUFFERS_FINAL_CLASS {
 private:
  float SizeXMinValue_;
  float SizeXMaxValue_;
  float SizeYMinValue_;
  float SizeYMaxValue_;
  float ScaleFactorMinValue_;
  float ScaleFactorMaxValue_;

 public:
  EffectParticleElementSize() {
    memset(this, 0, sizeof(EffectParticleElementSize));
  }
  EffectParticleElementSize(float _SizeXMinValue, float _SizeXMaxValue, float _SizeYMinValue, float _SizeYMaxValue, float _ScaleFactorMinValue, float _ScaleFactorMaxValue)
      : SizeXMinValue_(flatbuffers::EndianScalar(_SizeXMinValue)),
        SizeXMaxValue_(flatbuffers::EndianScalar(_SizeXMaxValue)),
        SizeYMinValue_(flatbuffers::EndianScalar(_SizeYMinValue)),
        SizeYMaxValue_(flatbuffers::EndianScalar(_SizeYMaxValue)),
        ScaleFactorMinValue_(flatbuffers::EndianScalar(_ScaleFactorMinValue)),
        ScaleFactorMaxValue_(flatbuffers::EndianScalar(_ScaleFactorMaxValue)) {
  }
  float SizeXMinValue() const {
    return flatbuffers::EndianScalar(SizeXMinValue_);
  }
  float SizeXMaxValue() const {
    return flatbuffers::EndianScalar(SizeXMaxValue_);
  }
  float SizeYMinValue() const {
    return flatbuffers::EndianScalar(SizeYMinValue_);
  }
  float SizeYMaxValue() const {
    return flatbuffers::EndianScalar(SizeYMaxValue_);
  }
  float ScaleFactorMinValue() const {
    return flatbuffers::EndianScalar(ScaleFactorMinValue_);
  }
  float ScaleFactorMaxValue() const {
    return flatbuffers::EndianScalar(ScaleFactorMaxValue_);
  }
};
FLATBUFFERS_STRUCT_END(EffectParticleElementSize, 24);

inline bool operator==(const EffectParticleElementSize &lhs, const EffectParticleElementSize &rhs) {
  return
      (lhs.SizeXMinValue() == rhs.SizeXMinValue()) &&
      (lhs.SizeXMaxValue() == rhs.SizeXMaxValue()) &&
      (lhs.SizeYMinValue() == rhs.SizeYMinValue()) &&
      (lhs.SizeYMaxValue() == rhs.SizeYMaxValue()) &&
      (lhs.ScaleFactorMinValue() == rhs.ScaleFactorMinValue()) &&
      (lhs.ScaleFactorMaxValue() == rhs.ScaleFactorMaxValue());
}

FLATBUFFERS_MANUALLY_ALIGNED_STRUCT(4) EffectParticleElementAlphaFade FLATBUFFERS_FINAL_CLASS {
 private:
  float disprangeMinValue_;
  float disprangeMaxValue_;

 public:
  EffectParticleElementAlphaFade() {
    memset(this, 0, sizeof(EffectParticleElementAlphaFade));
  }
  EffectParticleElementAlphaFade(float _disprangeMinValue, float _disprangeMaxValue)
      : disprangeMinValue_(flatbuffers::EndianScalar(_disprangeMinValue)),
        disprangeMaxValue_(flatbuffers::EndianScalar(_disprangeMaxValue)) {
  }
  float disprangeMinValue() const {
    return flatbuffers::EndianScalar(disprangeMinValue_);
  }
  float disprangeMaxValue() const {
    return flatbuffers::EndianScalar(disprangeMaxValue_);
  }
};
FLATBUFFERS_STRUCT_END(EffectParticleElementAlphaFade, 8);

inline bool operator==(const EffectParticleElementAlphaFade &lhs, const EffectParticleElementAlphaFade &rhs) {
  return
      (lhs.disprangeMinValue() == rhs.disprangeMinValue()) &&
      (lhs.disprangeMaxValue() == rhs.disprangeMaxValue());
}

FLATBUFFERS_MANUALLY_ALIGNED_STRUCT(4) EffectParticleElementTransColor FLATBUFFERS_FINAL_CLASS {
 private:
  uint32_t ColorMinValue_;
  uint32_t ColorMaxValue_;

 public:
  EffectParticleElementTransColor() {
    memset(this, 0, sizeof(EffectParticleElementTransColor));
  }
  EffectParticleElementTransColor(uint32_t _ColorMinValue, uint32_t _ColorMaxValue)
      : ColorMinValue_(flatbuffers::EndianScalar(_ColorMinValue)),
        ColorMaxValue_(flatbuffers::EndianScalar(_ColorMaxValue)) {
  }
  uint32_t ColorMinValue() const {
    return flatbuffers::EndianScalar(ColorMinValue_);
  }
  uint32_t ColorMaxValue() const {
    return flatbuffers::EndianScalar(ColorMaxValue_);
  }
};
FLATBUFFERS_STRUCT_END(EffectParticleElementTransColor, 8);

inline bool operator==(const EffectParticleElementTransColor &lhs, const EffectParticleElementTransColor &rhs) {
  return
      (lhs.ColorMinValue() == rhs.ColorMinValue()) &&
      (lhs.ColorMaxValue() == rhs.ColorMaxValue());
}

FLATBUFFERS_MANUALLY_ALIGNED_STRUCT(4) EffectParticleElementInitColor FLATBUFFERS_FINAL_CLASS {
 private:
  uint32_t ColorMinValue_;
  uint32_t ColorMaxValue_;

 public:
  EffectParticleElementInitColor() {
    memset(this, 0, sizeof(EffectParticleElementInitColor));
  }
  EffectParticleElementInitColor(uint32_t _ColorMinValue, uint32_t _ColorMaxValue)
      : ColorMinValue_(flatbuffers::EndianScalar(_ColorMinValue)),
        ColorMaxValue_(flatbuffers::EndianScalar(_ColorMaxValue)) {
  }
  uint32_t ColorMinValue() const {
    return flatbuffers::EndianScalar(ColorMinValue_);
  }
  uint32_t ColorMaxValue() const {
    return flatbuffers::EndianScalar(ColorMaxValue_);
  }
};
FLATBUFFERS_STRUCT_END(EffectParticleElementInitColor, 8);

inline bool operator==(const EffectParticleElementInitColor &lhs, const EffectParticleElementInitColor &rhs) {
  return
      (lhs.ColorMinValue() == rhs.ColorMinValue()) &&
      (lhs.ColorMaxValue() == rhs.ColorMaxValue());
}

FLATBUFFERS_MANUALLY_ALIGNED_STRUCT(4) EffectParticleElementTangentialAcceleration FLATBUFFERS_FINAL_CLASS {
 private:
  float AccelerationMinValue_;
  float AccelerationMaxValue_;

 public:
  EffectParticleElementTangentialAcceleration() {
    memset(this, 0, sizeof(EffectParticleElementTangentialAcceleration));
  }
  EffectParticleElementTangentialAcceleration(float _AccelerationMinValue, float _AccelerationMaxValue)
      : AccelerationMinValue_(flatbuffers::EndianScalar(_AccelerationMinValue)),
        AccelerationMaxValue_(flatbuffers::EndianScalar(_AccelerationMaxValue)) {
  }
  float AccelerationMinValue() const {
    return flatbuffers::EndianScalar(AccelerationMinValue_);
  }
  float AccelerationMaxValue() const {
    return flatbuffers::EndianScalar(AccelerationMaxValue_);
  }
};
FLATBUFFERS_STRUCT_END(EffectParticleElementTangentialAcceleration, 8);

inline bool operator==(const EffectParticleElementTangentialAcceleration &lhs, const EffectParticleElementTangentialAcceleration &rhs) {
  return
      (lhs.AccelerationMinValue() == rhs.AccelerationMinValue()) &&
      (lhs.AccelerationMaxValue() == rhs.AccelerationMaxValue());
}

FLATBUFFERS_MANUALLY_ALIGNED_STRUCT(4) EffectParticleElementTransSpeed FLATBUFFERS_FINAL_CLASS {
 private:
  float SpeedMinValue_;
  float SpeedMaxValue_;

 public:
  EffectParticleElementTransSpeed() {
    memset(this, 0, sizeof(EffectParticleElementTransSpeed));
  }
  EffectParticleElementTransSpeed(float _SpeedMinValue, float _SpeedMaxValue)
      : SpeedMinValue_(flatbuffers::EndianScalar(_SpeedMinValue)),
        SpeedMaxValue_(flatbuffers::EndianScalar(_SpeedMaxValue)) {
  }
  float SpeedMinValue() const {
    return flatbuffers::EndianScalar(SpeedMinValue_);
  }
  float SpeedMaxValue() const {
    return flatbuffers::EndianScalar(SpeedMaxValue_);
  }
};
FLATBUFFERS_STRUCT_END(EffectParticleElementTransSpeed, 8);

inline bool operator==(const EffectParticleElementTransSpeed &lhs, const EffectParticleElementTransSpeed &rhs) {
  return
      (lhs.SpeedMinValue() == rhs.SpeedMinValue()) &&
      (lhs.SpeedMaxValue() == rhs.SpeedMaxValue());
}

FLATBUFFERS_MANUALLY_ALIGNED_STRUCT(4) EffectParticleElementRotationTrans FLATBUFFERS_FINAL_CLASS {
 private:
  float RotationFactor_;
  float EndLifeTimePer_;

 public:
  EffectParticleElementRotationTrans() {
    memset(this, 0, sizeof(EffectParticleElementRotationTrans));
  }
  EffectParticleElementRotationTrans(float _RotationFactor, float _EndLifeTimePer)
      : RotationFactor_(flatbuffers::EndianScalar(_RotationFactor)),
        EndLifeTimePer_(flatbuffers::EndianScalar(_EndLifeTimePer)) {
  }
  float RotationFactor() const {
    return flatbuffers::EndianScalar(RotationFactor_);
  }
  float EndLifeTimePer() const {
    return flatbuffers::EndianScalar(EndLifeTimePer_);
  }
};
FLATBUFFERS_STRUCT_END(EffectParticleElementRotationTrans, 8);

inline bool operator==(const EffectParticleElementRotationTrans &lhs, const EffectParticleElementRotationTrans &rhs) {
  return
      (lhs.RotationFactor() == rhs.RotationFactor()) &&
      (lhs.EndLifeTimePer() == rhs.EndLifeTimePer());
}

FLATBUFFERS_MANUALLY_ALIGNED_STRUCT(4) EffectParticleElementRotation FLATBUFFERS_FINAL_CLASS {
 private:
  float RotationMinValue_;
  float RotationMaxValue_;
  float RotationAddMinValue_;
  float RotationAddMaxValue_;

 public:
  EffectParticleElementRotation() {
    memset(this, 0, sizeof(EffectParticleElementRotation));
  }
  EffectParticleElementRotation(float _RotationMinValue, float _RotationMaxValue, float _RotationAddMinValue, float _RotationAddMaxValue)
      : RotationMinValue_(flatbuffers::EndianScalar(_RotationMinValue)),
        RotationMaxValue_(flatbuffers::EndianScalar(_RotationMaxValue)),
        RotationAddMinValue_(flatbuffers::EndianScalar(_RotationAddMinValue)),
        RotationAddMaxValue_(flatbuffers::EndianScalar(_RotationAddMaxValue)) {
  }
  float RotationMinValue() const {
    return flatbuffers::EndianScalar(RotationMinValue_);
  }
  float RotationMaxValue() const {
    return flatbuffers::EndianScalar(RotationMaxValue_);
  }
  float RotationAddMinValue() const {
    return flatbuffers::EndianScalar(RotationAddMinValue_);
  }
  float RotationAddMaxValue() const {
    return flatbuffers::EndianScalar(RotationAddMaxValue_);
  }
};
FLATBUFFERS_STRUCT_END(EffectParticleElementRotation, 16);

inline bool operator==(const EffectParticleElementRotation &lhs, const EffectParticleElementRotation &rhs) {
  return
      (lhs.RotationMinValue() == rhs.RotationMinValue()) &&
      (lhs.RotationMaxValue() == rhs.RotationMaxValue()) &&
      (lhs.RotationAddMinValue() == rhs.RotationAddMinValue()) &&
      (lhs.RotationAddMaxValue() == rhs.RotationAddMaxValue());
}

FLATBUFFERS_MANUALLY_ALIGNED_STRUCT(4) EffectParticleElementPosition FLATBUFFERS_FINAL_CLASS {
 private:
  float OffsetXMinValue_;
  float OffsetXMaxValue_;
  float OffsetYMinValue_;
  float OffsetYMaxValue_;

 public:
  EffectParticleElementPosition() {
    memset(this, 0, sizeof(EffectParticleElementPosition));
  }
  EffectParticleElementPosition(float _OffsetXMinValue, float _OffsetXMaxValue, float _OffsetYMinValue, float _OffsetYMaxValue)
      : OffsetXMinValue_(flatbuffers::EndianScalar(_OffsetXMinValue)),
        OffsetXMaxValue_(flatbuffers::EndianScalar(_OffsetXMaxValue)),
        OffsetYMinValue_(flatbuffers::EndianScalar(_OffsetYMinValue)),
        OffsetYMaxValue_(flatbuffers::EndianScalar(_OffsetYMaxValue)) {
  }
  float OffsetXMinValue() const {
    return flatbuffers::EndianScalar(OffsetXMinValue_);
  }
  float OffsetXMaxValue() const {
    return flatbuffers::EndianScalar(OffsetXMaxValue_);
  }
  float OffsetYMinValue() const {
    return flatbuffers::EndianScalar(OffsetYMinValue_);
  }
  float OffsetYMaxValue() const {
    return flatbuffers::EndianScalar(OffsetYMaxValue_);
  }
};
FLATBUFFERS_STRUCT_END(EffectParticleElementPosition, 16);

inline bool operator==(const EffectParticleElementPosition &lhs, const EffectParticleElementPosition &rhs) {
  return
      (lhs.OffsetXMinValue() == rhs.OffsetXMinValue()) &&
      (lhs.OffsetXMaxValue() == rhs.OffsetXMaxValue()) &&
      (lhs.OffsetYMinValue() == rhs.OffsetYMinValue()) &&
      (lhs.OffsetYMaxValue() == rhs.OffsetYMaxValue());
}

FLATBUFFERS_MANUALLY_ALIGNED_STRUCT(4) EffectParticleElementGravity FLATBUFFERS_FINAL_CLASS {
 private:
  float Gravity_x_;
  float Gravity_y_;

 public:
  EffectParticleElementGravity() {
    memset(this, 0, sizeof(EffectParticleElementGravity));
  }
  EffectParticleElementGravity(float _Gravity_x, float _Gravity_y)
      : Gravity_x_(flatbuffers::EndianScalar(_Gravity_x)),
        Gravity_y_(flatbuffers::EndianScalar(_Gravity_y)) {
  }
  float Gravity_x() const {
    return flatbuffers::EndianScalar(Gravity_x_);
  }
  float Gravity_y() const {
    return flatbuffers::EndianScalar(Gravity_y_);
  }
};
FLATBUFFERS_STRUCT_END(EffectParticleElementGravity, 8);

inline bool operator==(const EffectParticleElementGravity &lhs, const EffectParticleElementGravity &rhs) {
  return
      (lhs.Gravity_x() == rhs.Gravity_x()) &&
      (lhs.Gravity_y() == rhs.Gravity_y());
}

FLATBUFFERS_MANUALLY_ALIGNED_STRUCT(4) EffectParticleElementDelay FLATBUFFERS_FINAL_CLASS {
 private:
  int32_t DelayTime_;

 public:
  EffectParticleElementDelay() {
    memset(this, 0, sizeof(EffectParticleElementDelay));
  }
  EffectParticleElementDelay(int32_t _DelayTime)
      : DelayTime_(flatbuffers::EndianScalar(_DelayTime)) {
  }
  int32_t DelayTime() const {
    return flatbuffers::EndianScalar(DelayTime_);
  }
};
FLATBUFFERS_STRUCT_END(EffectParticleElementDelay, 4);

inline bool operator==(const EffectParticleElementDelay &lhs, const EffectParticleElementDelay &rhs) {
  return
      (lhs.DelayTime() == rhs.DelayTime());
}

FLATBUFFERS_MANUALLY_ALIGNED_STRUCT(4) EffectParticleElementRndSeedChange FLATBUFFERS_FINAL_CLASS {
 private:
  int32_t Seed_;

 public:
  EffectParticleElementRndSeedChange() {
    memset(this, 0, sizeof(EffectParticleElementRndSeedChange));
  }
  EffectParticleElementRndSeedChange(int32_t _Seed)
      : Seed_(flatbuffers::EndianScalar(_Seed)) {
  }
  int32_t Seed() const {
    return flatbuffers::EndianScalar(Seed_);
  }
};
FLATBUFFERS_STRUCT_END(EffectParticleElementRndSeedChange, 4);

inline bool operator==(const EffectParticleElementRndSeedChange &lhs, const EffectParticleElementRndSeedChange &rhs) {
  return
      (lhs.Seed() == rhs.Seed());
}

FLATBUFFERS_MANUALLY_ALIGNED_STRUCT(4) EffectParticleElementBasic FLATBUFFERS_FINAL_CLASS {
 private:
  int32_t SsEffectFunctionType_;
  int32_t priority_;
  int32_t maximumParticle_;
  int32_t attimeCreate_;
  int32_t interval_;
  int32_t lifetime_;
  float speedMinValue_;
  float speedMaxValue_;
  int32_t lifespanMinValue_;
  int32_t lifespanMaxValue_;
  float angle_;
  float angleVariance_;

 public:
  EffectParticleElementBasic() {
    memset(this, 0, sizeof(EffectParticleElementBasic));
  }
  EffectParticleElementBasic(int32_t _SsEffectFunctionType, int32_t _priority, int32_t _maximumParticle, int32_t _attimeCreate, int32_t _interval, int32_t _lifetime, float _speedMinValue, float _speedMaxValue, int32_t _lifespanMinValue, int32_t _lifespanMaxValue, float _angle, float _angleVariance)
      : SsEffectFunctionType_(flatbuffers::EndianScalar(_SsEffectFunctionType)),
        priority_(flatbuffers::EndianScalar(_priority)),
        maximumParticle_(flatbuffers::EndianScalar(_maximumParticle)),
        attimeCreate_(flatbuffers::EndianScalar(_attimeCreate)),
        interval_(flatbuffers::EndianScalar(_interval)),
        lifetime_(flatbuffers::EndianScalar(_lifetime)),
        speedMinValue_(flatbuffers::EndianScalar(_speedMinValue)),
        speedMaxValue_(flatbuffers::EndianScalar(_speedMaxValue)),
        lifespanMinValue_(flatbuffers::EndianScalar(_lifespanMinValue)),
        lifespanMaxValue_(flatbuffers::EndianScalar(_lifespanMaxValue)),
        angle_(flatbuffers::EndianScalar(_angle)),
        angleVariance_(flatbuffers::EndianScalar(_angleVariance)) {
  }
  int32_t SsEffectFunctionType() const {
    return flatbuffers::EndianScalar(SsEffectFunctionType_);
  }
  int32_t priority() const {
    return flatbuffers::EndianScalar(priority_);
  }
  int32_t maximumParticle() const {
    return flatbuffers::EndianScalar(maximumParticle_);
  }
  int32_t attimeCreate() const {
    return flatbuffers::EndianScalar(attimeCreate_);
  }
  int32_t interval() const {
    return flatbuffers::EndianScalar(interval_);
  }
  int32_t lifetime() const {
    return flatbuffers::EndianScalar(lifetime_);
  }
  float speedMinValue() const {
    return flatbuffers::EndianScalar(speedMinValue_);
  }
  float speedMaxValue() const {
    return flatbuffers::EndianScalar(speedMaxValue_);
  }
  int32_t lifespanMinValue() const {
    return flatbuffers::EndianScalar(lifespanMinValue_);
  }
  int32_t lifespanMaxValue() const {
    return flatbuffers::EndianScalar(lifespanMaxValue_);
  }
  float angle() const {
    return flatbuffers::EndianScalar(angle_);
  }
  float angleVariance() const {
    return flatbuffers::EndianScalar(angleVariance_);
  }
};
FLATBUFFERS_STRUCT_END(EffectParticleElementBasic, 48);

inline bool operator==(const EffectParticleElementBasic &lhs, const EffectParticleElementBasic &rhs) {
  return
      (lhs.SsEffectFunctionType() == rhs.SsEffectFunctionType()) &&
      (lhs.priority() == rhs.priority()) &&
      (lhs.maximumParticle() == rhs.maximumParticle()) &&
      (lhs.attimeCreate() == rhs.attimeCreate()) &&
      (lhs.interval() == rhs.interval()) &&
      (lhs.lifetime() == rhs.lifetime()) &&
      (lhs.speedMinValue() == rhs.speedMinValue()) &&
      (lhs.speedMaxValue() == rhs.speedMaxValue()) &&
      (lhs.lifespanMinValue() == rhs.lifespanMinValue()) &&
      (lhs.lifespanMaxValue() == rhs.lifespanMaxValue()) &&
      (lhs.angle() == rhs.angle()) &&
      (lhs.angleVariance() == rhs.angleVariance());
}

FLATBUFFERS_MANUALLY_ALIGNED_STRUCT(4) userDataInteger FLATBUFFERS_FINAL_CLASS {
 private:
  int32_t integer_;

 public:
  userDataInteger() {
    memset(this, 0, sizeof(userDataInteger));
  }
  userDataInteger(int32_t _integer)
      : integer_(flatbuffers::EndianScalar(_integer)) {
  }
  int32_t integer() const {
    return flatbuffers::EndianScalar(integer_);
  }
};
FLATBUFFERS_STRUCT_END(userDataInteger, 4);

inline bool operator==(const userDataInteger &lhs, const userDataInteger &rhs) {
  return
      (lhs.integer() == rhs.integer());
}

FLATBUFFERS_MANUALLY_ALIGNED_STRUCT(4) userDataRect FLATBUFFERS_FINAL_CLASS {
 private:
  int32_t x_;
  int32_t y_;
  int32_t w_;
  int32_t h_;

 public:
  userDataRect() {
    memset(this, 0, sizeof(userDataRect));
  }
  userDataRect(int32_t _x, int32_t _y, int32_t _w, int32_t _h)
      : x_(flatbuffers::EndianScalar(_x)),
        y_(flatbuffers::EndianScalar(_y)),
        w_(flatbuffers::EndianScalar(_w)),
        h_(flatbuffers::EndianScalar(_h)) {
  }
  int32_t x() const {
    return flatbuffers::EndianScalar(x_);
  }
  int32_t y() const {
    return flatbuffers::EndianScalar(y_);
  }
  int32_t w() const {
    return flatbuffers::EndianScalar(w_);
  }
  int32_t h() const {
    return flatbuffers::EndianScalar(h_);
  }
};
FLATBUFFERS_STRUCT_END(userDataRect, 16);

inline bool operator==(const userDataRect &lhs, const userDataRect &rhs) {
  return
      (lhs.x() == rhs.x()) &&
      (lhs.y() == rhs.y()) &&
      (lhs.w() == rhs.w()) &&
      (lhs.h() == rhs.h());
}

FLATBUFFERS_MANUALLY_ALIGNED_STRUCT(4) userDataPoint FLATBUFFERS_FINAL_CLASS {
 private:
  int32_t x_;
  int32_t y_;

 public:
  userDataPoint() {
    memset(this, 0, sizeof(userDataPoint));
  }
  userDataPoint(int32_t _x, int32_t _y)
      : x_(flatbuffers::EndianScalar(_x)),
        y_(flatbuffers::EndianScalar(_y)) {
  }
  int32_t x() const {
    return flatbuffers::EndianScalar(x_);
  }
  int32_t y() const {
    return flatbuffers::EndianScalar(y_);
  }
};
FLATBUFFERS_STRUCT_END(userDataPoint, 8);

inline bool operator==(const userDataPoint &lhs, const userDataPoint &rhs) {
  return
      (lhs.x() == rhs.x()) &&
      (lhs.y() == rhs.y());
}

struct EffectNodeT : public flatbuffers::NativeTable {
  typedef EffectNode TableType;
  int16_t arrayIndex;
  int16_t parentIndex;
  int16_t type;
  int16_t cellIndex;
  int16_t blendType;
  int16_t numBehavior;
  std::vector<EffectNodeBehaviorUnion> Behavior;
  EffectNodeT()
      : arrayIndex(0),
        parentIndex(0),
        type(0),
        cellIndex(0),
        blendType(0),
        numBehavior(0) {
  }
};

inline bool operator==(const EffectNodeT &lhs, const EffectNodeT &rhs) {
  return
      (lhs.arrayIndex == rhs.arrayIndex) &&
      (lhs.parentIndex == rhs.parentIndex) &&
      (lhs.type == rhs.type) &&
      (lhs.cellIndex == rhs.cellIndex) &&
      (lhs.blendType == rhs.blendType) &&
      (lhs.numBehavior == rhs.numBehavior) &&
      (lhs.Behavior == rhs.Behavior);
}

struct EffectNode FLATBUFFERS_FINAL_CLASS : private flatbuffers::Table {
  typedef EffectNodeT NativeTableType;
  enum {
    VT_ARRAYINDEX = 4,
    VT_PARENTINDEX = 6,
    VT_TYPE = 8,
    VT_CELLINDEX = 10,
    VT_BLENDTYPE = 12,
    VT_NUMBEHAVIOR = 14,
    VT_BEHAVIOR_TYPE = 16,
    VT_BEHAVIOR = 18
  };
  int16_t arrayIndex() const {
    return GetField<int16_t>(VT_ARRAYINDEX, 0);
  }
  int16_t parentIndex() const {
    return GetField<int16_t>(VT_PARENTINDEX, 0);
  }
  int16_t type() const {
    return GetField<int16_t>(VT_TYPE, 0);
  }
  int16_t cellIndex() const {
    return GetField<int16_t>(VT_CELLINDEX, 0);
  }
  int16_t blendType() const {
    return GetField<int16_t>(VT_BLENDTYPE, 0);
  }
  int16_t numBehavior() const {
    return GetField<int16_t>(VT_NUMBEHAVIOR, 0);
  }
  const flatbuffers::Vector<uint8_t> *Behavior_type() const {
    return GetPointer<const flatbuffers::Vector<uint8_t> *>(VT_BEHAVIOR_TYPE);
  }
  const flatbuffers::Vector<flatbuffers::Offset<void>> *Behavior() const {
    return GetPointer<const flatbuffers::Vector<flatbuffers::Offset<void>> *>(VT_BEHAVIOR);
  }
  bool Verify(flatbuffers::Verifier &verifier) const {
    return VerifyTableStart(verifier) &&
           VerifyField<int16_t>(verifier, VT_ARRAYINDEX) &&
           VerifyField<int16_t>(verifier, VT_PARENTINDEX) &&
           VerifyField<int16_t>(verifier, VT_TYPE) &&
           VerifyField<int16_t>(verifier, VT_CELLINDEX) &&
           VerifyField<int16_t>(verifier, VT_BLENDTYPE) &&
           VerifyField<int16_t>(verifier, VT_NUMBEHAVIOR) &&
           VerifyOffset(verifier, VT_BEHAVIOR_TYPE) &&
           verifier.VerifyVector(Behavior_type()) &&
           VerifyOffset(verifier, VT_BEHAVIOR) &&
           verifier.VerifyVector(Behavior()) &&
           VerifyEffectNodeBehaviorVector(verifier, Behavior(), Behavior_type()) &&
           verifier.EndTable();
  }
  EffectNodeT *UnPack(const flatbuffers::resolver_function_t *_resolver = nullptr) const;
  void UnPackTo(EffectNodeT *_o, const flatbuffers::resolver_function_t *_resolver = nullptr) const;
  static flatbuffers::Offset<EffectNode> Pack(flatbuffers::FlatBufferBuilder &_fbb, const EffectNodeT* _o, const flatbuffers::rehasher_function_t *_rehasher = nullptr);
};

struct EffectNodeBuilder {
  flatbuffers::FlatBufferBuilder &fbb_;
  flatbuffers::uoffset_t start_;
  void add_arrayIndex(int16_t arrayIndex) {
    fbb_.AddElement<int16_t>(EffectNode::VT_ARRAYINDEX, arrayIndex, 0);
  }
  void add_parentIndex(int16_t parentIndex) {
    fbb_.AddElement<int16_t>(EffectNode::VT_PARENTINDEX, parentIndex, 0);
  }
  void add_type(int16_t type) {
    fbb_.AddElement<int16_t>(EffectNode::VT_TYPE, type, 0);
  }
  void add_cellIndex(int16_t cellIndex) {
    fbb_.AddElement<int16_t>(EffectNode::VT_CELLINDEX, cellIndex, 0);
  }
  void add_blendType(int16_t blendType) {
    fbb_.AddElement<int16_t>(EffectNode::VT_BLENDTYPE, blendType, 0);
  }
  void add_numBehavior(int16_t numBehavior) {
    fbb_.AddElement<int16_t>(EffectNode::VT_NUMBEHAVIOR, numBehavior, 0);
  }
  void add_Behavior_type(flatbuffers::Offset<flatbuffers::Vector<uint8_t>> Behavior_type) {
    fbb_.AddOffset(EffectNode::VT_BEHAVIOR_TYPE, Behavior_type);
  }
  void add_Behavior(flatbuffers::Offset<flatbuffers::Vector<flatbuffers::Offset<void>>> Behavior) {
    fbb_.AddOffset(EffectNode::VT_BEHAVIOR, Behavior);
  }
  explicit EffectNodeBuilder(flatbuffers::FlatBufferBuilder &_fbb)
        : fbb_(_fbb) {
    start_ = fbb_.StartTable();
  }
  EffectNodeBuilder &operator=(const EffectNodeBuilder &);
  flatbuffers::Offset<EffectNode> Finish() {
    const auto end = fbb_.EndTable(start_);
    auto o = flatbuffers::Offset<EffectNode>(end);
    return o;
  }
};

inline flatbuffers::Offset<EffectNode> CreateEffectNode(
    flatbuffers::FlatBufferBuilder &_fbb,
    int16_t arrayIndex = 0,
    int16_t parentIndex = 0,
    int16_t type = 0,
    int16_t cellIndex = 0,
    int16_t blendType = 0,
    int16_t numBehavior = 0,
    flatbuffers::Offset<flatbuffers::Vector<uint8_t>> Behavior_type = 0,
    flatbuffers::Offset<flatbuffers::Vector<flatbuffers::Offset<void>>> Behavior = 0) {
  EffectNodeBuilder builder_(_fbb);
  builder_.add_Behavior(Behavior);
  builder_.add_Behavior_type(Behavior_type);
  builder_.add_numBehavior(numBehavior);
  builder_.add_blendType(blendType);
  builder_.add_cellIndex(cellIndex);
  builder_.add_type(type);
  builder_.add_parentIndex(parentIndex);
  builder_.add_arrayIndex(arrayIndex);
  return builder_.Finish();
}

inline flatbuffers::Offset<EffectNode> CreateEffectNodeDirect(
    flatbuffers::FlatBufferBuilder &_fbb,
    int16_t arrayIndex = 0,
    int16_t parentIndex = 0,
    int16_t type = 0,
    int16_t cellIndex = 0,
    int16_t blendType = 0,
    int16_t numBehavior = 0,
    const std::vector<uint8_t> *Behavior_type = nullptr,
    const std::vector<flatbuffers::Offset<void>> *Behavior = nullptr) {
  return ss::ssfb::CreateEffectNode(
      _fbb,
      arrayIndex,
      parentIndex,
      type,
      cellIndex,
      blendType,
      numBehavior,
      Behavior_type ? _fbb.CreateVector<uint8_t>(*Behavior_type) : 0,
      Behavior ? _fbb.CreateVector<flatbuffers::Offset<void>>(*Behavior) : 0);
}

flatbuffers::Offset<EffectNode> CreateEffectNode(flatbuffers::FlatBufferBuilder &_fbb, const EffectNodeT *_o, const flatbuffers::rehasher_function_t *_rehasher = nullptr);

struct EffectFileT : public flatbuffers::NativeTable {
  typedef EffectFile TableType;
  std::string name;
  int16_t fps;
  int16_t isLockRandSeed;
  int16_t lockRandSeed;
  int16_t layoutScaleX;
  int16_t layoutScaleY;
  int16_t numNodeList;
  std::vector<std::unique_ptr<EffectNodeT>> effectNode;
  EffectFileT()
      : fps(0),
        isLockRandSeed(0),
        lockRandSeed(0),
        layoutScaleX(0),
        layoutScaleY(0),
        numNodeList(0) {
  }
};

inline bool operator==(const EffectFileT &lhs, const EffectFileT &rhs) {
  return
      (lhs.name == rhs.name) &&
      (lhs.fps == rhs.fps) &&
      (lhs.isLockRandSeed == rhs.isLockRandSeed) &&
      (lhs.lockRandSeed == rhs.lockRandSeed) &&
      (lhs.layoutScaleX == rhs.layoutScaleX) &&
      (lhs.layoutScaleY == rhs.layoutScaleY) &&
      (lhs.numNodeList == rhs.numNodeList) &&
      (lhs.effectNode == rhs.effectNode);
}

struct EffectFile FLATBUFFERS_FINAL_CLASS : private flatbuffers::Table {
  typedef EffectFileT NativeTableType;
  enum {
    VT_NAME = 4,
    VT_FPS = 6,
    VT_ISLOCKRANDSEED = 8,
    VT_LOCKRANDSEED = 10,
    VT_LAYOUTSCALEX = 12,
    VT_LAYOUTSCALEY = 14,
    VT_NUMNODELIST = 16,
    VT_EFFECTNODE = 18
  };
  const flatbuffers::String *name() const {
    return GetPointer<const flatbuffers::String *>(VT_NAME);
  }
  int16_t fps() const {
    return GetField<int16_t>(VT_FPS, 0);
  }
  int16_t isLockRandSeed() const {
    return GetField<int16_t>(VT_ISLOCKRANDSEED, 0);
  }
  int16_t lockRandSeed() const {
    return GetField<int16_t>(VT_LOCKRANDSEED, 0);
  }
  int16_t layoutScaleX() const {
    return GetField<int16_t>(VT_LAYOUTSCALEX, 0);
  }
  int16_t layoutScaleY() const {
    return GetField<int16_t>(VT_LAYOUTSCALEY, 0);
  }
  int16_t numNodeList() const {
    return GetField<int16_t>(VT_NUMNODELIST, 0);
  }
  const flatbuffers::Vector<flatbuffers::Offset<EffectNode>> *effectNode() const {
    return GetPointer<const flatbuffers::Vector<flatbuffers::Offset<EffectNode>> *>(VT_EFFECTNODE);
  }
  bool Verify(flatbuffers::Verifier &verifier) const {
    return VerifyTableStart(verifier) &&
           VerifyOffset(verifier, VT_NAME) &&
           verifier.VerifyString(name()) &&
           VerifyField<int16_t>(verifier, VT_FPS) &&
           VerifyField<int16_t>(verifier, VT_ISLOCKRANDSEED) &&
           VerifyField<int16_t>(verifier, VT_LOCKRANDSEED) &&
           VerifyField<int16_t>(verifier, VT_LAYOUTSCALEX) &&
           VerifyField<int16_t>(verifier, VT_LAYOUTSCALEY) &&
           VerifyField<int16_t>(verifier, VT_NUMNODELIST) &&
           VerifyOffset(verifier, VT_EFFECTNODE) &&
           verifier.VerifyVector(effectNode()) &&
           verifier.VerifyVectorOfTables(effectNode()) &&
           verifier.EndTable();
  }
  EffectFileT *UnPack(const flatbuffers::resolver_function_t *_resolver = nullptr) const;
  void UnPackTo(EffectFileT *_o, const flatbuffers::resolver_function_t *_resolver = nullptr) const;
  static flatbuffers::Offset<EffectFile> Pack(flatbuffers::FlatBufferBuilder &_fbb, const EffectFileT* _o, const flatbuffers::rehasher_function_t *_rehasher = nullptr);
};

struct EffectFileBuilder {
  flatbuffers::FlatBufferBuilder &fbb_;
  flatbuffers::uoffset_t start_;
  void add_name(flatbuffers::Offset<flatbuffers::String> name) {
    fbb_.AddOffset(EffectFile::VT_NAME, name);
  }
  void add_fps(int16_t fps) {
    fbb_.AddElement<int16_t>(EffectFile::VT_FPS, fps, 0);
  }
  void add_isLockRandSeed(int16_t isLockRandSeed) {
    fbb_.AddElement<int16_t>(EffectFile::VT_ISLOCKRANDSEED, isLockRandSeed, 0);
  }
  void add_lockRandSeed(int16_t lockRandSeed) {
    fbb_.AddElement<int16_t>(EffectFile::VT_LOCKRANDSEED, lockRandSeed, 0);
  }
  void add_layoutScaleX(int16_t layoutScaleX) {
    fbb_.AddElement<int16_t>(EffectFile::VT_LAYOUTSCALEX, layoutScaleX, 0);
  }
  void add_layoutScaleY(int16_t layoutScaleY) {
    fbb_.AddElement<int16_t>(EffectFile::VT_LAYOUTSCALEY, layoutScaleY, 0);
  }
  void add_numNodeList(int16_t numNodeList) {
    fbb_.AddElement<int16_t>(EffectFile::VT_NUMNODELIST, numNodeList, 0);
  }
  void add_effectNode(flatbuffers::Offset<flatbuffers::Vector<flatbuffers::Offset<EffectNode>>> effectNode) {
    fbb_.AddOffset(EffectFile::VT_EFFECTNODE, effectNode);
  }
  explicit EffectFileBuilder(flatbuffers::FlatBufferBuilder &_fbb)
        : fbb_(_fbb) {
    start_ = fbb_.StartTable();
  }
  EffectFileBuilder &operator=(const EffectFileBuilder &);
  flatbuffers::Offset<EffectFile> Finish() {
    const auto end = fbb_.EndTable(start_);
    auto o = flatbuffers::Offset<EffectFile>(end);
    return o;
  }
};

inline flatbuffers::Offset<EffectFile> CreateEffectFile(
    flatbuffers::FlatBufferBuilder &_fbb,
    flatbuffers::Offset<flatbuffers::String> name = 0,
    int16_t fps = 0,
    int16_t isLockRandSeed = 0,
    int16_t lockRandSeed = 0,
    int16_t layoutScaleX = 0,
    int16_t layoutScaleY = 0,
    int16_t numNodeList = 0,
    flatbuffers::Offset<flatbuffers::Vector<flatbuffers::Offset<EffectNode>>> effectNode = 0) {
  EffectFileBuilder builder_(_fbb);
  builder_.add_effectNode(effectNode);
  builder_.add_name(name);
  builder_.add_numNodeList(numNodeList);
  builder_.add_layoutScaleY(layoutScaleY);
  builder_.add_layoutScaleX(layoutScaleX);
  builder_.add_lockRandSeed(lockRandSeed);
  builder_.add_isLockRandSeed(isLockRandSeed);
  builder_.add_fps(fps);
  return builder_.Finish();
}

inline flatbuffers::Offset<EffectFile> CreateEffectFileDirect(
    flatbuffers::FlatBufferBuilder &_fbb,
    const char *name = nullptr,
    int16_t fps = 0,
    int16_t isLockRandSeed = 0,
    int16_t lockRandSeed = 0,
    int16_t layoutScaleX = 0,
    int16_t layoutScaleY = 0,
    int16_t numNodeList = 0,
    const std::vector<flatbuffers::Offset<EffectNode>> *effectNode = nullptr) {
  return ss::ssfb::CreateEffectFile(
      _fbb,
      name ? _fbb.CreateString(name) : 0,
      fps,
      isLockRandSeed,
      lockRandSeed,
      layoutScaleX,
      layoutScaleY,
      numNodeList,
      effectNode ? _fbb.CreateVector<flatbuffers::Offset<EffectNode>>(*effectNode) : 0);
}

flatbuffers::Offset<EffectFile> CreateEffectFile(flatbuffers::FlatBufferBuilder &_fbb, const EffectFileT *_o, const flatbuffers::rehasher_function_t *_rehasher = nullptr);

struct CellMapT : public flatbuffers::NativeTable {
  typedef CellMap TableType;
  std::string name;
  std::string imagePath;
  int16_t index;
  int16_t wrapmode;
  int16_t filtermode;
  CellMapT()
      : index(0),
        wrapmode(0),
        filtermode(0) {
  }
};

inline bool operator==(const CellMapT &lhs, const CellMapT &rhs) {
  return
      (lhs.name == rhs.name) &&
      (lhs.imagePath == rhs.imagePath) &&
      (lhs.index == rhs.index) &&
      (lhs.wrapmode == rhs.wrapmode) &&
      (lhs.filtermode == rhs.filtermode);
}

struct CellMap FLATBUFFERS_FINAL_CLASS : private flatbuffers::Table {
  typedef CellMapT NativeTableType;
  enum {
    VT_NAME = 4,
    VT_IMAGEPATH = 6,
    VT_INDEX = 8,
    VT_WRAPMODE = 10,
    VT_FILTERMODE = 12
  };
  const flatbuffers::String *name() const {
    return GetPointer<const flatbuffers::String *>(VT_NAME);
  }
  const flatbuffers::String *imagePath() const {
    return GetPointer<const flatbuffers::String *>(VT_IMAGEPATH);
  }
  int16_t index() const {
    return GetField<int16_t>(VT_INDEX, 0);
  }
  int16_t wrapmode() const {
    return GetField<int16_t>(VT_WRAPMODE, 0);
  }
  int16_t filtermode() const {
    return GetField<int16_t>(VT_FILTERMODE, 0);
  }
  bool Verify(flatbuffers::Verifier &verifier) const {
    return VerifyTableStart(verifier) &&
           VerifyOffset(verifier, VT_NAME) &&
           verifier.VerifyString(name()) &&
           VerifyOffset(verifier, VT_IMAGEPATH) &&
           verifier.VerifyString(imagePath()) &&
           VerifyField<int16_t>(verifier, VT_INDEX) &&
           VerifyField<int16_t>(verifier, VT_WRAPMODE) &&
           VerifyField<int16_t>(verifier, VT_FILTERMODE) &&
           verifier.EndTable();
  }
  CellMapT *UnPack(const flatbuffers::resolver_function_t *_resolver = nullptr) const;
  void UnPackTo(CellMapT *_o, const flatbuffers::resolver_function_t *_resolver = nullptr) const;
  static flatbuffers::Offset<CellMap> Pack(flatbuffers::FlatBufferBuilder &_fbb, const CellMapT* _o, const flatbuffers::rehasher_function_t *_rehasher = nullptr);
};

struct CellMapBuilder {
  flatbuffers::FlatBufferBuilder &fbb_;
  flatbuffers::uoffset_t start_;
  void add_name(flatbuffers::Offset<flatbuffers::String> name) {
    fbb_.AddOffset(CellMap::VT_NAME, name);
  }
  void add_imagePath(flatbuffers::Offset<flatbuffers::String> imagePath) {
    fbb_.AddOffset(CellMap::VT_IMAGEPATH, imagePath);
  }
  void add_index(int16_t index) {
    fbb_.AddElement<int16_t>(CellMap::VT_INDEX, index, 0);
  }
  void add_wrapmode(int16_t wrapmode) {
    fbb_.AddElement<int16_t>(CellMap::VT_WRAPMODE, wrapmode, 0);
  }
  void add_filtermode(int16_t filtermode) {
    fbb_.AddElement<int16_t>(CellMap::VT_FILTERMODE, filtermode, 0);
  }
  explicit CellMapBuilder(flatbuffers::FlatBufferBuilder &_fbb)
        : fbb_(_fbb) {
    start_ = fbb_.StartTable();
  }
  CellMapBuilder &operator=(const CellMapBuilder &);
  flatbuffers::Offset<CellMap> Finish() {
    const auto end = fbb_.EndTable(start_);
    auto o = flatbuffers::Offset<CellMap>(end);
    return o;
  }
};

inline flatbuffers::Offset<CellMap> CreateCellMap(
    flatbuffers::FlatBufferBuilder &_fbb,
    flatbuffers::Offset<flatbuffers::String> name = 0,
    flatbuffers::Offset<flatbuffers::String> imagePath = 0,
    int16_t index = 0,
    int16_t wrapmode = 0,
    int16_t filtermode = 0) {
  CellMapBuilder builder_(_fbb);
  builder_.add_imagePath(imagePath);
  builder_.add_name(name);
  builder_.add_filtermode(filtermode);
  builder_.add_wrapmode(wrapmode);
  builder_.add_index(index);
  return builder_.Finish();
}

inline flatbuffers::Offset<CellMap> CreateCellMapDirect(
    flatbuffers::FlatBufferBuilder &_fbb,
    const char *name = nullptr,
    const char *imagePath = nullptr,
    int16_t index = 0,
    int16_t wrapmode = 0,
    int16_t filtermode = 0) {
  return ss::ssfb::CreateCellMap(
      _fbb,
      name ? _fbb.CreateString(name) : 0,
      imagePath ? _fbb.CreateString(imagePath) : 0,
      index,
      wrapmode,
      filtermode);
}

flatbuffers::Offset<CellMap> CreateCellMap(flatbuffers::FlatBufferBuilder &_fbb, const CellMapT *_o, const flatbuffers::rehasher_function_t *_rehasher = nullptr);

struct CellT : public flatbuffers::NativeTable {
  typedef Cell TableType;
  std::string name;
  std::unique_ptr<CellMapT> cellMap;
  int16_t indexInCellMap;
  int16_t x;
  int16_t y;
  int16_t width;
  int16_t height;
  float pivot_x;
  float pivot_y;
  float u1;
  float v1;
  float u2;
  float v2;
  CellT()
      : indexInCellMap(0),
        x(0),
        y(0),
        width(0),
        height(0),
        pivot_x(0.0f),
        pivot_y(0.0f),
        u1(0.0f),
        v1(0.0f),
        u2(0.0f),
        v2(0.0f) {
  }
};

inline bool operator==(const CellT &lhs, const CellT &rhs) {
  return
      (lhs.name == rhs.name) &&
      (lhs.cellMap == rhs.cellMap) &&
      (lhs.indexInCellMap == rhs.indexInCellMap) &&
      (lhs.x == rhs.x) &&
      (lhs.y == rhs.y) &&
      (lhs.width == rhs.width) &&
      (lhs.height == rhs.height) &&
      (lhs.pivot_x == rhs.pivot_x) &&
      (lhs.pivot_y == rhs.pivot_y) &&
      (lhs.u1 == rhs.u1) &&
      (lhs.v1 == rhs.v1) &&
      (lhs.u2 == rhs.u2) &&
      (lhs.v2 == rhs.v2);
}

struct Cell FLATBUFFERS_FINAL_CLASS : private flatbuffers::Table {
  typedef CellT NativeTableType;
  enum {
    VT_NAME = 4,
    VT_CELLMAP = 6,
    VT_INDEXINCELLMAP = 8,
    VT_X = 10,
    VT_Y = 12,
    VT_WIDTH = 14,
    VT_HEIGHT = 16,
    VT_PIVOT_X = 18,
    VT_PIVOT_Y = 20,
    VT_U1 = 22,
    VT_V1 = 24,
    VT_U2 = 26,
    VT_V2 = 28
  };
  const flatbuffers::String *name() const {
    return GetPointer<const flatbuffers::String *>(VT_NAME);
  }
  const CellMap *cellMap() const {
    return GetPointer<const CellMap *>(VT_CELLMAP);
  }
  int16_t indexInCellMap() const {
    return GetField<int16_t>(VT_INDEXINCELLMAP, 0);
  }
  int16_t x() const {
    return GetField<int16_t>(VT_X, 0);
  }
  int16_t y() const {
    return GetField<int16_t>(VT_Y, 0);
  }
  int16_t width() const {
    return GetField<int16_t>(VT_WIDTH, 0);
  }
  int16_t height() const {
    return GetField<int16_t>(VT_HEIGHT, 0);
  }
  float pivot_x() const {
    return GetField<float>(VT_PIVOT_X, 0.0f);
  }
  float pivot_y() const {
    return GetField<float>(VT_PIVOT_Y, 0.0f);
  }
  float u1() const {
    return GetField<float>(VT_U1, 0.0f);
  }
  float v1() const {
    return GetField<float>(VT_V1, 0.0f);
  }
  float u2() const {
    return GetField<float>(VT_U2, 0.0f);
  }
  float v2() const {
    return GetField<float>(VT_V2, 0.0f);
  }
  bool Verify(flatbuffers::Verifier &verifier) const {
    return VerifyTableStart(verifier) &&
           VerifyOffset(verifier, VT_NAME) &&
           verifier.VerifyString(name()) &&
           VerifyOffset(verifier, VT_CELLMAP) &&
           verifier.VerifyTable(cellMap()) &&
           VerifyField<int16_t>(verifier, VT_INDEXINCELLMAP) &&
           VerifyField<int16_t>(verifier, VT_X) &&
           VerifyField<int16_t>(verifier, VT_Y) &&
           VerifyField<int16_t>(verifier, VT_WIDTH) &&
           VerifyField<int16_t>(verifier, VT_HEIGHT) &&
           VerifyField<float>(verifier, VT_PIVOT_X) &&
           VerifyField<float>(verifier, VT_PIVOT_Y) &&
           VerifyField<float>(verifier, VT_U1) &&
           VerifyField<float>(verifier, VT_V1) &&
           VerifyField<float>(verifier, VT_U2) &&
           VerifyField<float>(verifier, VT_V2) &&
           verifier.EndTable();
  }
  CellT *UnPack(const flatbuffers::resolver_function_t *_resolver = nullptr) const;
  void UnPackTo(CellT *_o, const flatbuffers::resolver_function_t *_resolver = nullptr) const;
  static flatbuffers::Offset<Cell> Pack(flatbuffers::FlatBufferBuilder &_fbb, const CellT* _o, const flatbuffers::rehasher_function_t *_rehasher = nullptr);
};

struct CellBuilder {
  flatbuffers::FlatBufferBuilder &fbb_;
  flatbuffers::uoffset_t start_;
  void add_name(flatbuffers::Offset<flatbuffers::String> name) {
    fbb_.AddOffset(Cell::VT_NAME, name);
  }
  void add_cellMap(flatbuffers::Offset<CellMap> cellMap) {
    fbb_.AddOffset(Cell::VT_CELLMAP, cellMap);
  }
  void add_indexInCellMap(int16_t indexInCellMap) {
    fbb_.AddElement<int16_t>(Cell::VT_INDEXINCELLMAP, indexInCellMap, 0);
  }
  void add_x(int16_t x) {
    fbb_.AddElement<int16_t>(Cell::VT_X, x, 0);
  }
  void add_y(int16_t y) {
    fbb_.AddElement<int16_t>(Cell::VT_Y, y, 0);
  }
  void add_width(int16_t width) {
    fbb_.AddElement<int16_t>(Cell::VT_WIDTH, width, 0);
  }
  void add_height(int16_t height) {
    fbb_.AddElement<int16_t>(Cell::VT_HEIGHT, height, 0);
  }
  void add_pivot_x(float pivot_x) {
    fbb_.AddElement<float>(Cell::VT_PIVOT_X, pivot_x, 0.0f);
  }
  void add_pivot_y(float pivot_y) {
    fbb_.AddElement<float>(Cell::VT_PIVOT_Y, pivot_y, 0.0f);
  }
  void add_u1(float u1) {
    fbb_.AddElement<float>(Cell::VT_U1, u1, 0.0f);
  }
  void add_v1(float v1) {
    fbb_.AddElement<float>(Cell::VT_V1, v1, 0.0f);
  }
  void add_u2(float u2) {
    fbb_.AddElement<float>(Cell::VT_U2, u2, 0.0f);
  }
  void add_v2(float v2) {
    fbb_.AddElement<float>(Cell::VT_V2, v2, 0.0f);
  }
  explicit CellBuilder(flatbuffers::FlatBufferBuilder &_fbb)
        : fbb_(_fbb) {
    start_ = fbb_.StartTable();
  }
  CellBuilder &operator=(const CellBuilder &);
  flatbuffers::Offset<Cell> Finish() {
    const auto end = fbb_.EndTable(start_);
    auto o = flatbuffers::Offset<Cell>(end);
    return o;
  }
};

inline flatbuffers::Offset<Cell> CreateCell(
    flatbuffers::FlatBufferBuilder &_fbb,
    flatbuffers::Offset<flatbuffers::String> name = 0,
    flatbuffers::Offset<CellMap> cellMap = 0,
    int16_t indexInCellMap = 0,
    int16_t x = 0,
    int16_t y = 0,
    int16_t width = 0,
    int16_t height = 0,
    float pivot_x = 0.0f,
    float pivot_y = 0.0f,
    float u1 = 0.0f,
    float v1 = 0.0f,
    float u2 = 0.0f,
    float v2 = 0.0f) {
  CellBuilder builder_(_fbb);
  builder_.add_v2(v2);
  builder_.add_u2(u2);
  builder_.add_v1(v1);
  builder_.add_u1(u1);
  builder_.add_pivot_y(pivot_y);
  builder_.add_pivot_x(pivot_x);
  builder_.add_cellMap(cellMap);
  builder_.add_name(name);
  builder_.add_height(height);
  builder_.add_width(width);
  builder_.add_y(y);
  builder_.add_x(x);
  builder_.add_indexInCellMap(indexInCellMap);
  return builder_.Finish();
}

inline flatbuffers::Offset<Cell> CreateCellDirect(
    flatbuffers::FlatBufferBuilder &_fbb,
    const char *name = nullptr,
    flatbuffers::Offset<CellMap> cellMap = 0,
    int16_t indexInCellMap = 0,
    int16_t x = 0,
    int16_t y = 0,
    int16_t width = 0,
    int16_t height = 0,
    float pivot_x = 0.0f,
    float pivot_y = 0.0f,
    float u1 = 0.0f,
    float v1 = 0.0f,
    float u2 = 0.0f,
    float v2 = 0.0f) {
  return ss::ssfb::CreateCell(
      _fbb,
      name ? _fbb.CreateString(name) : 0,
      cellMap,
      indexInCellMap,
      x,
      y,
      width,
      height,
      pivot_x,
      pivot_y,
      u1,
      v1,
      u2,
      v2);
}

flatbuffers::Offset<Cell> CreateCell(flatbuffers::FlatBufferBuilder &_fbb, const CellT *_o, const flatbuffers::rehasher_function_t *_rehasher = nullptr);

struct meshDataUVT : public flatbuffers::NativeTable {
  typedef meshDataUV TableType;
  std::vector<float> uv;
  meshDataUVT() {
  }
};

inline bool operator==(const meshDataUVT &lhs, const meshDataUVT &rhs) {
  return
      (lhs.uv == rhs.uv);
}

struct meshDataUV FLATBUFFERS_FINAL_CLASS : private flatbuffers::Table {
  typedef meshDataUVT NativeTableType;
  enum {
    VT_UV = 4
  };
  const flatbuffers::Vector<float> *uv() const {
    return GetPointer<const flatbuffers::Vector<float> *>(VT_UV);
  }
  bool Verify(flatbuffers::Verifier &verifier) const {
    return VerifyTableStart(verifier) &&
           VerifyOffset(verifier, VT_UV) &&
           verifier.VerifyVector(uv()) &&
           verifier.EndTable();
  }
  meshDataUVT *UnPack(const flatbuffers::resolver_function_t *_resolver = nullptr) const;
  void UnPackTo(meshDataUVT *_o, const flatbuffers::resolver_function_t *_resolver = nullptr) const;
  static flatbuffers::Offset<meshDataUV> Pack(flatbuffers::FlatBufferBuilder &_fbb, const meshDataUVT* _o, const flatbuffers::rehasher_function_t *_rehasher = nullptr);
};

struct meshDataUVBuilder {
  flatbuffers::FlatBufferBuilder &fbb_;
  flatbuffers::uoffset_t start_;
  void add_uv(flatbuffers::Offset<flatbuffers::Vector<float>> uv) {
    fbb_.AddOffset(meshDataUV::VT_UV, uv);
  }
  explicit meshDataUVBuilder(flatbuffers::FlatBufferBuilder &_fbb)
        : fbb_(_fbb) {
    start_ = fbb_.StartTable();
  }
  meshDataUVBuilder &operator=(const meshDataUVBuilder &);
  flatbuffers::Offset<meshDataUV> Finish() {
    const auto end = fbb_.EndTable(start_);
    auto o = flatbuffers::Offset<meshDataUV>(end);
    return o;
  }
};

inline flatbuffers::Offset<meshDataUV> CreatemeshDataUV(
    flatbuffers::FlatBufferBuilder &_fbb,
    flatbuffers::Offset<flatbuffers::Vector<float>> uv = 0) {
  meshDataUVBuilder builder_(_fbb);
  builder_.add_uv(uv);
  return builder_.Finish();
}

inline flatbuffers::Offset<meshDataUV> CreatemeshDataUVDirect(
    flatbuffers::FlatBufferBuilder &_fbb,
    const std::vector<float> *uv = nullptr) {
  return ss::ssfb::CreatemeshDataUV(
      _fbb,
      uv ? _fbb.CreateVector<float>(*uv) : 0);
}

flatbuffers::Offset<meshDataUV> CreatemeshDataUV(flatbuffers::FlatBufferBuilder &_fbb, const meshDataUVT *_o, const flatbuffers::rehasher_function_t *_rehasher = nullptr);

struct meshDataIndicesT : public flatbuffers::NativeTable {
  typedef meshDataIndices TableType;
  std::vector<float> indices;
  meshDataIndicesT() {
  }
};

inline bool operator==(const meshDataIndicesT &lhs, const meshDataIndicesT &rhs) {
  return
      (lhs.indices == rhs.indices);
}

struct meshDataIndices FLATBUFFERS_FINAL_CLASS : private flatbuffers::Table {
  typedef meshDataIndicesT NativeTableType;
  enum {
    VT_INDICES = 4
  };
  const flatbuffers::Vector<float> *indices() const {
    return GetPointer<const flatbuffers::Vector<float> *>(VT_INDICES);
  }
  bool Verify(flatbuffers::Verifier &verifier) const {
    return VerifyTableStart(verifier) &&
           VerifyOffset(verifier, VT_INDICES) &&
           verifier.VerifyVector(indices()) &&
           verifier.EndTable();
  }
  meshDataIndicesT *UnPack(const flatbuffers::resolver_function_t *_resolver = nullptr) const;
  void UnPackTo(meshDataIndicesT *_o, const flatbuffers::resolver_function_t *_resolver = nullptr) const;
  static flatbuffers::Offset<meshDataIndices> Pack(flatbuffers::FlatBufferBuilder &_fbb, const meshDataIndicesT* _o, const flatbuffers::rehasher_function_t *_rehasher = nullptr);
};

struct meshDataIndicesBuilder {
  flatbuffers::FlatBufferBuilder &fbb_;
  flatbuffers::uoffset_t start_;
  void add_indices(flatbuffers::Offset<flatbuffers::Vector<float>> indices) {
    fbb_.AddOffset(meshDataIndices::VT_INDICES, indices);
  }
  explicit meshDataIndicesBuilder(flatbuffers::FlatBufferBuilder &_fbb)
        : fbb_(_fbb) {
    start_ = fbb_.StartTable();
  }
  meshDataIndicesBuilder &operator=(const meshDataIndicesBuilder &);
  flatbuffers::Offset<meshDataIndices> Finish() {
    const auto end = fbb_.EndTable(start_);
    auto o = flatbuffers::Offset<meshDataIndices>(end);
    return o;
  }
};

inline flatbuffers::Offset<meshDataIndices> CreatemeshDataIndices(
    flatbuffers::FlatBufferBuilder &_fbb,
    flatbuffers::Offset<flatbuffers::Vector<float>> indices = 0) {
  meshDataIndicesBuilder builder_(_fbb);
  builder_.add_indices(indices);
  return builder_.Finish();
}

inline flatbuffers::Offset<meshDataIndices> CreatemeshDataIndicesDirect(
    flatbuffers::FlatBufferBuilder &_fbb,
    const std::vector<float> *indices = nullptr) {
  return ss::ssfb::CreatemeshDataIndices(
      _fbb,
      indices ? _fbb.CreateVector<float>(*indices) : 0);
}

flatbuffers::Offset<meshDataIndices> CreatemeshDataIndices(flatbuffers::FlatBufferBuilder &_fbb, const meshDataIndicesT *_o, const flatbuffers::rehasher_function_t *_rehasher = nullptr);

struct partStateT : public flatbuffers::NativeTable {
  typedef partState TableType;
  int16_t index;
  uint32_t flag1;
  uint32_t flag2;
  std::vector<uint32_t> data;
  partStateT()
      : index(0),
        flag1(0),
        flag2(0) {
  }
};

inline bool operator==(const partStateT &lhs, const partStateT &rhs) {
  return
      (lhs.index == rhs.index) &&
      (lhs.flag1 == rhs.flag1) &&
      (lhs.flag2 == rhs.flag2) &&
      (lhs.data == rhs.data);
}

struct partState FLATBUFFERS_FINAL_CLASS : private flatbuffers::Table {
  typedef partStateT NativeTableType;
  enum {
    VT_INDEX = 4,
    VT_FLAG1 = 6,
    VT_FLAG2 = 8,
    VT_DATA = 10
  };
  int16_t index() const {
    return GetField<int16_t>(VT_INDEX, 0);
  }
  uint32_t flag1() const {
    return GetField<uint32_t>(VT_FLAG1, 0);
  }
  uint32_t flag2() const {
    return GetField<uint32_t>(VT_FLAG2, 0);
  }
  const flatbuffers::Vector<uint32_t> *data() const {
    return GetPointer<const flatbuffers::Vector<uint32_t> *>(VT_DATA);
  }
  bool Verify(flatbuffers::Verifier &verifier) const {
    return VerifyTableStart(verifier) &&
           VerifyField<int16_t>(verifier, VT_INDEX) &&
           VerifyField<uint32_t>(verifier, VT_FLAG1) &&
           VerifyField<uint32_t>(verifier, VT_FLAG2) &&
           VerifyOffset(verifier, VT_DATA) &&
           verifier.VerifyVector(data()) &&
           verifier.EndTable();
  }
  partStateT *UnPack(const flatbuffers::resolver_function_t *_resolver = nullptr) const;
  void UnPackTo(partStateT *_o, const flatbuffers::resolver_function_t *_resolver = nullptr) const;
  static flatbuffers::Offset<partState> Pack(flatbuffers::FlatBufferBuilder &_fbb, const partStateT* _o, const flatbuffers::rehasher_function_t *_rehasher = nullptr);
};

struct partStateBuilder {
  flatbuffers::FlatBufferBuilder &fbb_;
  flatbuffers::uoffset_t start_;
  void add_index(int16_t index) {
    fbb_.AddElement<int16_t>(partState::VT_INDEX, index, 0);
  }
  void add_flag1(uint32_t flag1) {
    fbb_.AddElement<uint32_t>(partState::VT_FLAG1, flag1, 0);
  }
  void add_flag2(uint32_t flag2) {
    fbb_.AddElement<uint32_t>(partState::VT_FLAG2, flag2, 0);
  }
  void add_data(flatbuffers::Offset<flatbuffers::Vector<uint32_t>> data) {
    fbb_.AddOffset(partState::VT_DATA, data);
  }
  explicit partStateBuilder(flatbuffers::FlatBufferBuilder &_fbb)
        : fbb_(_fbb) {
    start_ = fbb_.StartTable();
  }
  partStateBuilder &operator=(const partStateBuilder &);
  flatbuffers::Offset<partState> Finish() {
    const auto end = fbb_.EndTable(start_);
    auto o = flatbuffers::Offset<partState>(end);
    return o;
  }
};

inline flatbuffers::Offset<partState> CreatepartState(
    flatbuffers::FlatBufferBuilder &_fbb,
    int16_t index = 0,
    uint32_t flag1 = 0,
    uint32_t flag2 = 0,
    flatbuffers::Offset<flatbuffers::Vector<uint32_t>> data = 0) {
  partStateBuilder builder_(_fbb);
  builder_.add_data(data);
  builder_.add_flag2(flag2);
  builder_.add_flag1(flag1);
  builder_.add_index(index);
  return builder_.Finish();
}

inline flatbuffers::Offset<partState> CreatepartStateDirect(
    flatbuffers::FlatBufferBuilder &_fbb,
    int16_t index = 0,
    uint32_t flag1 = 0,
    uint32_t flag2 = 0,
    const std::vector<uint32_t> *data = nullptr) {
  return ss::ssfb::CreatepartState(
      _fbb,
      index,
      flag1,
      flag2,
      data ? _fbb.CreateVector<uint32_t>(*data) : 0);
}

flatbuffers::Offset<partState> CreatepartState(flatbuffers::FlatBufferBuilder &_fbb, const partStateT *_o, const flatbuffers::rehasher_function_t *_rehasher = nullptr);

struct frameDataIndexT : public flatbuffers::NativeTable {
  typedef frameDataIndex TableType;
  std::vector<std::unique_ptr<partStateT>> states;
  frameDataIndexT() {
  }
};

inline bool operator==(const frameDataIndexT &lhs, const frameDataIndexT &rhs) {
  return
      (lhs.states == rhs.states);
}

struct frameDataIndex FLATBUFFERS_FINAL_CLASS : private flatbuffers::Table {
  typedef frameDataIndexT NativeTableType;
  enum {
    VT_STATES = 4
  };
  const flatbuffers::Vector<flatbuffers::Offset<partState>> *states() const {
    return GetPointer<const flatbuffers::Vector<flatbuffers::Offset<partState>> *>(VT_STATES);
  }
  bool Verify(flatbuffers::Verifier &verifier) const {
    return VerifyTableStart(verifier) &&
           VerifyOffset(verifier, VT_STATES) &&
           verifier.VerifyVector(states()) &&
           verifier.VerifyVectorOfTables(states()) &&
           verifier.EndTable();
  }
  frameDataIndexT *UnPack(const flatbuffers::resolver_function_t *_resolver = nullptr) const;
  void UnPackTo(frameDataIndexT *_o, const flatbuffers::resolver_function_t *_resolver = nullptr) const;
  static flatbuffers::Offset<frameDataIndex> Pack(flatbuffers::FlatBufferBuilder &_fbb, const frameDataIndexT* _o, const flatbuffers::rehasher_function_t *_rehasher = nullptr);
};

struct frameDataIndexBuilder {
  flatbuffers::FlatBufferBuilder &fbb_;
  flatbuffers::uoffset_t start_;
  void add_states(flatbuffers::Offset<flatbuffers::Vector<flatbuffers::Offset<partState>>> states) {
    fbb_.AddOffset(frameDataIndex::VT_STATES, states);
  }
  explicit frameDataIndexBuilder(flatbuffers::FlatBufferBuilder &_fbb)
        : fbb_(_fbb) {
    start_ = fbb_.StartTable();
  }
  frameDataIndexBuilder &operator=(const frameDataIndexBuilder &);
  flatbuffers::Offset<frameDataIndex> Finish() {
    const auto end = fbb_.EndTable(start_);
    auto o = flatbuffers::Offset<frameDataIndex>(end);
    return o;
  }
};

inline flatbuffers::Offset<frameDataIndex> CreateframeDataIndex(
    flatbuffers::FlatBufferBuilder &_fbb,
    flatbuffers::Offset<flatbuffers::Vector<flatbuffers::Offset<partState>>> states = 0) {
  frameDataIndexBuilder builder_(_fbb);
  builder_.add_states(states);
  return builder_.Finish();
}

inline flatbuffers::Offset<frameDataIndex> CreateframeDataIndexDirect(
    flatbuffers::FlatBufferBuilder &_fbb,
    const std::vector<flatbuffers::Offset<partState>> *states = nullptr) {
  return ss::ssfb::CreateframeDataIndex(
      _fbb,
      states ? _fbb.CreateVector<flatbuffers::Offset<partState>>(*states) : 0);
}

flatbuffers::Offset<frameDataIndex> CreateframeDataIndex(flatbuffers::FlatBufferBuilder &_fbb, const frameDataIndexT *_o, const flatbuffers::rehasher_function_t *_rehasher = nullptr);

struct userDataStringT : public flatbuffers::NativeTable {
  typedef userDataString TableType;
  int32_t length;
  std::string data;
  userDataStringT()
      : length(0) {
  }
};

inline bool operator==(const userDataStringT &lhs, const userDataStringT &rhs) {
  return
      (lhs.length == rhs.length) &&
      (lhs.data == rhs.data);
}

struct userDataString FLATBUFFERS_FINAL_CLASS : private flatbuffers::Table {
  typedef userDataStringT NativeTableType;
  enum {
    VT_LENGTH = 4,
    VT_DATA = 6
  };
  int32_t length() const {
    return GetField<int32_t>(VT_LENGTH, 0);
  }
  const flatbuffers::String *data() const {
    return GetPointer<const flatbuffers::String *>(VT_DATA);
  }
  bool Verify(flatbuffers::Verifier &verifier) const {
    return VerifyTableStart(verifier) &&
           VerifyField<int32_t>(verifier, VT_LENGTH) &&
           VerifyOffset(verifier, VT_DATA) &&
           verifier.VerifyString(data()) &&
           verifier.EndTable();
  }
  userDataStringT *UnPack(const flatbuffers::resolver_function_t *_resolver = nullptr) const;
  void UnPackTo(userDataStringT *_o, const flatbuffers::resolver_function_t *_resolver = nullptr) const;
  static flatbuffers::Offset<userDataString> Pack(flatbuffers::FlatBufferBuilder &_fbb, const userDataStringT* _o, const flatbuffers::rehasher_function_t *_rehasher = nullptr);
};

struct userDataStringBuilder {
  flatbuffers::FlatBufferBuilder &fbb_;
  flatbuffers::uoffset_t start_;
  void add_length(int32_t length) {
    fbb_.AddElement<int32_t>(userDataString::VT_LENGTH, length, 0);
  }
  void add_data(flatbuffers::Offset<flatbuffers::String> data) {
    fbb_.AddOffset(userDataString::VT_DATA, data);
  }
  explicit userDataStringBuilder(flatbuffers::FlatBufferBuilder &_fbb)
        : fbb_(_fbb) {
    start_ = fbb_.StartTable();
  }
  userDataStringBuilder &operator=(const userDataStringBuilder &);
  flatbuffers::Offset<userDataString> Finish() {
    const auto end = fbb_.EndTable(start_);
    auto o = flatbuffers::Offset<userDataString>(end);
    return o;
  }
};

inline flatbuffers::Offset<userDataString> CreateuserDataString(
    flatbuffers::FlatBufferBuilder &_fbb,
    int32_t length = 0,
    flatbuffers::Offset<flatbuffers::String> data = 0) {
  userDataStringBuilder builder_(_fbb);
  builder_.add_data(data);
  builder_.add_length(length);
  return builder_.Finish();
}

inline flatbuffers::Offset<userDataString> CreateuserDataStringDirect(
    flatbuffers::FlatBufferBuilder &_fbb,
    int32_t length = 0,
    const char *data = nullptr) {
  return ss::ssfb::CreateuserDataString(
      _fbb,
      length,
      data ? _fbb.CreateString(data) : 0);
}

flatbuffers::Offset<userDataString> CreateuserDataString(flatbuffers::FlatBufferBuilder &_fbb, const userDataStringT *_o, const flatbuffers::rehasher_function_t *_rehasher = nullptr);

struct userDataItemT : public flatbuffers::NativeTable {
  typedef userDataItem TableType;
  int16_t flags;
  int16_t arrayIndex;
  std::vector<userDataValueUnion> data;
  userDataItemT()
      : flags(0),
        arrayIndex(0) {
  }
};

inline bool operator==(const userDataItemT &lhs, const userDataItemT &rhs) {
  return
      (lhs.flags == rhs.flags) &&
      (lhs.arrayIndex == rhs.arrayIndex) &&
      (lhs.data == rhs.data);
}

struct userDataItem FLATBUFFERS_FINAL_CLASS : private flatbuffers::Table {
  typedef userDataItemT NativeTableType;
  enum {
    VT_FLAGS = 4,
    VT_ARRAYINDEX = 6,
    VT_DATA_TYPE = 8,
    VT_DATA = 10
  };
  int16_t flags() const {
    return GetField<int16_t>(VT_FLAGS, 0);
  }
  int16_t arrayIndex() const {
    return GetField<int16_t>(VT_ARRAYINDEX, 0);
  }
  const flatbuffers::Vector<uint8_t> *data_type() const {
    return GetPointer<const flatbuffers::Vector<uint8_t> *>(VT_DATA_TYPE);
  }
  const flatbuffers::Vector<flatbuffers::Offset<void>> *data() const {
    return GetPointer<const flatbuffers::Vector<flatbuffers::Offset<void>> *>(VT_DATA);
  }
  bool Verify(flatbuffers::Verifier &verifier) const {
    return VerifyTableStart(verifier) &&
           VerifyField<int16_t>(verifier, VT_FLAGS) &&
           VerifyField<int16_t>(verifier, VT_ARRAYINDEX) &&
           VerifyOffset(verifier, VT_DATA_TYPE) &&
           verifier.VerifyVector(data_type()) &&
           VerifyOffset(verifier, VT_DATA) &&
           verifier.VerifyVector(data()) &&
           VerifyuserDataValueVector(verifier, data(), data_type()) &&
           verifier.EndTable();
  }
  userDataItemT *UnPack(const flatbuffers::resolver_function_t *_resolver = nullptr) const;
  void UnPackTo(userDataItemT *_o, const flatbuffers::resolver_function_t *_resolver = nullptr) const;
  static flatbuffers::Offset<userDataItem> Pack(flatbuffers::FlatBufferBuilder &_fbb, const userDataItemT* _o, const flatbuffers::rehasher_function_t *_rehasher = nullptr);
};

struct userDataItemBuilder {
  flatbuffers::FlatBufferBuilder &fbb_;
  flatbuffers::uoffset_t start_;
  void add_flags(int16_t flags) {
    fbb_.AddElement<int16_t>(userDataItem::VT_FLAGS, flags, 0);
  }
  void add_arrayIndex(int16_t arrayIndex) {
    fbb_.AddElement<int16_t>(userDataItem::VT_ARRAYINDEX, arrayIndex, 0);
  }
  void add_data_type(flatbuffers::Offset<flatbuffers::Vector<uint8_t>> data_type) {
    fbb_.AddOffset(userDataItem::VT_DATA_TYPE, data_type);
  }
  void add_data(flatbuffers::Offset<flatbuffers::Vector<flatbuffers::Offset<void>>> data) {
    fbb_.AddOffset(userDataItem::VT_DATA, data);
  }
  explicit userDataItemBuilder(flatbuffers::FlatBufferBuilder &_fbb)
        : fbb_(_fbb) {
    start_ = fbb_.StartTable();
  }
  userDataItemBuilder &operator=(const userDataItemBuilder &);
  flatbuffers::Offset<userDataItem> Finish() {
    const auto end = fbb_.EndTable(start_);
    auto o = flatbuffers::Offset<userDataItem>(end);
    return o;
  }
};

inline flatbuffers::Offset<userDataItem> CreateuserDataItem(
    flatbuffers::FlatBufferBuilder &_fbb,
    int16_t flags = 0,
    int16_t arrayIndex = 0,
    flatbuffers::Offset<flatbuffers::Vector<uint8_t>> data_type = 0,
    flatbuffers::Offset<flatbuffers::Vector<flatbuffers::Offset<void>>> data = 0) {
  userDataItemBuilder builder_(_fbb);
  builder_.add_data(data);
  builder_.add_data_type(data_type);
  builder_.add_arrayIndex(arrayIndex);
  builder_.add_flags(flags);
  return builder_.Finish();
}

inline flatbuffers::Offset<userDataItem> CreateuserDataItemDirect(
    flatbuffers::FlatBufferBuilder &_fbb,
    int16_t flags = 0,
    int16_t arrayIndex = 0,
    const std::vector<uint8_t> *data_type = nullptr,
    const std::vector<flatbuffers::Offset<void>> *data = nullptr) {
  return ss::ssfb::CreateuserDataItem(
      _fbb,
      flags,
      arrayIndex,
      data_type ? _fbb.CreateVector<uint8_t>(*data_type) : 0,
      data ? _fbb.CreateVector<flatbuffers::Offset<void>>(*data) : 0);
}

flatbuffers::Offset<userDataItem> CreateuserDataItem(flatbuffers::FlatBufferBuilder &_fbb, const userDataItemT *_o, const flatbuffers::rehasher_function_t *_rehasher = nullptr);

struct userDataPerFrameT : public flatbuffers::NativeTable {
  typedef userDataPerFrame TableType;
  int16_t frameIndex;
  std::vector<std::unique_ptr<userDataItemT>> data;
  userDataPerFrameT()
      : frameIndex(0) {
  }
};

inline bool operator==(const userDataPerFrameT &lhs, const userDataPerFrameT &rhs) {
  return
      (lhs.frameIndex == rhs.frameIndex) &&
      (lhs.data == rhs.data);
}

struct userDataPerFrame FLATBUFFERS_FINAL_CLASS : private flatbuffers::Table {
  typedef userDataPerFrameT NativeTableType;
  enum {
    VT_FRAMEINDEX = 4,
    VT_DATA = 6
  };
  int16_t frameIndex() const {
    return GetField<int16_t>(VT_FRAMEINDEX, 0);
  }
  const flatbuffers::Vector<flatbuffers::Offset<userDataItem>> *data() const {
    return GetPointer<const flatbuffers::Vector<flatbuffers::Offset<userDataItem>> *>(VT_DATA);
  }
  bool Verify(flatbuffers::Verifier &verifier) const {
    return VerifyTableStart(verifier) &&
           VerifyField<int16_t>(verifier, VT_FRAMEINDEX) &&
           VerifyOffset(verifier, VT_DATA) &&
           verifier.VerifyVector(data()) &&
           verifier.VerifyVectorOfTables(data()) &&
           verifier.EndTable();
  }
  userDataPerFrameT *UnPack(const flatbuffers::resolver_function_t *_resolver = nullptr) const;
  void UnPackTo(userDataPerFrameT *_o, const flatbuffers::resolver_function_t *_resolver = nullptr) const;
  static flatbuffers::Offset<userDataPerFrame> Pack(flatbuffers::FlatBufferBuilder &_fbb, const userDataPerFrameT* _o, const flatbuffers::rehasher_function_t *_rehasher = nullptr);
};

struct userDataPerFrameBuilder {
  flatbuffers::FlatBufferBuilder &fbb_;
  flatbuffers::uoffset_t start_;
  void add_frameIndex(int16_t frameIndex) {
    fbb_.AddElement<int16_t>(userDataPerFrame::VT_FRAMEINDEX, frameIndex, 0);
  }
  void add_data(flatbuffers::Offset<flatbuffers::Vector<flatbuffers::Offset<userDataItem>>> data) {
    fbb_.AddOffset(userDataPerFrame::VT_DATA, data);
  }
  explicit userDataPerFrameBuilder(flatbuffers::FlatBufferBuilder &_fbb)
        : fbb_(_fbb) {
    start_ = fbb_.StartTable();
  }
  userDataPerFrameBuilder &operator=(const userDataPerFrameBuilder &);
  flatbuffers::Offset<userDataPerFrame> Finish() {
    const auto end = fbb_.EndTable(start_);
    auto o = flatbuffers::Offset<userDataPerFrame>(end);
    return o;
  }
};

inline flatbuffers::Offset<userDataPerFrame> CreateuserDataPerFrame(
    flatbuffers::FlatBufferBuilder &_fbb,
    int16_t frameIndex = 0,
    flatbuffers::Offset<flatbuffers::Vector<flatbuffers::Offset<userDataItem>>> data = 0) {
  userDataPerFrameBuilder builder_(_fbb);
  builder_.add_data(data);
  builder_.add_frameIndex(frameIndex);
  return builder_.Finish();
}

inline flatbuffers::Offset<userDataPerFrame> CreateuserDataPerFrameDirect(
    flatbuffers::FlatBufferBuilder &_fbb,
    int16_t frameIndex = 0,
    const std::vector<flatbuffers::Offset<userDataItem>> *data = nullptr) {
  return ss::ssfb::CreateuserDataPerFrame(
      _fbb,
      frameIndex,
      data ? _fbb.CreateVector<flatbuffers::Offset<userDataItem>>(*data) : 0);
}

flatbuffers::Offset<userDataPerFrame> CreateuserDataPerFrame(flatbuffers::FlatBufferBuilder &_fbb, const userDataPerFrameT *_o, const flatbuffers::rehasher_function_t *_rehasher = nullptr);

struct labelDataItemT : public flatbuffers::NativeTable {
  typedef labelDataItem TableType;
  std::string label;
  int16_t frameIndex;
  labelDataItemT()
      : frameIndex(0) {
  }
};

inline bool operator==(const labelDataItemT &lhs, const labelDataItemT &rhs) {
  return
      (lhs.label == rhs.label) &&
      (lhs.frameIndex == rhs.frameIndex);
}

struct labelDataItem FLATBUFFERS_FINAL_CLASS : private flatbuffers::Table {
  typedef labelDataItemT NativeTableType;
  enum {
    VT_LABEL = 4,
    VT_FRAMEINDEX = 6
  };
  const flatbuffers::String *label() const {
    return GetPointer<const flatbuffers::String *>(VT_LABEL);
  }
  int16_t frameIndex() const {
    return GetField<int16_t>(VT_FRAMEINDEX, 0);
  }
  bool Verify(flatbuffers::Verifier &verifier) const {
    return VerifyTableStart(verifier) &&
           VerifyOffset(verifier, VT_LABEL) &&
           verifier.VerifyString(label()) &&
           VerifyField<int16_t>(verifier, VT_FRAMEINDEX) &&
           verifier.EndTable();
  }
  labelDataItemT *UnPack(const flatbuffers::resolver_function_t *_resolver = nullptr) const;
  void UnPackTo(labelDataItemT *_o, const flatbuffers::resolver_function_t *_resolver = nullptr) const;
  static flatbuffers::Offset<labelDataItem> Pack(flatbuffers::FlatBufferBuilder &_fbb, const labelDataItemT* _o, const flatbuffers::rehasher_function_t *_rehasher = nullptr);
};

struct labelDataItemBuilder {
  flatbuffers::FlatBufferBuilder &fbb_;
  flatbuffers::uoffset_t start_;
  void add_label(flatbuffers::Offset<flatbuffers::String> label) {
    fbb_.AddOffset(labelDataItem::VT_LABEL, label);
  }
  void add_frameIndex(int16_t frameIndex) {
    fbb_.AddElement<int16_t>(labelDataItem::VT_FRAMEINDEX, frameIndex, 0);
  }
  explicit labelDataItemBuilder(flatbuffers::FlatBufferBuilder &_fbb)
        : fbb_(_fbb) {
    start_ = fbb_.StartTable();
  }
  labelDataItemBuilder &operator=(const labelDataItemBuilder &);
  flatbuffers::Offset<labelDataItem> Finish() {
    const auto end = fbb_.EndTable(start_);
    auto o = flatbuffers::Offset<labelDataItem>(end);
    return o;
  }
};

inline flatbuffers::Offset<labelDataItem> CreatelabelDataItem(
    flatbuffers::FlatBufferBuilder &_fbb,
    flatbuffers::Offset<flatbuffers::String> label = 0,
    int16_t frameIndex = 0) {
  labelDataItemBuilder builder_(_fbb);
  builder_.add_label(label);
  builder_.add_frameIndex(frameIndex);
  return builder_.Finish();
}

inline flatbuffers::Offset<labelDataItem> CreatelabelDataItemDirect(
    flatbuffers::FlatBufferBuilder &_fbb,
    const char *label = nullptr,
    int16_t frameIndex = 0) {
  return ss::ssfb::CreatelabelDataItem(
      _fbb,
      label ? _fbb.CreateString(label) : 0,
      frameIndex);
}

flatbuffers::Offset<labelDataItem> CreatelabelDataItem(flatbuffers::FlatBufferBuilder &_fbb, const labelDataItemT *_o, const flatbuffers::rehasher_function_t *_rehasher = nullptr);

struct AnimationDataT : public flatbuffers::NativeTable {
  typedef AnimationData TableType;
  std::string name;
  std::vector<std::unique_ptr<AnimationInitialDataT>> defaultData;
  std::vector<std::unique_ptr<frameDataIndexT>> frameData;
  std::vector<std::unique_ptr<userDataPerFrameT>> userData;
  std::vector<std::unique_ptr<labelDataItemT>> labelData;
  std::vector<std::unique_ptr<meshDataUVT>> meshsDataUV;
  std::vector<std::unique_ptr<meshDataIndicesT>> meshsDataIndices;
  int16_t startFrames;
  int16_t endFrames;
  int16_t totalFrames;
  int16_t fps;
  int16_t labelNum;
  int16_t canvasSizeW;
  int16_t canvasSizeH;
  float canvasPvotX;
  float canvasPvotY;
  AnimationDataT()
      : startFrames(0),
        endFrames(0),
        totalFrames(0),
        fps(0),
        labelNum(0),
        canvasSizeW(0),
        canvasSizeH(0),
        canvasPvotX(0.0f),
        canvasPvotY(0.0f) {
  }
};

inline bool operator==(const AnimationDataT &lhs, const AnimationDataT &rhs) {
  return
      (lhs.name == rhs.name) &&
      (lhs.defaultData == rhs.defaultData) &&
      (lhs.frameData == rhs.frameData) &&
      (lhs.userData == rhs.userData) &&
      (lhs.labelData == rhs.labelData) &&
      (lhs.meshsDataUV == rhs.meshsDataUV) &&
      (lhs.meshsDataIndices == rhs.meshsDataIndices) &&
      (lhs.startFrames == rhs.startFrames) &&
      (lhs.endFrames == rhs.endFrames) &&
      (lhs.totalFrames == rhs.totalFrames) &&
      (lhs.fps == rhs.fps) &&
      (lhs.labelNum == rhs.labelNum) &&
      (lhs.canvasSizeW == rhs.canvasSizeW) &&
      (lhs.canvasSizeH == rhs.canvasSizeH) &&
      (lhs.canvasPvotX == rhs.canvasPvotX) &&
      (lhs.canvasPvotY == rhs.canvasPvotY);
}

struct AnimationData FLATBUFFERS_FINAL_CLASS : private flatbuffers::Table {
  typedef AnimationDataT NativeTableType;
  enum {
    VT_NAME = 4,
    VT_DEFAULTDATA = 6,
    VT_FRAMEDATA = 8,
    VT_USERDATA = 10,
    VT_LABELDATA = 12,
    VT_MESHSDATAUV = 14,
    VT_MESHSDATAINDICES = 16,
    VT_STARTFRAMES = 18,
    VT_ENDFRAMES = 20,
    VT_TOTALFRAMES = 22,
    VT_FPS = 24,
    VT_LABELNUM = 26,
    VT_CANVASSIZEW = 28,
    VT_CANVASSIZEH = 30,
    VT_CANVASPVOTX = 32,
    VT_CANVASPVOTY = 34
  };
  const flatbuffers::String *name() const {
    return GetPointer<const flatbuffers::String *>(VT_NAME);
  }
  const flatbuffers::Vector<flatbuffers::Offset<AnimationInitialData>> *defaultData() const {
    return GetPointer<const flatbuffers::Vector<flatbuffers::Offset<AnimationInitialData>> *>(VT_DEFAULTDATA);
  }
  const flatbuffers::Vector<flatbuffers::Offset<frameDataIndex>> *frameData() const {
    return GetPointer<const flatbuffers::Vector<flatbuffers::Offset<frameDataIndex>> *>(VT_FRAMEDATA);
  }
  const flatbuffers::Vector<flatbuffers::Offset<userDataPerFrame>> *userData() const {
    return GetPointer<const flatbuffers::Vector<flatbuffers::Offset<userDataPerFrame>> *>(VT_USERDATA);
  }
  const flatbuffers::Vector<flatbuffers::Offset<labelDataItem>> *labelData() const {
    return GetPointer<const flatbuffers::Vector<flatbuffers::Offset<labelDataItem>> *>(VT_LABELDATA);
  }
  const flatbuffers::Vector<flatbuffers::Offset<meshDataUV>> *meshsDataUV() const {
    return GetPointer<const flatbuffers::Vector<flatbuffers::Offset<meshDataUV>> *>(VT_MESHSDATAUV);
  }
  const flatbuffers::Vector<flatbuffers::Offset<meshDataIndices>> *meshsDataIndices() const {
    return GetPointer<const flatbuffers::Vector<flatbuffers::Offset<meshDataIndices>> *>(VT_MESHSDATAINDICES);
  }
  int16_t startFrames() const {
    return GetField<int16_t>(VT_STARTFRAMES, 0);
  }
  int16_t endFrames() const {
    return GetField<int16_t>(VT_ENDFRAMES, 0);
  }
  int16_t totalFrames() const {
    return GetField<int16_t>(VT_TOTALFRAMES, 0);
  }
  int16_t fps() const {
    return GetField<int16_t>(VT_FPS, 0);
  }
  int16_t labelNum() const {
    return GetField<int16_t>(VT_LABELNUM, 0);
  }
  int16_t canvasSizeW() const {
    return GetField<int16_t>(VT_CANVASSIZEW, 0);
  }
  int16_t canvasSizeH() const {
    return GetField<int16_t>(VT_CANVASSIZEH, 0);
  }
  float canvasPvotX() const {
    return GetField<float>(VT_CANVASPVOTX, 0.0f);
  }
  float canvasPvotY() const {
    return GetField<float>(VT_CANVASPVOTY, 0.0f);
  }
  bool Verify(flatbuffers::Verifier &verifier) const {
    return VerifyTableStart(verifier) &&
           VerifyOffset(verifier, VT_NAME) &&
           verifier.VerifyString(name()) &&
           VerifyOffset(verifier, VT_DEFAULTDATA) &&
           verifier.VerifyVector(defaultData()) &&
           verifier.VerifyVectorOfTables(defaultData()) &&
           VerifyOffset(verifier, VT_FRAMEDATA) &&
           verifier.VerifyVector(frameData()) &&
           verifier.VerifyVectorOfTables(frameData()) &&
           VerifyOffset(verifier, VT_USERDATA) &&
           verifier.VerifyVector(userData()) &&
           verifier.VerifyVectorOfTables(userData()) &&
           VerifyOffset(verifier, VT_LABELDATA) &&
           verifier.VerifyVector(labelData()) &&
           verifier.VerifyVectorOfTables(labelData()) &&
           VerifyOffset(verifier, VT_MESHSDATAUV) &&
           verifier.VerifyVector(meshsDataUV()) &&
           verifier.VerifyVectorOfTables(meshsDataUV()) &&
           VerifyOffset(verifier, VT_MESHSDATAINDICES) &&
           verifier.VerifyVector(meshsDataIndices()) &&
           verifier.VerifyVectorOfTables(meshsDataIndices()) &&
           VerifyField<int16_t>(verifier, VT_STARTFRAMES) &&
           VerifyField<int16_t>(verifier, VT_ENDFRAMES) &&
           VerifyField<int16_t>(verifier, VT_TOTALFRAMES) &&
           VerifyField<int16_t>(verifier, VT_FPS) &&
           VerifyField<int16_t>(verifier, VT_LABELNUM) &&
           VerifyField<int16_t>(verifier, VT_CANVASSIZEW) &&
           VerifyField<int16_t>(verifier, VT_CANVASSIZEH) &&
           VerifyField<float>(verifier, VT_CANVASPVOTX) &&
           VerifyField<float>(verifier, VT_CANVASPVOTY) &&
           verifier.EndTable();
  }
  AnimationDataT *UnPack(const flatbuffers::resolver_function_t *_resolver = nullptr) const;
  void UnPackTo(AnimationDataT *_o, const flatbuffers::resolver_function_t *_resolver = nullptr) const;
  static flatbuffers::Offset<AnimationData> Pack(flatbuffers::FlatBufferBuilder &_fbb, const AnimationDataT* _o, const flatbuffers::rehasher_function_t *_rehasher = nullptr);
};

struct AnimationDataBuilder {
  flatbuffers::FlatBufferBuilder &fbb_;
  flatbuffers::uoffset_t start_;
  void add_name(flatbuffers::Offset<flatbuffers::String> name) {
    fbb_.AddOffset(AnimationData::VT_NAME, name);
  }
  void add_defaultData(flatbuffers::Offset<flatbuffers::Vector<flatbuffers::Offset<AnimationInitialData>>> defaultData) {
    fbb_.AddOffset(AnimationData::VT_DEFAULTDATA, defaultData);
  }
  void add_frameData(flatbuffers::Offset<flatbuffers::Vector<flatbuffers::Offset<frameDataIndex>>> frameData) {
    fbb_.AddOffset(AnimationData::VT_FRAMEDATA, frameData);
  }
  void add_userData(flatbuffers::Offset<flatbuffers::Vector<flatbuffers::Offset<userDataPerFrame>>> userData) {
    fbb_.AddOffset(AnimationData::VT_USERDATA, userData);
  }
  void add_labelData(flatbuffers::Offset<flatbuffers::Vector<flatbuffers::Offset<labelDataItem>>> labelData) {
    fbb_.AddOffset(AnimationData::VT_LABELDATA, labelData);
  }
  void add_meshsDataUV(flatbuffers::Offset<flatbuffers::Vector<flatbuffers::Offset<meshDataUV>>> meshsDataUV) {
    fbb_.AddOffset(AnimationData::VT_MESHSDATAUV, meshsDataUV);
  }
  void add_meshsDataIndices(flatbuffers::Offset<flatbuffers::Vector<flatbuffers::Offset<meshDataIndices>>> meshsDataIndices) {
    fbb_.AddOffset(AnimationData::VT_MESHSDATAINDICES, meshsDataIndices);
  }
  void add_startFrames(int16_t startFrames) {
    fbb_.AddElement<int16_t>(AnimationData::VT_STARTFRAMES, startFrames, 0);
  }
  void add_endFrames(int16_t endFrames) {
    fbb_.AddElement<int16_t>(AnimationData::VT_ENDFRAMES, endFrames, 0);
  }
  void add_totalFrames(int16_t totalFrames) {
    fbb_.AddElement<int16_t>(AnimationData::VT_TOTALFRAMES, totalFrames, 0);
  }
  void add_fps(int16_t fps) {
    fbb_.AddElement<int16_t>(AnimationData::VT_FPS, fps, 0);
  }
  void add_labelNum(int16_t labelNum) {
    fbb_.AddElement<int16_t>(AnimationData::VT_LABELNUM, labelNum, 0);
  }
  void add_canvasSizeW(int16_t canvasSizeW) {
    fbb_.AddElement<int16_t>(AnimationData::VT_CANVASSIZEW, canvasSizeW, 0);
  }
  void add_canvasSizeH(int16_t canvasSizeH) {
    fbb_.AddElement<int16_t>(AnimationData::VT_CANVASSIZEH, canvasSizeH, 0);
  }
  void add_canvasPvotX(float canvasPvotX) {
    fbb_.AddElement<float>(AnimationData::VT_CANVASPVOTX, canvasPvotX, 0.0f);
  }
  void add_canvasPvotY(float canvasPvotY) {
    fbb_.AddElement<float>(AnimationData::VT_CANVASPVOTY, canvasPvotY, 0.0f);
  }
  explicit AnimationDataBuilder(flatbuffers::FlatBufferBuilder &_fbb)
        : fbb_(_fbb) {
    start_ = fbb_.StartTable();
  }
  AnimationDataBuilder &operator=(const AnimationDataBuilder &);
  flatbuffers::Offset<AnimationData> Finish() {
    const auto end = fbb_.EndTable(start_);
    auto o = flatbuffers::Offset<AnimationData>(end);
    return o;
  }
};

inline flatbuffers::Offset<AnimationData> CreateAnimationData(
    flatbuffers::FlatBufferBuilder &_fbb,
    flatbuffers::Offset<flatbuffers::String> name = 0,
    flatbuffers::Offset<flatbuffers::Vector<flatbuffers::Offset<AnimationInitialData>>> defaultData = 0,
    flatbuffers::Offset<flatbuffers::Vector<flatbuffers::Offset<frameDataIndex>>> frameData = 0,
    flatbuffers::Offset<flatbuffers::Vector<flatbuffers::Offset<userDataPerFrame>>> userData = 0,
    flatbuffers::Offset<flatbuffers::Vector<flatbuffers::Offset<labelDataItem>>> labelData = 0,
    flatbuffers::Offset<flatbuffers::Vector<flatbuffers::Offset<meshDataUV>>> meshsDataUV = 0,
    flatbuffers::Offset<flatbuffers::Vector<flatbuffers::Offset<meshDataIndices>>> meshsDataIndices = 0,
    int16_t startFrames = 0,
    int16_t endFrames = 0,
    int16_t totalFrames = 0,
    int16_t fps = 0,
    int16_t labelNum = 0,
    int16_t canvasSizeW = 0,
    int16_t canvasSizeH = 0,
    float canvasPvotX = 0.0f,
    float canvasPvotY = 0.0f) {
  AnimationDataBuilder builder_(_fbb);
  builder_.add_canvasPvotY(canvasPvotY);
  builder_.add_canvasPvotX(canvasPvotX);
  builder_.add_meshsDataIndices(meshsDataIndices);
  builder_.add_meshsDataUV(meshsDataUV);
  builder_.add_labelData(labelData);
  builder_.add_userData(userData);
  builder_.add_frameData(frameData);
  builder_.add_defaultData(defaultData);
  builder_.add_name(name);
  builder_.add_canvasSizeH(canvasSizeH);
  builder_.add_canvasSizeW(canvasSizeW);
  builder_.add_labelNum(labelNum);
  builder_.add_fps(fps);
  builder_.add_totalFrames(totalFrames);
  builder_.add_endFrames(endFrames);
  builder_.add_startFrames(startFrames);
  return builder_.Finish();
}

inline flatbuffers::Offset<AnimationData> CreateAnimationDataDirect(
    flatbuffers::FlatBufferBuilder &_fbb,
    const char *name = nullptr,
    const std::vector<flatbuffers::Offset<AnimationInitialData>> *defaultData = nullptr,
    const std::vector<flatbuffers::Offset<frameDataIndex>> *frameData = nullptr,
    const std::vector<flatbuffers::Offset<userDataPerFrame>> *userData = nullptr,
    const std::vector<flatbuffers::Offset<labelDataItem>> *labelData = nullptr,
    const std::vector<flatbuffers::Offset<meshDataUV>> *meshsDataUV = nullptr,
    const std::vector<flatbuffers::Offset<meshDataIndices>> *meshsDataIndices = nullptr,
    int16_t startFrames = 0,
    int16_t endFrames = 0,
    int16_t totalFrames = 0,
    int16_t fps = 0,
    int16_t labelNum = 0,
    int16_t canvasSizeW = 0,
    int16_t canvasSizeH = 0,
    float canvasPvotX = 0.0f,
    float canvasPvotY = 0.0f) {
  return ss::ssfb::CreateAnimationData(
      _fbb,
      name ? _fbb.CreateString(name) : 0,
      defaultData ? _fbb.CreateVector<flatbuffers::Offset<AnimationInitialData>>(*defaultData) : 0,
      frameData ? _fbb.CreateVector<flatbuffers::Offset<frameDataIndex>>(*frameData) : 0,
      userData ? _fbb.CreateVector<flatbuffers::Offset<userDataPerFrame>>(*userData) : 0,
      labelData ? _fbb.CreateVector<flatbuffers::Offset<labelDataItem>>(*labelData) : 0,
      meshsDataUV ? _fbb.CreateVector<flatbuffers::Offset<meshDataUV>>(*meshsDataUV) : 0,
      meshsDataIndices ? _fbb.CreateVector<flatbuffers::Offset<meshDataIndices>>(*meshsDataIndices) : 0,
      startFrames,
      endFrames,
      totalFrames,
      fps,
      labelNum,
      canvasSizeW,
      canvasSizeH,
      canvasPvotX,
      canvasPvotY);
}

flatbuffers::Offset<AnimationData> CreateAnimationData(flatbuffers::FlatBufferBuilder &_fbb, const AnimationDataT *_o, const flatbuffers::rehasher_function_t *_rehasher = nullptr);

struct AnimationInitialDataT : public flatbuffers::NativeTable {
  typedef AnimationInitialData TableType;
  int16_t index;
  int32_t lowflag;
  int32_t highflag;
  int16_t priority;
  int16_t cellIndex;
  int16_t opacity;
  int16_t localopacity;
  int16_t masklimen;
  float positionX;
  float positionY;
  float positionZ;
  float pivotX;
  float pivotY;
  float rotationX;
  float rotationY;
  float rotationZ;
  float scaleX;
  float scaleY;
  float localscaleX;
  float localscaleY;
  float size_X;
  float size_Y;
  float uv_move_X;
  float uv_move_Y;
  float uv_rotation;
  float uv_scale_X;
  float uv_scale_Y;
  float boundingRadius;
  int32_t instanceValue_curKeyframe;
  int32_t instanceValue_startFrame;
  int32_t instanceValue_endFrame;
  int32_t instanceValue_loopNum;
  float instanceValue_speed;
  int32_t instanceValue_loopflag;
  int32_t effectValue_curKeyframe;
  int32_t effectValue_startTime;
  float effectValue_speed;
  int32_t effectValue_loopflag;
  AnimationInitialDataT()
      : index(0),
        lowflag(0),
        highflag(0),
        priority(0),
        cellIndex(0),
        opacity(0),
        localopacity(0),
        masklimen(0),
        positionX(0.0f),
        positionY(0.0f),
        positionZ(0.0f),
        pivotX(0.0f),
        pivotY(0.0f),
        rotationX(0.0f),
        rotationY(0.0f),
        rotationZ(0.0f),
        scaleX(0.0f),
        scaleY(0.0f),
        localscaleX(0.0f),
        localscaleY(0.0f),
        size_X(0.0f),
        size_Y(0.0f),
        uv_move_X(0.0f),
        uv_move_Y(0.0f),
        uv_rotation(0.0f),
        uv_scale_X(0.0f),
        uv_scale_Y(0.0f),
        boundingRadius(0.0f),
        instanceValue_curKeyframe(0),
        instanceValue_startFrame(0),
        instanceValue_endFrame(0),
        instanceValue_loopNum(0),
        instanceValue_speed(0.0f),
        instanceValue_loopflag(0),
        effectValue_curKeyframe(0),
        effectValue_startTime(0),
        effectValue_speed(0.0f),
        effectValue_loopflag(0) {
  }
};

inline bool operator==(const AnimationInitialDataT &lhs, const AnimationInitialDataT &rhs) {
  return
      (lhs.index == rhs.index) &&
      (lhs.lowflag == rhs.lowflag) &&
      (lhs.highflag == rhs.highflag) &&
      (lhs.priority == rhs.priority) &&
      (lhs.cellIndex == rhs.cellIndex) &&
      (lhs.opacity == rhs.opacity) &&
      (lhs.localopacity == rhs.localopacity) &&
      (lhs.masklimen == rhs.masklimen) &&
      (lhs.positionX == rhs.positionX) &&
      (lhs.positionY == rhs.positionY) &&
      (lhs.positionZ == rhs.positionZ) &&
      (lhs.pivotX == rhs.pivotX) &&
      (lhs.pivotY == rhs.pivotY) &&
      (lhs.rotationX == rhs.rotationX) &&
      (lhs.rotationY == rhs.rotationY) &&
      (lhs.rotationZ == rhs.rotationZ) &&
      (lhs.scaleX == rhs.scaleX) &&
      (lhs.scaleY == rhs.scaleY) &&
      (lhs.localscaleX == rhs.localscaleX) &&
      (lhs.localscaleY == rhs.localscaleY) &&
      (lhs.size_X == rhs.size_X) &&
      (lhs.size_Y == rhs.size_Y) &&
      (lhs.uv_move_X == rhs.uv_move_X) &&
      (lhs.uv_move_Y == rhs.uv_move_Y) &&
      (lhs.uv_rotation == rhs.uv_rotation) &&
      (lhs.uv_scale_X == rhs.uv_scale_X) &&
      (lhs.uv_scale_Y == rhs.uv_scale_Y) &&
      (lhs.boundingRadius == rhs.boundingRadius) &&
      (lhs.instanceValue_curKeyframe == rhs.instanceValue_curKeyframe) &&
      (lhs.instanceValue_startFrame == rhs.instanceValue_startFrame) &&
      (lhs.instanceValue_endFrame == rhs.instanceValue_endFrame) &&
      (lhs.instanceValue_loopNum == rhs.instanceValue_loopNum) &&
      (lhs.instanceValue_speed == rhs.instanceValue_speed) &&
      (lhs.instanceValue_loopflag == rhs.instanceValue_loopflag) &&
      (lhs.effectValue_curKeyframe == rhs.effectValue_curKeyframe) &&
      (lhs.effectValue_startTime == rhs.effectValue_startTime) &&
      (lhs.effectValue_speed == rhs.effectValue_speed) &&
      (lhs.effectValue_loopflag == rhs.effectValue_loopflag);
}

struct AnimationInitialData FLATBUFFERS_FINAL_CLASS : private flatbuffers::Table {
  typedef AnimationInitialDataT NativeTableType;
  enum {
    VT_INDEX = 4,
    VT_LOWFLAG = 6,
    VT_HIGHFLAG = 8,
    VT_PRIORITY = 10,
    VT_CELLINDEX = 12,
    VT_OPACITY = 14,
    VT_LOCALOPACITY = 16,
    VT_MASKLIMEN = 18,
    VT_POSITIONX = 20,
    VT_POSITIONY = 22,
    VT_POSITIONZ = 24,
    VT_PIVOTX = 26,
    VT_PIVOTY = 28,
    VT_ROTATIONX = 30,
    VT_ROTATIONY = 32,
    VT_ROTATIONZ = 34,
    VT_SCALEX = 36,
    VT_SCALEY = 38,
    VT_LOCALSCALEX = 40,
    VT_LOCALSCALEY = 42,
    VT_SIZE_X = 44,
    VT_SIZE_Y = 46,
    VT_UV_MOVE_X = 48,
    VT_UV_MOVE_Y = 50,
    VT_UV_ROTATION = 52,
    VT_UV_SCALE_X = 54,
    VT_UV_SCALE_Y = 56,
    VT_BOUNDINGRADIUS = 58,
    VT_INSTANCEVALUE_CURKEYFRAME = 60,
    VT_INSTANCEVALUE_STARTFRAME = 62,
    VT_INSTANCEVALUE_ENDFRAME = 64,
    VT_INSTANCEVALUE_LOOPNUM = 66,
    VT_INSTANCEVALUE_SPEED = 68,
    VT_INSTANCEVALUE_LOOPFLAG = 70,
    VT_EFFECTVALUE_CURKEYFRAME = 72,
    VT_EFFECTVALUE_STARTTIME = 74,
    VT_EFFECTVALUE_SPEED = 76,
    VT_EFFECTVALUE_LOOPFLAG = 78
  };
  int16_t index() const {
    return GetField<int16_t>(VT_INDEX, 0);
  }
  int32_t lowflag() const {
    return GetField<int32_t>(VT_LOWFLAG, 0);
  }
  int32_t highflag() const {
    return GetField<int32_t>(VT_HIGHFLAG, 0);
  }
  int16_t priority() const {
    return GetField<int16_t>(VT_PRIORITY, 0);
  }
  int16_t cellIndex() const {
    return GetField<int16_t>(VT_CELLINDEX, 0);
  }
  int16_t opacity() const {
    return GetField<int16_t>(VT_OPACITY, 0);
  }
  int16_t localopacity() const {
    return GetField<int16_t>(VT_LOCALOPACITY, 0);
  }
  int16_t masklimen() const {
    return GetField<int16_t>(VT_MASKLIMEN, 0);
  }
  float positionX() const {
    return GetField<float>(VT_POSITIONX, 0.0f);
  }
  float positionY() const {
    return GetField<float>(VT_POSITIONY, 0.0f);
  }
  float positionZ() const {
    return GetField<float>(VT_POSITIONZ, 0.0f);
  }
  float pivotX() const {
    return GetField<float>(VT_PIVOTX, 0.0f);
  }
  float pivotY() const {
    return GetField<float>(VT_PIVOTY, 0.0f);
  }
  float rotationX() const {
    return GetField<float>(VT_ROTATIONX, 0.0f);
  }
  float rotationY() const {
    return GetField<float>(VT_ROTATIONY, 0.0f);
  }
  float rotationZ() const {
    return GetField<float>(VT_ROTATIONZ, 0.0f);
  }
  float scaleX() const {
    return GetField<float>(VT_SCALEX, 0.0f);
  }
  float scaleY() const {
    return GetField<float>(VT_SCALEY, 0.0f);
  }
  float localscaleX() const {
    return GetField<float>(VT_LOCALSCALEX, 0.0f);
  }
  float localscaleY() const {
    return GetField<float>(VT_LOCALSCALEY, 0.0f);
  }
  float size_X() const {
    return GetField<float>(VT_SIZE_X, 0.0f);
  }
  float size_Y() const {
    return GetField<float>(VT_SIZE_Y, 0.0f);
  }
  float uv_move_X() const {
    return GetField<float>(VT_UV_MOVE_X, 0.0f);
  }
  float uv_move_Y() const {
    return GetField<float>(VT_UV_MOVE_Y, 0.0f);
  }
  float uv_rotation() const {
    return GetField<float>(VT_UV_ROTATION, 0.0f);
  }
  float uv_scale_X() const {
    return GetField<float>(VT_UV_SCALE_X, 0.0f);
  }
  float uv_scale_Y() const {
    return GetField<float>(VT_UV_SCALE_Y, 0.0f);
  }
  float boundingRadius() const {
    return GetField<float>(VT_BOUNDINGRADIUS, 0.0f);
  }
  int32_t instanceValue_curKeyframe() const {
    return GetField<int32_t>(VT_INSTANCEVALUE_CURKEYFRAME, 0);
  }
  int32_t instanceValue_startFrame() const {
    return GetField<int32_t>(VT_INSTANCEVALUE_STARTFRAME, 0);
  }
  int32_t instanceValue_endFrame() const {
    return GetField<int32_t>(VT_INSTANCEVALUE_ENDFRAME, 0);
  }
  int32_t instanceValue_loopNum() const {
    return GetField<int32_t>(VT_INSTANCEVALUE_LOOPNUM, 0);
  }
  float instanceValue_speed() const {
    return GetField<float>(VT_INSTANCEVALUE_SPEED, 0.0f);
  }
  int32_t instanceValue_loopflag() const {
    return GetField<int32_t>(VT_INSTANCEVALUE_LOOPFLAG, 0);
  }
  int32_t effectValue_curKeyframe() const {
    return GetField<int32_t>(VT_EFFECTVALUE_CURKEYFRAME, 0);
  }
  int32_t effectValue_startTime() const {
    return GetField<int32_t>(VT_EFFECTVALUE_STARTTIME, 0);
  }
  float effectValue_speed() const {
    return GetField<float>(VT_EFFECTVALUE_SPEED, 0.0f);
  }
  int32_t effectValue_loopflag() const {
    return GetField<int32_t>(VT_EFFECTVALUE_LOOPFLAG, 0);
  }
  bool Verify(flatbuffers::Verifier &verifier) const {
    return VerifyTableStart(verifier) &&
           VerifyField<int16_t>(verifier, VT_INDEX) &&
           VerifyField<int32_t>(verifier, VT_LOWFLAG) &&
           VerifyField<int32_t>(verifier, VT_HIGHFLAG) &&
           VerifyField<int16_t>(verifier, VT_PRIORITY) &&
           VerifyField<int16_t>(verifier, VT_CELLINDEX) &&
           VerifyField<int16_t>(verifier, VT_OPACITY) &&
           VerifyField<int16_t>(verifier, VT_LOCALOPACITY) &&
           VerifyField<int16_t>(verifier, VT_MASKLIMEN) &&
           VerifyField<float>(verifier, VT_POSITIONX) &&
           VerifyField<float>(verifier, VT_POSITIONY) &&
           VerifyField<float>(verifier, VT_POSITIONZ) &&
           VerifyField<float>(verifier, VT_PIVOTX) &&
           VerifyField<float>(verifier, VT_PIVOTY) &&
           VerifyField<float>(verifier, VT_ROTATIONX) &&
           VerifyField<float>(verifier, VT_ROTATIONY) &&
           VerifyField<float>(verifier, VT_ROTATIONZ) &&
           VerifyField<float>(verifier, VT_SCALEX) &&
           VerifyField<float>(verifier, VT_SCALEY) &&
           VerifyField<float>(verifier, VT_LOCALSCALEX) &&
           VerifyField<float>(verifier, VT_LOCALSCALEY) &&
           VerifyField<float>(verifier, VT_SIZE_X) &&
           VerifyField<float>(verifier, VT_SIZE_Y) &&
           VerifyField<float>(verifier, VT_UV_MOVE_X) &&
           VerifyField<float>(verifier, VT_UV_MOVE_Y) &&
           VerifyField<float>(verifier, VT_UV_ROTATION) &&
           VerifyField<float>(verifier, VT_UV_SCALE_X) &&
           VerifyField<float>(verifier, VT_UV_SCALE_Y) &&
           VerifyField<float>(verifier, VT_BOUNDINGRADIUS) &&
           VerifyField<int32_t>(verifier, VT_INSTANCEVALUE_CURKEYFRAME) &&
           VerifyField<int32_t>(verifier, VT_INSTANCEVALUE_STARTFRAME) &&
           VerifyField<int32_t>(verifier, VT_INSTANCEVALUE_ENDFRAME) &&
           VerifyField<int32_t>(verifier, VT_INSTANCEVALUE_LOOPNUM) &&
           VerifyField<float>(verifier, VT_INSTANCEVALUE_SPEED) &&
           VerifyField<int32_t>(verifier, VT_INSTANCEVALUE_LOOPFLAG) &&
           VerifyField<int32_t>(verifier, VT_EFFECTVALUE_CURKEYFRAME) &&
           VerifyField<int32_t>(verifier, VT_EFFECTVALUE_STARTTIME) &&
           VerifyField<float>(verifier, VT_EFFECTVALUE_SPEED) &&
           VerifyField<int32_t>(verifier, VT_EFFECTVALUE_LOOPFLAG) &&
           verifier.EndTable();
  }
  AnimationInitialDataT *UnPack(const flatbuffers::resolver_function_t *_resolver = nullptr) const;
  void UnPackTo(AnimationInitialDataT *_o, const flatbuffers::resolver_function_t *_resolver = nullptr) const;
  static flatbuffers::Offset<AnimationInitialData> Pack(flatbuffers::FlatBufferBuilder &_fbb, const AnimationInitialDataT* _o, const flatbuffers::rehasher_function_t *_rehasher = nullptr);
};

struct AnimationInitialDataBuilder {
  flatbuffers::FlatBufferBuilder &fbb_;
  flatbuffers::uoffset_t start_;
  void add_index(int16_t index) {
    fbb_.AddElement<int16_t>(AnimationInitialData::VT_INDEX, index, 0);
  }
  void add_lowflag(int32_t lowflag) {
    fbb_.AddElement<int32_t>(AnimationInitialData::VT_LOWFLAG, lowflag, 0);
  }
  void add_highflag(int32_t highflag) {
    fbb_.AddElement<int32_t>(AnimationInitialData::VT_HIGHFLAG, highflag, 0);
  }
  void add_priority(int16_t priority) {
    fbb_.AddElement<int16_t>(AnimationInitialData::VT_PRIORITY, priority, 0);
  }
  void add_cellIndex(int16_t cellIndex) {
    fbb_.AddElement<int16_t>(AnimationInitialData::VT_CELLINDEX, cellIndex, 0);
  }
  void add_opacity(int16_t opacity) {
    fbb_.AddElement<int16_t>(AnimationInitialData::VT_OPACITY, opacity, 0);
  }
  void add_localopacity(int16_t localopacity) {
    fbb_.AddElement<int16_t>(AnimationInitialData::VT_LOCALOPACITY, localopacity, 0);
  }
  void add_masklimen(int16_t masklimen) {
    fbb_.AddElement<int16_t>(AnimationInitialData::VT_MASKLIMEN, masklimen, 0);
  }
  void add_positionX(float positionX) {
    fbb_.AddElement<float>(AnimationInitialData::VT_POSITIONX, positionX, 0.0f);
  }
  void add_positionY(float positionY) {
    fbb_.AddElement<float>(AnimationInitialData::VT_POSITIONY, positionY, 0.0f);
  }
  void add_positionZ(float positionZ) {
    fbb_.AddElement<float>(AnimationInitialData::VT_POSITIONZ, positionZ, 0.0f);
  }
  void add_pivotX(float pivotX) {
    fbb_.AddElement<float>(AnimationInitialData::VT_PIVOTX, pivotX, 0.0f);
  }
  void add_pivotY(float pivotY) {
    fbb_.AddElement<float>(AnimationInitialData::VT_PIVOTY, pivotY, 0.0f);
  }
  void add_rotationX(float rotationX) {
    fbb_.AddElement<float>(AnimationInitialData::VT_ROTATIONX, rotationX, 0.0f);
  }
  void add_rotationY(float rotationY) {
    fbb_.AddElement<float>(AnimationInitialData::VT_ROTATIONY, rotationY, 0.0f);
  }
  void add_rotationZ(float rotationZ) {
    fbb_.AddElement<float>(AnimationInitialData::VT_ROTATIONZ, rotationZ, 0.0f);
  }
  void add_scaleX(float scaleX) {
    fbb_.AddElement<float>(AnimationInitialData::VT_SCALEX, scaleX, 0.0f);
  }
  void add_scaleY(float scaleY) {
    fbb_.AddElement<float>(AnimationInitialData::VT_SCALEY, scaleY, 0.0f);
  }
  void add_localscaleX(float localscaleX) {
    fbb_.AddElement<float>(AnimationInitialData::VT_LOCALSCALEX, localscaleX, 0.0f);
  }
  void add_localscaleY(float localscaleY) {
    fbb_.AddElement<float>(AnimationInitialData::VT_LOCALSCALEY, localscaleY, 0.0f);
  }
  void add_size_X(float size_X) {
    fbb_.AddElement<float>(AnimationInitialData::VT_SIZE_X, size_X, 0.0f);
  }
  void add_size_Y(float size_Y) {
    fbb_.AddElement<float>(AnimationInitialData::VT_SIZE_Y, size_Y, 0.0f);
  }
  void add_uv_move_X(float uv_move_X) {
    fbb_.AddElement<float>(AnimationInitialData::VT_UV_MOVE_X, uv_move_X, 0.0f);
  }
  void add_uv_move_Y(float uv_move_Y) {
    fbb_.AddElement<float>(AnimationInitialData::VT_UV_MOVE_Y, uv_move_Y, 0.0f);
  }
  void add_uv_rotation(float uv_rotation) {
    fbb_.AddElement<float>(AnimationInitialData::VT_UV_ROTATION, uv_rotation, 0.0f);
  }
  void add_uv_scale_X(float uv_scale_X) {
    fbb_.AddElement<float>(AnimationInitialData::VT_UV_SCALE_X, uv_scale_X, 0.0f);
  }
  void add_uv_scale_Y(float uv_scale_Y) {
    fbb_.AddElement<float>(AnimationInitialData::VT_UV_SCALE_Y, uv_scale_Y, 0.0f);
  }
  void add_boundingRadius(float boundingRadius) {
    fbb_.AddElement<float>(AnimationInitialData::VT_BOUNDINGRADIUS, boundingRadius, 0.0f);
  }
  void add_instanceValue_curKeyframe(int32_t instanceValue_curKeyframe) {
    fbb_.AddElement<int32_t>(AnimationInitialData::VT_INSTANCEVALUE_CURKEYFRAME, instanceValue_curKeyframe, 0);
  }
  void add_instanceValue_startFrame(int32_t instanceValue_startFrame) {
    fbb_.AddElement<int32_t>(AnimationInitialData::VT_INSTANCEVALUE_STARTFRAME, instanceValue_startFrame, 0);
  }
  void add_instanceValue_endFrame(int32_t instanceValue_endFrame) {
    fbb_.AddElement<int32_t>(AnimationInitialData::VT_INSTANCEVALUE_ENDFRAME, instanceValue_endFrame, 0);
  }
  void add_instanceValue_loopNum(int32_t instanceValue_loopNum) {
    fbb_.AddElement<int32_t>(AnimationInitialData::VT_INSTANCEVALUE_LOOPNUM, instanceValue_loopNum, 0);
  }
  void add_instanceValue_speed(float instanceValue_speed) {
    fbb_.AddElement<float>(AnimationInitialData::VT_INSTANCEVALUE_SPEED, instanceValue_speed, 0.0f);
  }
  void add_instanceValue_loopflag(int32_t instanceValue_loopflag) {
    fbb_.AddElement<int32_t>(AnimationInitialData::VT_INSTANCEVALUE_LOOPFLAG, instanceValue_loopflag, 0);
  }
  void add_effectValue_curKeyframe(int32_t effectValue_curKeyframe) {
    fbb_.AddElement<int32_t>(AnimationInitialData::VT_EFFECTVALUE_CURKEYFRAME, effectValue_curKeyframe, 0);
  }
  void add_effectValue_startTime(int32_t effectValue_startTime) {
    fbb_.AddElement<int32_t>(AnimationInitialData::VT_EFFECTVALUE_STARTTIME, effectValue_startTime, 0);
  }
  void add_effectValue_speed(float effectValue_speed) {
    fbb_.AddElement<float>(AnimationInitialData::VT_EFFECTVALUE_SPEED, effectValue_speed, 0.0f);
  }
  void add_effectValue_loopflag(int32_t effectValue_loopflag) {
    fbb_.AddElement<int32_t>(AnimationInitialData::VT_EFFECTVALUE_LOOPFLAG, effectValue_loopflag, 0);
  }
  explicit AnimationInitialDataBuilder(flatbuffers::FlatBufferBuilder &_fbb)
        : fbb_(_fbb) {
    start_ = fbb_.StartTable();
  }
  AnimationInitialDataBuilder &operator=(const AnimationInitialDataBuilder &);
  flatbuffers::Offset<AnimationInitialData> Finish() {
    const auto end = fbb_.EndTable(start_);
    auto o = flatbuffers::Offset<AnimationInitialData>(end);
    return o;
  }
};

inline flatbuffers::Offset<AnimationInitialData> CreateAnimationInitialData(
    flatbuffers::FlatBufferBuilder &_fbb,
    int16_t index = 0,
    int32_t lowflag = 0,
    int32_t highflag = 0,
    int16_t priority = 0,
    int16_t cellIndex = 0,
    int16_t opacity = 0,
    int16_t localopacity = 0,
    int16_t masklimen = 0,
    float positionX = 0.0f,
    float positionY = 0.0f,
    float positionZ = 0.0f,
    float pivotX = 0.0f,
    float pivotY = 0.0f,
    float rotationX = 0.0f,
    float rotationY = 0.0f,
    float rotationZ = 0.0f,
    float scaleX = 0.0f,
    float scaleY = 0.0f,
    float localscaleX = 0.0f,
    float localscaleY = 0.0f,
    float size_X = 0.0f,
    float size_Y = 0.0f,
    float uv_move_X = 0.0f,
    float uv_move_Y = 0.0f,
    float uv_rotation = 0.0f,
    float uv_scale_X = 0.0f,
    float uv_scale_Y = 0.0f,
    float boundingRadius = 0.0f,
    int32_t instanceValue_curKeyframe = 0,
    int32_t instanceValue_startFrame = 0,
    int32_t instanceValue_endFrame = 0,
    int32_t instanceValue_loopNum = 0,
    float instanceValue_speed = 0.0f,
    int32_t instanceValue_loopflag = 0,
    int32_t effectValue_curKeyframe = 0,
    int32_t effectValue_startTime = 0,
    float effectValue_speed = 0.0f,
    int32_t effectValue_loopflag = 0) {
  AnimationInitialDataBuilder builder_(_fbb);
  builder_.add_effectValue_loopflag(effectValue_loopflag);
  builder_.add_effectValue_speed(effectValue_speed);
  builder_.add_effectValue_startTime(effectValue_startTime);
  builder_.add_effectValue_curKeyframe(effectValue_curKeyframe);
  builder_.add_instanceValue_loopflag(instanceValue_loopflag);
  builder_.add_instanceValue_speed(instanceValue_speed);
  builder_.add_instanceValue_loopNum(instanceValue_loopNum);
  builder_.add_instanceValue_endFrame(instanceValue_endFrame);
  builder_.add_instanceValue_startFrame(instanceValue_startFrame);
  builder_.add_instanceValue_curKeyframe(instanceValue_curKeyframe);
  builder_.add_boundingRadius(boundingRadius);
  builder_.add_uv_scale_Y(uv_scale_Y);
  builder_.add_uv_scale_X(uv_scale_X);
  builder_.add_uv_rotation(uv_rotation);
  builder_.add_uv_move_Y(uv_move_Y);
  builder_.add_uv_move_X(uv_move_X);
  builder_.add_size_Y(size_Y);
  builder_.add_size_X(size_X);
  builder_.add_localscaleY(localscaleY);
  builder_.add_localscaleX(localscaleX);
  builder_.add_scaleY(scaleY);
  builder_.add_scaleX(scaleX);
  builder_.add_rotationZ(rotationZ);
  builder_.add_rotationY(rotationY);
  builder_.add_rotationX(rotationX);
  builder_.add_pivotY(pivotY);
  builder_.add_pivotX(pivotX);
  builder_.add_positionZ(positionZ);
  builder_.add_positionY(positionY);
  builder_.add_positionX(positionX);
  builder_.add_highflag(highflag);
  builder_.add_lowflag(lowflag);
  builder_.add_masklimen(masklimen);
  builder_.add_localopacity(localopacity);
  builder_.add_opacity(opacity);
  builder_.add_cellIndex(cellIndex);
  builder_.add_priority(priority);
  builder_.add_index(index);
  return builder_.Finish();
}

flatbuffers::Offset<AnimationInitialData> CreateAnimationInitialData(flatbuffers::FlatBufferBuilder &_fbb, const AnimationInitialDataT *_o, const flatbuffers::rehasher_function_t *_rehasher = nullptr);

struct PartDataT : public flatbuffers::NativeTable {
  typedef PartData TableType;
  std::string name;
  int16_t index;
  int16_t parentIndex;
  SsPartType type;
  int16_t boundsType;
  int16_t alphaBlendType;
  std::string refname;
  std::string effectfilename;
  std::string colorLabel;
  int16_t maskInfluence;
  PartDataT()
      : index(0),
        parentIndex(0),
        type(SsPartType_Nulltype),
        boundsType(0),
        alphaBlendType(0),
        maskInfluence(0) {
  }
};

inline bool operator==(const PartDataT &lhs, const PartDataT &rhs) {
  return
      (lhs.name == rhs.name) &&
      (lhs.index == rhs.index) &&
      (lhs.parentIndex == rhs.parentIndex) &&
      (lhs.type == rhs.type) &&
      (lhs.boundsType == rhs.boundsType) &&
      (lhs.alphaBlendType == rhs.alphaBlendType) &&
      (lhs.refname == rhs.refname) &&
      (lhs.effectfilename == rhs.effectfilename) &&
      (lhs.colorLabel == rhs.colorLabel) &&
      (lhs.maskInfluence == rhs.maskInfluence);
}

struct PartData FLATBUFFERS_FINAL_CLASS : private flatbuffers::Table {
  typedef PartDataT NativeTableType;
  enum {
    VT_NAME = 4,
    VT_INDEX = 6,
    VT_PARENTINDEX = 8,
    VT_TYPE = 10,
    VT_BOUNDSTYPE = 12,
    VT_ALPHABLENDTYPE = 14,
    VT_REFNAME = 16,
    VT_EFFECTFILENAME = 18,
    VT_COLORLABEL = 20,
    VT_MASKINFLUENCE = 22
  };
  const flatbuffers::String *name() const {
    return GetPointer<const flatbuffers::String *>(VT_NAME);
  }
  int16_t index() const {
    return GetField<int16_t>(VT_INDEX, 0);
  }
  int16_t parentIndex() const {
    return GetField<int16_t>(VT_PARENTINDEX, 0);
  }
  SsPartType type() const {
    return static_cast<SsPartType>(GetField<int8_t>(VT_TYPE, 0));
  }
  int16_t boundsType() const {
    return GetField<int16_t>(VT_BOUNDSTYPE, 0);
  }
  int16_t alphaBlendType() const {
    return GetField<int16_t>(VT_ALPHABLENDTYPE, 0);
  }
  const flatbuffers::String *refname() const {
    return GetPointer<const flatbuffers::String *>(VT_REFNAME);
  }
  const flatbuffers::String *effectfilename() const {
    return GetPointer<const flatbuffers::String *>(VT_EFFECTFILENAME);
  }
  const flatbuffers::String *colorLabel() const {
    return GetPointer<const flatbuffers::String *>(VT_COLORLABEL);
  }
  int16_t maskInfluence() const {
    return GetField<int16_t>(VT_MASKINFLUENCE, 0);
  }
  bool Verify(flatbuffers::Verifier &verifier) const {
    return VerifyTableStart(verifier) &&
           VerifyOffset(verifier, VT_NAME) &&
           verifier.VerifyString(name()) &&
           VerifyField<int16_t>(verifier, VT_INDEX) &&
           VerifyField<int16_t>(verifier, VT_PARENTINDEX) &&
           VerifyField<int8_t>(verifier, VT_TYPE) &&
           VerifyField<int16_t>(verifier, VT_BOUNDSTYPE) &&
           VerifyField<int16_t>(verifier, VT_ALPHABLENDTYPE) &&
           VerifyOffset(verifier, VT_REFNAME) &&
           verifier.VerifyString(refname()) &&
           VerifyOffset(verifier, VT_EFFECTFILENAME) &&
           verifier.VerifyString(effectfilename()) &&
           VerifyOffset(verifier, VT_COLORLABEL) &&
           verifier.VerifyString(colorLabel()) &&
           VerifyField<int16_t>(verifier, VT_MASKINFLUENCE) &&
           verifier.EndTable();
  }
  PartDataT *UnPack(const flatbuffers::resolver_function_t *_resolver = nullptr) const;
  void UnPackTo(PartDataT *_o, const flatbuffers::resolver_function_t *_resolver = nullptr) const;
  static flatbuffers::Offset<PartData> Pack(flatbuffers::FlatBufferBuilder &_fbb, const PartDataT* _o, const flatbuffers::rehasher_function_t *_rehasher = nullptr);
};

struct PartDataBuilder {
  flatbuffers::FlatBufferBuilder &fbb_;
  flatbuffers::uoffset_t start_;
  void add_name(flatbuffers::Offset<flatbuffers::String> name) {
    fbb_.AddOffset(PartData::VT_NAME, name);
  }
  void add_index(int16_t index) {
    fbb_.AddElement<int16_t>(PartData::VT_INDEX, index, 0);
  }
  void add_parentIndex(int16_t parentIndex) {
    fbb_.AddElement<int16_t>(PartData::VT_PARENTINDEX, parentIndex, 0);
  }
  void add_type(SsPartType type) {
    fbb_.AddElement<int8_t>(PartData::VT_TYPE, static_cast<int8_t>(type), 0);
  }
  void add_boundsType(int16_t boundsType) {
    fbb_.AddElement<int16_t>(PartData::VT_BOUNDSTYPE, boundsType, 0);
  }
  void add_alphaBlendType(int16_t alphaBlendType) {
    fbb_.AddElement<int16_t>(PartData::VT_ALPHABLENDTYPE, alphaBlendType, 0);
  }
  void add_refname(flatbuffers::Offset<flatbuffers::String> refname) {
    fbb_.AddOffset(PartData::VT_REFNAME, refname);
  }
  void add_effectfilename(flatbuffers::Offset<flatbuffers::String> effectfilename) {
    fbb_.AddOffset(PartData::VT_EFFECTFILENAME, effectfilename);
  }
  void add_colorLabel(flatbuffers::Offset<flatbuffers::String> colorLabel) {
    fbb_.AddOffset(PartData::VT_COLORLABEL, colorLabel);
  }
  void add_maskInfluence(int16_t maskInfluence) {
    fbb_.AddElement<int16_t>(PartData::VT_MASKINFLUENCE, maskInfluence, 0);
  }
  explicit PartDataBuilder(flatbuffers::FlatBufferBuilder &_fbb)
        : fbb_(_fbb) {
    start_ = fbb_.StartTable();
  }
  PartDataBuilder &operator=(const PartDataBuilder &);
  flatbuffers::Offset<PartData> Finish() {
    const auto end = fbb_.EndTable(start_);
    auto o = flatbuffers::Offset<PartData>(end);
    return o;
  }
};

inline flatbuffers::Offset<PartData> CreatePartData(
    flatbuffers::FlatBufferBuilder &_fbb,
    flatbuffers::Offset<flatbuffers::String> name = 0,
    int16_t index = 0,
    int16_t parentIndex = 0,
    SsPartType type = SsPartType_Nulltype,
    int16_t boundsType = 0,
    int16_t alphaBlendType = 0,
    flatbuffers::Offset<flatbuffers::String> refname = 0,
    flatbuffers::Offset<flatbuffers::String> effectfilename = 0,
    flatbuffers::Offset<flatbuffers::String> colorLabel = 0,
    int16_t maskInfluence = 0) {
  PartDataBuilder builder_(_fbb);
  builder_.add_colorLabel(colorLabel);
  builder_.add_effectfilename(effectfilename);
  builder_.add_refname(refname);
  builder_.add_name(name);
  builder_.add_maskInfluence(maskInfluence);
  builder_.add_alphaBlendType(alphaBlendType);
  builder_.add_boundsType(boundsType);
  builder_.add_parentIndex(parentIndex);
  builder_.add_index(index);
  builder_.add_type(type);
  return builder_.Finish();
}

inline flatbuffers::Offset<PartData> CreatePartDataDirect(
    flatbuffers::FlatBufferBuilder &_fbb,
    const char *name = nullptr,
    int16_t index = 0,
    int16_t parentIndex = 0,
    SsPartType type = SsPartType_Nulltype,
    int16_t boundsType = 0,
    int16_t alphaBlendType = 0,
    const char *refname = nullptr,
    const char *effectfilename = nullptr,
    const char *colorLabel = nullptr,
    int16_t maskInfluence = 0) {
  return ss::ssfb::CreatePartData(
      _fbb,
      name ? _fbb.CreateString(name) : 0,
      index,
      parentIndex,
      type,
      boundsType,
      alphaBlendType,
      refname ? _fbb.CreateString(refname) : 0,
      effectfilename ? _fbb.CreateString(effectfilename) : 0,
      colorLabel ? _fbb.CreateString(colorLabel) : 0,
      maskInfluence);
}

flatbuffers::Offset<PartData> CreatePartData(flatbuffers::FlatBufferBuilder &_fbb, const PartDataT *_o, const flatbuffers::rehasher_function_t *_rehasher = nullptr);

struct AnimePackDataT : public flatbuffers::NativeTable {
  typedef AnimePackData TableType;
  std::string name;
  std::vector<std::unique_ptr<PartDataT>> parts;
  std::vector<std::unique_ptr<AnimationDataT>> animations;
  AnimePackDataT() {
  }
};

inline bool operator==(const AnimePackDataT &lhs, const AnimePackDataT &rhs) {
  return
      (lhs.name == rhs.name) &&
      (lhs.parts == rhs.parts) &&
      (lhs.animations == rhs.animations);
}

struct AnimePackData FLATBUFFERS_FINAL_CLASS : private flatbuffers::Table {
  typedef AnimePackDataT NativeTableType;
  enum {
    VT_NAME = 4,
    VT_PARTS = 6,
    VT_ANIMATIONS = 8
  };
  const flatbuffers::String *name() const {
    return GetPointer<const flatbuffers::String *>(VT_NAME);
  }
  const flatbuffers::Vector<flatbuffers::Offset<PartData>> *parts() const {
    return GetPointer<const flatbuffers::Vector<flatbuffers::Offset<PartData>> *>(VT_PARTS);
  }
  const flatbuffers::Vector<flatbuffers::Offset<AnimationData>> *animations() const {
    return GetPointer<const flatbuffers::Vector<flatbuffers::Offset<AnimationData>> *>(VT_ANIMATIONS);
  }
  bool Verify(flatbuffers::Verifier &verifier) const {
    return VerifyTableStart(verifier) &&
           VerifyOffset(verifier, VT_NAME) &&
           verifier.VerifyString(name()) &&
           VerifyOffset(verifier, VT_PARTS) &&
           verifier.VerifyVector(parts()) &&
           verifier.VerifyVectorOfTables(parts()) &&
           VerifyOffset(verifier, VT_ANIMATIONS) &&
           verifier.VerifyVector(animations()) &&
           verifier.VerifyVectorOfTables(animations()) &&
           verifier.EndTable();
  }
  AnimePackDataT *UnPack(const flatbuffers::resolver_function_t *_resolver = nullptr) const;
  void UnPackTo(AnimePackDataT *_o, const flatbuffers::resolver_function_t *_resolver = nullptr) const;
  static flatbuffers::Offset<AnimePackData> Pack(flatbuffers::FlatBufferBuilder &_fbb, const AnimePackDataT* _o, const flatbuffers::rehasher_function_t *_rehasher = nullptr);
};

struct AnimePackDataBuilder {
  flatbuffers::FlatBufferBuilder &fbb_;
  flatbuffers::uoffset_t start_;
  void add_name(flatbuffers::Offset<flatbuffers::String> name) {
    fbb_.AddOffset(AnimePackData::VT_NAME, name);
  }
  void add_parts(flatbuffers::Offset<flatbuffers::Vector<flatbuffers::Offset<PartData>>> parts) {
    fbb_.AddOffset(AnimePackData::VT_PARTS, parts);
  }
  void add_animations(flatbuffers::Offset<flatbuffers::Vector<flatbuffers::Offset<AnimationData>>> animations) {
    fbb_.AddOffset(AnimePackData::VT_ANIMATIONS, animations);
  }
  explicit AnimePackDataBuilder(flatbuffers::FlatBufferBuilder &_fbb)
        : fbb_(_fbb) {
    start_ = fbb_.StartTable();
  }
  AnimePackDataBuilder &operator=(const AnimePackDataBuilder &);
  flatbuffers::Offset<AnimePackData> Finish() {
    const auto end = fbb_.EndTable(start_);
    auto o = flatbuffers::Offset<AnimePackData>(end);
    return o;
  }
};

inline flatbuffers::Offset<AnimePackData> CreateAnimePackData(
    flatbuffers::FlatBufferBuilder &_fbb,
    flatbuffers::Offset<flatbuffers::String> name = 0,
    flatbuffers::Offset<flatbuffers::Vector<flatbuffers::Offset<PartData>>> parts = 0,
    flatbuffers::Offset<flatbuffers::Vector<flatbuffers::Offset<AnimationData>>> animations = 0) {
  AnimePackDataBuilder builder_(_fbb);
  builder_.add_animations(animations);
  builder_.add_parts(parts);
  builder_.add_name(name);
  return builder_.Finish();
}

inline flatbuffers::Offset<AnimePackData> CreateAnimePackDataDirect(
    flatbuffers::FlatBufferBuilder &_fbb,
    const char *name = nullptr,
    const std::vector<flatbuffers::Offset<PartData>> *parts = nullptr,
    const std::vector<flatbuffers::Offset<AnimationData>> *animations = nullptr) {
  return ss::ssfb::CreateAnimePackData(
      _fbb,
      name ? _fbb.CreateString(name) : 0,
      parts ? _fbb.CreateVector<flatbuffers::Offset<PartData>>(*parts) : 0,
      animations ? _fbb.CreateVector<flatbuffers::Offset<AnimationData>>(*animations) : 0);
}

flatbuffers::Offset<AnimePackData> CreateAnimePackData(flatbuffers::FlatBufferBuilder &_fbb, const AnimePackDataT *_o, const flatbuffers::rehasher_function_t *_rehasher = nullptr);

struct ProjectDataT : public flatbuffers::NativeTable {
  typedef ProjectData TableType;
  uint32_t dataId;
  uint32_t version;
  uint32_t flags;
  std::string imageBaseDir;
  std::vector<std::unique_ptr<CellT>> cells;
  std::vector<std::unique_ptr<AnimePackDataT>> animePacks;
  std::vector<std::unique_ptr<EffectFileT>> effectFileList;
  int16_t numCells;
  int16_t numAnimePacks;
  int16_t numEffectFileList;
  ProjectDataT()
      : dataId(0),
        version(0),
        flags(0),
        numCells(0),
        numAnimePacks(0),
        numEffectFileList(0) {
  }
};

inline bool operator==(const ProjectDataT &lhs, const ProjectDataT &rhs) {
  return
      (lhs.dataId == rhs.dataId) &&
      (lhs.version == rhs.version) &&
      (lhs.flags == rhs.flags) &&
      (lhs.imageBaseDir == rhs.imageBaseDir) &&
      (lhs.cells == rhs.cells) &&
      (lhs.animePacks == rhs.animePacks) &&
      (lhs.effectFileList == rhs.effectFileList) &&
      (lhs.numCells == rhs.numCells) &&
      (lhs.numAnimePacks == rhs.numAnimePacks) &&
      (lhs.numEffectFileList == rhs.numEffectFileList);
}

struct ProjectData FLATBUFFERS_FINAL_CLASS : private flatbuffers::Table {
  typedef ProjectDataT NativeTableType;
  enum {
    VT_DATAID = 4,
    VT_VERSION = 6,
    VT_FLAGS = 8,
    VT_IMAGEBASEDIR = 10,
    VT_CELLS = 12,
    VT_ANIMEPACKS = 14,
    VT_EFFECTFILELIST = 16,
    VT_NUMCELLS = 18,
    VT_NUMANIMEPACKS = 20,
    VT_NUMEFFECTFILELIST = 22
  };
  uint32_t dataId() const {
    return GetField<uint32_t>(VT_DATAID, 0);
  }
  uint32_t version() const {
    return GetField<uint32_t>(VT_VERSION, 0);
  }
  uint32_t flags() const {
    return GetField<uint32_t>(VT_FLAGS, 0);
  }
  const flatbuffers::String *imageBaseDir() const {
    return GetPointer<const flatbuffers::String *>(VT_IMAGEBASEDIR);
  }
  const flatbuffers::Vector<flatbuffers::Offset<Cell>> *cells() const {
    return GetPointer<const flatbuffers::Vector<flatbuffers::Offset<Cell>> *>(VT_CELLS);
  }
  const flatbuffers::Vector<flatbuffers::Offset<AnimePackData>> *animePacks() const {
    return GetPointer<const flatbuffers::Vector<flatbuffers::Offset<AnimePackData>> *>(VT_ANIMEPACKS);
  }
  const flatbuffers::Vector<flatbuffers::Offset<EffectFile>> *effectFileList() const {
    return GetPointer<const flatbuffers::Vector<flatbuffers::Offset<EffectFile>> *>(VT_EFFECTFILELIST);
  }
  int16_t numCells() const {
    return GetField<int16_t>(VT_NUMCELLS, 0);
  }
  int16_t numAnimePacks() const {
    return GetField<int16_t>(VT_NUMANIMEPACKS, 0);
  }
  int16_t numEffectFileList() const {
    return GetField<int16_t>(VT_NUMEFFECTFILELIST, 0);
  }
  bool Verify(flatbuffers::Verifier &verifier) const {
    return VerifyTableStart(verifier) &&
           VerifyField<uint32_t>(verifier, VT_DATAID) &&
           VerifyField<uint32_t>(verifier, VT_VERSION) &&
           VerifyField<uint32_t>(verifier, VT_FLAGS) &&
           VerifyOffset(verifier, VT_IMAGEBASEDIR) &&
           verifier.VerifyString(imageBaseDir()) &&
           VerifyOffset(verifier, VT_CELLS) &&
           verifier.VerifyVector(cells()) &&
           verifier.VerifyVectorOfTables(cells()) &&
           VerifyOffset(verifier, VT_ANIMEPACKS) &&
           verifier.VerifyVector(animePacks()) &&
           verifier.VerifyVectorOfTables(animePacks()) &&
           VerifyOffset(verifier, VT_EFFECTFILELIST) &&
           verifier.VerifyVector(effectFileList()) &&
           verifier.VerifyVectorOfTables(effectFileList()) &&
           VerifyField<int16_t>(verifier, VT_NUMCELLS) &&
           VerifyField<int16_t>(verifier, VT_NUMANIMEPACKS) &&
           VerifyField<int16_t>(verifier, VT_NUMEFFECTFILELIST) &&
           verifier.EndTable();
  }
  ProjectDataT *UnPack(const flatbuffers::resolver_function_t *_resolver = nullptr) const;
  void UnPackTo(ProjectDataT *_o, const flatbuffers::resolver_function_t *_resolver = nullptr) const;
  static flatbuffers::Offset<ProjectData> Pack(flatbuffers::FlatBufferBuilder &_fbb, const ProjectDataT* _o, const flatbuffers::rehasher_function_t *_rehasher = nullptr);
};

struct ProjectDataBuilder {
  flatbuffers::FlatBufferBuilder &fbb_;
  flatbuffers::uoffset_t start_;
  void add_dataId(uint32_t dataId) {
    fbb_.AddElement<uint32_t>(ProjectData::VT_DATAID, dataId, 0);
  }
  void add_version(uint32_t version) {
    fbb_.AddElement<uint32_t>(ProjectData::VT_VERSION, version, 0);
  }
  void add_flags(uint32_t flags) {
    fbb_.AddElement<uint32_t>(ProjectData::VT_FLAGS, flags, 0);
  }
  void add_imageBaseDir(flatbuffers::Offset<flatbuffers::String> imageBaseDir) {
    fbb_.AddOffset(ProjectData::VT_IMAGEBASEDIR, imageBaseDir);
  }
  void add_cells(flatbuffers::Offset<flatbuffers::Vector<flatbuffers::Offset<Cell>>> cells) {
    fbb_.AddOffset(ProjectData::VT_CELLS, cells);
  }
  void add_animePacks(flatbuffers::Offset<flatbuffers::Vector<flatbuffers::Offset<AnimePackData>>> animePacks) {
    fbb_.AddOffset(ProjectData::VT_ANIMEPACKS, animePacks);
  }
  void add_effectFileList(flatbuffers::Offset<flatbuffers::Vector<flatbuffers::Offset<EffectFile>>> effectFileList) {
    fbb_.AddOffset(ProjectData::VT_EFFECTFILELIST, effectFileList);
  }
  void add_numCells(int16_t numCells) {
    fbb_.AddElement<int16_t>(ProjectData::VT_NUMCELLS, numCells, 0);
  }
  void add_numAnimePacks(int16_t numAnimePacks) {
    fbb_.AddElement<int16_t>(ProjectData::VT_NUMANIMEPACKS, numAnimePacks, 0);
  }
  void add_numEffectFileList(int16_t numEffectFileList) {
    fbb_.AddElement<int16_t>(ProjectData::VT_NUMEFFECTFILELIST, numEffectFileList, 0);
  }
  explicit ProjectDataBuilder(flatbuffers::FlatBufferBuilder &_fbb)
        : fbb_(_fbb) {
    start_ = fbb_.StartTable();
  }
  ProjectDataBuilder &operator=(const ProjectDataBuilder &);
  flatbuffers::Offset<ProjectData> Finish() {
    const auto end = fbb_.EndTable(start_);
    auto o = flatbuffers::Offset<ProjectData>(end);
    return o;
  }
};

inline flatbuffers::Offset<ProjectData> CreateProjectData(
    flatbuffers::FlatBufferBuilder &_fbb,
    uint32_t dataId = 0,
    uint32_t version = 0,
    uint32_t flags = 0,
    flatbuffers::Offset<flatbuffers::String> imageBaseDir = 0,
    flatbuffers::Offset<flatbuffers::Vector<flatbuffers::Offset<Cell>>> cells = 0,
    flatbuffers::Offset<flatbuffers::Vector<flatbuffers::Offset<AnimePackData>>> animePacks = 0,
    flatbuffers::Offset<flatbuffers::Vector<flatbuffers::Offset<EffectFile>>> effectFileList = 0,
    int16_t numCells = 0,
    int16_t numAnimePacks = 0,
    int16_t numEffectFileList = 0) {
  ProjectDataBuilder builder_(_fbb);
  builder_.add_effectFileList(effectFileList);
  builder_.add_animePacks(animePacks);
  builder_.add_cells(cells);
  builder_.add_imageBaseDir(imageBaseDir);
  builder_.add_flags(flags);
  builder_.add_version(version);
  builder_.add_dataId(dataId);
  builder_.add_numEffectFileList(numEffectFileList);
  builder_.add_numAnimePacks(numAnimePacks);
  builder_.add_numCells(numCells);
  return builder_.Finish();
}

inline flatbuffers::Offset<ProjectData> CreateProjectDataDirect(
    flatbuffers::FlatBufferBuilder &_fbb,
    uint32_t dataId = 0,
    uint32_t version = 0,
    uint32_t flags = 0,
    const char *imageBaseDir = nullptr,
    const std::vector<flatbuffers::Offset<Cell>> *cells = nullptr,
    const std::vector<flatbuffers::Offset<AnimePackData>> *animePacks = nullptr,
    const std::vector<flatbuffers::Offset<EffectFile>> *effectFileList = nullptr,
    int16_t numCells = 0,
    int16_t numAnimePacks = 0,
    int16_t numEffectFileList = 0) {
  return ss::ssfb::CreateProjectData(
      _fbb,
      dataId,
      version,
      flags,
      imageBaseDir ? _fbb.CreateString(imageBaseDir) : 0,
      cells ? _fbb.CreateVector<flatbuffers::Offset<Cell>>(*cells) : 0,
      animePacks ? _fbb.CreateVector<flatbuffers::Offset<AnimePackData>>(*animePacks) : 0,
      effectFileList ? _fbb.CreateVector<flatbuffers::Offset<EffectFile>>(*effectFileList) : 0,
      numCells,
      numAnimePacks,
      numEffectFileList);
}

flatbuffers::Offset<ProjectData> CreateProjectData(flatbuffers::FlatBufferBuilder &_fbb, const ProjectDataT *_o, const flatbuffers::rehasher_function_t *_rehasher = nullptr);

inline EffectNodeT *EffectNode::UnPack(const flatbuffers::resolver_function_t *_resolver) const {
  auto _o = new EffectNodeT();
  UnPackTo(_o, _resolver);
  return _o;
}

inline void EffectNode::UnPackTo(EffectNodeT *_o, const flatbuffers::resolver_function_t *_resolver) const {
  (void)_o;
  (void)_resolver;
  { auto _e = arrayIndex(); _o->arrayIndex = _e; };
  { auto _e = parentIndex(); _o->parentIndex = _e; };
  { auto _e = type(); _o->type = _e; };
  { auto _e = cellIndex(); _o->cellIndex = _e; };
  { auto _e = blendType(); _o->blendType = _e; };
  { auto _e = numBehavior(); _o->numBehavior = _e; };
  { auto _e = Behavior_type(); if (_e) { _o->Behavior.resize(_e->size()); for (flatbuffers::uoffset_t _i = 0; _i < _e->size(); _i++) { _o->Behavior[_i].type = (EffectNodeBehavior)_e->Get(_i); } } };
  { auto _e = Behavior(); if (_e) { _o->Behavior.resize(_e->size()); for (flatbuffers::uoffset_t _i = 0; _i < _e->size(); _i++) { _o->Behavior[_i].value = EffectNodeBehaviorUnion::UnPack(_e->Get(_i), Behavior_type()->GetEnum<EffectNodeBehavior>(_i), _resolver); } } };
}

inline flatbuffers::Offset<EffectNode> EffectNode::Pack(flatbuffers::FlatBufferBuilder &_fbb, const EffectNodeT* _o, const flatbuffers::rehasher_function_t *_rehasher) {
  return CreateEffectNode(_fbb, _o, _rehasher);
}

inline flatbuffers::Offset<EffectNode> CreateEffectNode(flatbuffers::FlatBufferBuilder &_fbb, const EffectNodeT *_o, const flatbuffers::rehasher_function_t *_rehasher) {
  (void)_rehasher;
  (void)_o;
  struct _VectorArgs { flatbuffers::FlatBufferBuilder *__fbb; const EffectNodeT* __o; const flatbuffers::rehasher_function_t *__rehasher; } _va = { &_fbb, _o, _rehasher}; (void)_va;
  auto _arrayIndex = _o->arrayIndex;
  auto _parentIndex = _o->parentIndex;
  auto _type = _o->type;
  auto _cellIndex = _o->cellIndex;
  auto _blendType = _o->blendType;
  auto _numBehavior = _o->numBehavior;
  auto _Behavior_type = _o->Behavior.size() ? _fbb.CreateVector<uint8_t>(_o->Behavior.size(), [](size_t i, _VectorArgs *__va) { return static_cast<uint8_t>(__va->__o->Behavior[i].type); }, &_va) : 0;
  auto _Behavior = _o->Behavior.size() ? _fbb.CreateVector<flatbuffers::Offset<void>>(_o->Behavior.size(), [](size_t i, _VectorArgs *__va) { return __va->__o->Behavior[i].Pack(*__va->__fbb, __va->__rehasher); }, &_va) : 0;
  return ss::ssfb::CreateEffectNode(
      _fbb,
      _arrayIndex,
      _parentIndex,
      _type,
      _cellIndex,
      _blendType,
      _numBehavior,
      _Behavior_type,
      _Behavior);
}

inline EffectFileT *EffectFile::UnPack(const flatbuffers::resolver_function_t *_resolver) const {
  auto _o = new EffectFileT();
  UnPackTo(_o, _resolver);
  return _o;
}

inline void EffectFile::UnPackTo(EffectFileT *_o, const flatbuffers::resolver_function_t *_resolver) const {
  (void)_o;
  (void)_resolver;
  { auto _e = name(); if (_e) _o->name = _e->str(); };
  { auto _e = fps(); _o->fps = _e; };
  { auto _e = isLockRandSeed(); _o->isLockRandSeed = _e; };
  { auto _e = lockRandSeed(); _o->lockRandSeed = _e; };
  { auto _e = layoutScaleX(); _o->layoutScaleX = _e; };
  { auto _e = layoutScaleY(); _o->layoutScaleY = _e; };
  { auto _e = numNodeList(); _o->numNodeList = _e; };
  { auto _e = effectNode(); if (_e) { _o->effectNode.resize(_e->size()); for (flatbuffers::uoffset_t _i = 0; _i < _e->size(); _i++) { _o->effectNode[_i] = std::unique_ptr<EffectNodeT>(_e->Get(_i)->UnPack(_resolver)); } } };
}

inline flatbuffers::Offset<EffectFile> EffectFile::Pack(flatbuffers::FlatBufferBuilder &_fbb, const EffectFileT* _o, const flatbuffers::rehasher_function_t *_rehasher) {
  return CreateEffectFile(_fbb, _o, _rehasher);
}

inline flatbuffers::Offset<EffectFile> CreateEffectFile(flatbuffers::FlatBufferBuilder &_fbb, const EffectFileT *_o, const flatbuffers::rehasher_function_t *_rehasher) {
  (void)_rehasher;
  (void)_o;
  struct _VectorArgs { flatbuffers::FlatBufferBuilder *__fbb; const EffectFileT* __o; const flatbuffers::rehasher_function_t *__rehasher; } _va = { &_fbb, _o, _rehasher}; (void)_va;
  auto _name = _o->name.empty() ? 0 : _fbb.CreateString(_o->name);
  auto _fps = _o->fps;
  auto _isLockRandSeed = _o->isLockRandSeed;
  auto _lockRandSeed = _o->lockRandSeed;
  auto _layoutScaleX = _o->layoutScaleX;
  auto _layoutScaleY = _o->layoutScaleY;
  auto _numNodeList = _o->numNodeList;
  auto _effectNode = _o->effectNode.size() ? _fbb.CreateVector<flatbuffers::Offset<EffectNode>> (_o->effectNode.size(), [](size_t i, _VectorArgs *__va) { return CreateEffectNode(*__va->__fbb, __va->__o->effectNode[i].get(), __va->__rehasher); }, &_va ) : 0;
  return ss::ssfb::CreateEffectFile(
      _fbb,
      _name,
      _fps,
      _isLockRandSeed,
      _lockRandSeed,
      _layoutScaleX,
      _layoutScaleY,
      _numNodeList,
      _effectNode);
}

inline CellMapT *CellMap::UnPack(const flatbuffers::resolver_function_t *_resolver) const {
  auto _o = new CellMapT();
  UnPackTo(_o, _resolver);
  return _o;
}

inline void CellMap::UnPackTo(CellMapT *_o, const flatbuffers::resolver_function_t *_resolver) const {
  (void)_o;
  (void)_resolver;
  { auto _e = name(); if (_e) _o->name = _e->str(); };
  { auto _e = imagePath(); if (_e) _o->imagePath = _e->str(); };
  { auto _e = index(); _o->index = _e; };
  { auto _e = wrapmode(); _o->wrapmode = _e; };
  { auto _e = filtermode(); _o->filtermode = _e; };
}

inline flatbuffers::Offset<CellMap> CellMap::Pack(flatbuffers::FlatBufferBuilder &_fbb, const CellMapT* _o, const flatbuffers::rehasher_function_t *_rehasher) {
  return CreateCellMap(_fbb, _o, _rehasher);
}

inline flatbuffers::Offset<CellMap> CreateCellMap(flatbuffers::FlatBufferBuilder &_fbb, const CellMapT *_o, const flatbuffers::rehasher_function_t *_rehasher) {
  (void)_rehasher;
  (void)_o;
  struct _VectorArgs { flatbuffers::FlatBufferBuilder *__fbb; const CellMapT* __o; const flatbuffers::rehasher_function_t *__rehasher; } _va = { &_fbb, _o, _rehasher}; (void)_va;
  auto _name = _o->name.empty() ? 0 : _fbb.CreateString(_o->name);
  auto _imagePath = _o->imagePath.empty() ? 0 : _fbb.CreateString(_o->imagePath);
  auto _index = _o->index;
  auto _wrapmode = _o->wrapmode;
  auto _filtermode = _o->filtermode;
  return ss::ssfb::CreateCellMap(
      _fbb,
      _name,
      _imagePath,
      _index,
      _wrapmode,
      _filtermode);
}

inline CellT *Cell::UnPack(const flatbuffers::resolver_function_t *_resolver) const {
  auto _o = new CellT();
  UnPackTo(_o, _resolver);
  return _o;
}

inline void Cell::UnPackTo(CellT *_o, const flatbuffers::resolver_function_t *_resolver) const {
  (void)_o;
  (void)_resolver;
  { auto _e = name(); if (_e) _o->name = _e->str(); };
  { auto _e = cellMap(); if (_e) _o->cellMap = std::unique_ptr<CellMapT>(_e->UnPack(_resolver)); };
  { auto _e = indexInCellMap(); _o->indexInCellMap = _e; };
  { auto _e = x(); _o->x = _e; };
  { auto _e = y(); _o->y = _e; };
  { auto _e = width(); _o->width = _e; };
  { auto _e = height(); _o->height = _e; };
  { auto _e = pivot_x(); _o->pivot_x = _e; };
  { auto _e = pivot_y(); _o->pivot_y = _e; };
  { auto _e = u1(); _o->u1 = _e; };
  { auto _e = v1(); _o->v1 = _e; };
  { auto _e = u2(); _o->u2 = _e; };
  { auto _e = v2(); _o->v2 = _e; };
}

inline flatbuffers::Offset<Cell> Cell::Pack(flatbuffers::FlatBufferBuilder &_fbb, const CellT* _o, const flatbuffers::rehasher_function_t *_rehasher) {
  return CreateCell(_fbb, _o, _rehasher);
}

inline flatbuffers::Offset<Cell> CreateCell(flatbuffers::FlatBufferBuilder &_fbb, const CellT *_o, const flatbuffers::rehasher_function_t *_rehasher) {
  (void)_rehasher;
  (void)_o;
  struct _VectorArgs { flatbuffers::FlatBufferBuilder *__fbb; const CellT* __o; const flatbuffers::rehasher_function_t *__rehasher; } _va = { &_fbb, _o, _rehasher}; (void)_va;
  auto _name = _o->name.empty() ? 0 : _fbb.CreateString(_o->name);
  auto _cellMap = _o->cellMap ? CreateCellMap(_fbb, _o->cellMap.get(), _rehasher) : 0;
  auto _indexInCellMap = _o->indexInCellMap;
  auto _x = _o->x;
  auto _y = _o->y;
  auto _width = _o->width;
  auto _height = _o->height;
  auto _pivot_x = _o->pivot_x;
  auto _pivot_y = _o->pivot_y;
  auto _u1 = _o->u1;
  auto _v1 = _o->v1;
  auto _u2 = _o->u2;
  auto _v2 = _o->v2;
  return ss::ssfb::CreateCell(
      _fbb,
      _name,
      _cellMap,
      _indexInCellMap,
      _x,
      _y,
      _width,
      _height,
      _pivot_x,
      _pivot_y,
      _u1,
      _v1,
      _u2,
      _v2);
}

inline meshDataUVT *meshDataUV::UnPack(const flatbuffers::resolver_function_t *_resolver) const {
  auto _o = new meshDataUVT();
  UnPackTo(_o, _resolver);
  return _o;
}

inline void meshDataUV::UnPackTo(meshDataUVT *_o, const flatbuffers::resolver_function_t *_resolver) const {
  (void)_o;
  (void)_resolver;
  { auto _e = uv(); if (_e) { _o->uv.resize(_e->size()); for (flatbuffers::uoffset_t _i = 0; _i < _e->size(); _i++) { _o->uv[_i] = _e->Get(_i); } } };
}

inline flatbuffers::Offset<meshDataUV> meshDataUV::Pack(flatbuffers::FlatBufferBuilder &_fbb, const meshDataUVT* _o, const flatbuffers::rehasher_function_t *_rehasher) {
  return CreatemeshDataUV(_fbb, _o, _rehasher);
}

inline flatbuffers::Offset<meshDataUV> CreatemeshDataUV(flatbuffers::FlatBufferBuilder &_fbb, const meshDataUVT *_o, const flatbuffers::rehasher_function_t *_rehasher) {
  (void)_rehasher;
  (void)_o;
  struct _VectorArgs { flatbuffers::FlatBufferBuilder *__fbb; const meshDataUVT* __o; const flatbuffers::rehasher_function_t *__rehasher; } _va = { &_fbb, _o, _rehasher}; (void)_va;
  auto _uv = _o->uv.size() ? _fbb.CreateVector(_o->uv) : 0;
  return ss::ssfb::CreatemeshDataUV(
      _fbb,
      _uv);
}

inline meshDataIndicesT *meshDataIndices::UnPack(const flatbuffers::resolver_function_t *_resolver) const {
  auto _o = new meshDataIndicesT();
  UnPackTo(_o, _resolver);
  return _o;
}

inline void meshDataIndices::UnPackTo(meshDataIndicesT *_o, const flatbuffers::resolver_function_t *_resolver) const {
  (void)_o;
  (void)_resolver;
  { auto _e = indices(); if (_e) { _o->indices.resize(_e->size()); for (flatbuffers::uoffset_t _i = 0; _i < _e->size(); _i++) { _o->indices[_i] = _e->Get(_i); } } };
}

inline flatbuffers::Offset<meshDataIndices> meshDataIndices::Pack(flatbuffers::FlatBufferBuilder &_fbb, const meshDataIndicesT* _o, const flatbuffers::rehasher_function_t *_rehasher) {
  return CreatemeshDataIndices(_fbb, _o, _rehasher);
}

inline flatbuffers::Offset<meshDataIndices> CreatemeshDataIndices(flatbuffers::FlatBufferBuilder &_fbb, const meshDataIndicesT *_o, const flatbuffers::rehasher_function_t *_rehasher) {
  (void)_rehasher;
  (void)_o;
  struct _VectorArgs { flatbuffers::FlatBufferBuilder *__fbb; const meshDataIndicesT* __o; const flatbuffers::rehasher_function_t *__rehasher; } _va = { &_fbb, _o, _rehasher}; (void)_va;
  auto _indices = _o->indices.size() ? _fbb.CreateVector(_o->indices) : 0;
  return ss::ssfb::CreatemeshDataIndices(
      _fbb,
      _indices);
}

inline partStateT *partState::UnPack(const flatbuffers::resolver_function_t *_resolver) const {
  auto _o = new partStateT();
  UnPackTo(_o, _resolver);
  return _o;
}

inline void partState::UnPackTo(partStateT *_o, const flatbuffers::resolver_function_t *_resolver) const {
  (void)_o;
  (void)_resolver;
  { auto _e = index(); _o->index = _e; };
  { auto _e = flag1(); _o->flag1 = _e; };
  { auto _e = flag2(); _o->flag2 = _e; };
  { auto _e = data(); if (_e) { _o->data.resize(_e->size()); for (flatbuffers::uoffset_t _i = 0; _i < _e->size(); _i++) { _o->data[_i] = _e->Get(_i); } } };
}

inline flatbuffers::Offset<partState> partState::Pack(flatbuffers::FlatBufferBuilder &_fbb, const partStateT* _o, const flatbuffers::rehasher_function_t *_rehasher) {
  return CreatepartState(_fbb, _o, _rehasher);
}

inline flatbuffers::Offset<partState> CreatepartState(flatbuffers::FlatBufferBuilder &_fbb, const partStateT *_o, const flatbuffers::rehasher_function_t *_rehasher) {
  (void)_rehasher;
  (void)_o;
  struct _VectorArgs { flatbuffers::FlatBufferBuilder *__fbb; const partStateT* __o; const flatbuffers::rehasher_function_t *__rehasher; } _va = { &_fbb, _o, _rehasher}; (void)_va;
  auto _index = _o->index;
  auto _flag1 = _o->flag1;
  auto _flag2 = _o->flag2;
  auto _data = _o->data.size() ? _fbb.CreateVector(_o->data) : 0;
  return ss::ssfb::CreatepartState(
      _fbb,
      _index,
      _flag1,
      _flag2,
      _data);
}

inline frameDataIndexT *frameDataIndex::UnPack(const flatbuffers::resolver_function_t *_resolver) const {
  auto _o = new frameDataIndexT();
  UnPackTo(_o, _resolver);
  return _o;
}

inline void frameDataIndex::UnPackTo(frameDataIndexT *_o, const flatbuffers::resolver_function_t *_resolver) const {
  (void)_o;
  (void)_resolver;
  { auto _e = states(); if (_e) { _o->states.resize(_e->size()); for (flatbuffers::uoffset_t _i = 0; _i < _e->size(); _i++) { _o->states[_i] = std::unique_ptr<partStateT>(_e->Get(_i)->UnPack(_resolver)); } } };
}

inline flatbuffers::Offset<frameDataIndex> frameDataIndex::Pack(flatbuffers::FlatBufferBuilder &_fbb, const frameDataIndexT* _o, const flatbuffers::rehasher_function_t *_rehasher) {
  return CreateframeDataIndex(_fbb, _o, _rehasher);
}

inline flatbuffers::Offset<frameDataIndex> CreateframeDataIndex(flatbuffers::FlatBufferBuilder &_fbb, const frameDataIndexT *_o, const flatbuffers::rehasher_function_t *_rehasher) {
  (void)_rehasher;
  (void)_o;
  struct _VectorArgs { flatbuffers::FlatBufferBuilder *__fbb; const frameDataIndexT* __o; const flatbuffers::rehasher_function_t *__rehasher; } _va = { &_fbb, _o, _rehasher}; (void)_va;
  auto _states = _o->states.size() ? _fbb.CreateVector<flatbuffers::Offset<partState>> (_o->states.size(), [](size_t i, _VectorArgs *__va) { return CreatepartState(*__va->__fbb, __va->__o->states[i].get(), __va->__rehasher); }, &_va ) : 0;
  return ss::ssfb::CreateframeDataIndex(
      _fbb,
      _states);
}

inline userDataStringT *userDataString::UnPack(const flatbuffers::resolver_function_t *_resolver) const {
  auto _o = new userDataStringT();
  UnPackTo(_o, _resolver);
  return _o;
}

inline void userDataString::UnPackTo(userDataStringT *_o, const flatbuffers::resolver_function_t *_resolver) const {
  (void)_o;
  (void)_resolver;
  { auto _e = length(); _o->length = _e; };
  { auto _e = data(); if (_e) _o->data = _e->str(); };
}

inline flatbuffers::Offset<userDataString> userDataString::Pack(flatbuffers::FlatBufferBuilder &_fbb, const userDataStringT* _o, const flatbuffers::rehasher_function_t *_rehasher) {
  return CreateuserDataString(_fbb, _o, _rehasher);
}

inline flatbuffers::Offset<userDataString> CreateuserDataString(flatbuffers::FlatBufferBuilder &_fbb, const userDataStringT *_o, const flatbuffers::rehasher_function_t *_rehasher) {
  (void)_rehasher;
  (void)_o;
  struct _VectorArgs { flatbuffers::FlatBufferBuilder *__fbb; const userDataStringT* __o; const flatbuffers::rehasher_function_t *__rehasher; } _va = { &_fbb, _o, _rehasher}; (void)_va;
  auto _length = _o->length;
  auto _data = _o->data.empty() ? 0 : _fbb.CreateString(_o->data);
  return ss::ssfb::CreateuserDataString(
      _fbb,
      _length,
      _data);
}

inline userDataItemT *userDataItem::UnPack(const flatbuffers::resolver_function_t *_resolver) const {
  auto _o = new userDataItemT();
  UnPackTo(_o, _resolver);
  return _o;
}

inline void userDataItem::UnPackTo(userDataItemT *_o, const flatbuffers::resolver_function_t *_resolver) const {
  (void)_o;
  (void)_resolver;
  { auto _e = flags(); _o->flags = _e; };
  { auto _e = arrayIndex(); _o->arrayIndex = _e; };
  { auto _e = data_type(); if (_e) { _o->data.resize(_e->size()); for (flatbuffers::uoffset_t _i = 0; _i < _e->size(); _i++) { _o->data[_i].type = (userDataValue)_e->Get(_i); } } };
  { auto _e = data(); if (_e) { _o->data.resize(_e->size()); for (flatbuffers::uoffset_t _i = 0; _i < _e->size(); _i++) { _o->data[_i].value = userDataValueUnion::UnPack(_e->Get(_i), data_type()->GetEnum<userDataValue>(_i), _resolver); } } };
}

inline flatbuffers::Offset<userDataItem> userDataItem::Pack(flatbuffers::FlatBufferBuilder &_fbb, const userDataItemT* _o, const flatbuffers::rehasher_function_t *_rehasher) {
  return CreateuserDataItem(_fbb, _o, _rehasher);
}

inline flatbuffers::Offset<userDataItem> CreateuserDataItem(flatbuffers::FlatBufferBuilder &_fbb, const userDataItemT *_o, const flatbuffers::rehasher_function_t *_rehasher) {
  (void)_rehasher;
  (void)_o;
  struct _VectorArgs { flatbuffers::FlatBufferBuilder *__fbb; const userDataItemT* __o; const flatbuffers::rehasher_function_t *__rehasher; } _va = { &_fbb, _o, _rehasher}; (void)_va;
  auto _flags = _o->flags;
  auto _arrayIndex = _o->arrayIndex;
  auto _data_type = _o->data.size() ? _fbb.CreateVector<uint8_t>(_o->data.size(), [](size_t i, _VectorArgs *__va) { return static_cast<uint8_t>(__va->__o->data[i].type); }, &_va) : 0;
  auto _data = _o->data.size() ? _fbb.CreateVector<flatbuffers::Offset<void>>(_o->data.size(), [](size_t i, _VectorArgs *__va) { return __va->__o->data[i].Pack(*__va->__fbb, __va->__rehasher); }, &_va) : 0;
  return ss::ssfb::CreateuserDataItem(
      _fbb,
      _flags,
      _arrayIndex,
      _data_type,
      _data);
}

inline userDataPerFrameT *userDataPerFrame::UnPack(const flatbuffers::resolver_function_t *_resolver) const {
  auto _o = new userDataPerFrameT();
  UnPackTo(_o, _resolver);
  return _o;
}

inline void userDataPerFrame::UnPackTo(userDataPerFrameT *_o, const flatbuffers::resolver_function_t *_resolver) const {
  (void)_o;
  (void)_resolver;
  { auto _e = frameIndex(); _o->frameIndex = _e; };
  { auto _e = data(); if (_e) { _o->data.resize(_e->size()); for (flatbuffers::uoffset_t _i = 0; _i < _e->size(); _i++) { _o->data[_i] = std::unique_ptr<userDataItemT>(_e->Get(_i)->UnPack(_resolver)); } } };
}

inline flatbuffers::Offset<userDataPerFrame> userDataPerFrame::Pack(flatbuffers::FlatBufferBuilder &_fbb, const userDataPerFrameT* _o, const flatbuffers::rehasher_function_t *_rehasher) {
  return CreateuserDataPerFrame(_fbb, _o, _rehasher);
}

inline flatbuffers::Offset<userDataPerFrame> CreateuserDataPerFrame(flatbuffers::FlatBufferBuilder &_fbb, const userDataPerFrameT *_o, const flatbuffers::rehasher_function_t *_rehasher) {
  (void)_rehasher;
  (void)_o;
  struct _VectorArgs { flatbuffers::FlatBufferBuilder *__fbb; const userDataPerFrameT* __o; const flatbuffers::rehasher_function_t *__rehasher; } _va = { &_fbb, _o, _rehasher}; (void)_va;
  auto _frameIndex = _o->frameIndex;
  auto _data = _o->data.size() ? _fbb.CreateVector<flatbuffers::Offset<userDataItem>> (_o->data.size(), [](size_t i, _VectorArgs *__va) { return CreateuserDataItem(*__va->__fbb, __va->__o->data[i].get(), __va->__rehasher); }, &_va ) : 0;
  return ss::ssfb::CreateuserDataPerFrame(
      _fbb,
      _frameIndex,
      _data);
}

inline labelDataItemT *labelDataItem::UnPack(const flatbuffers::resolver_function_t *_resolver) const {
  auto _o = new labelDataItemT();
  UnPackTo(_o, _resolver);
  return _o;
}

inline void labelDataItem::UnPackTo(labelDataItemT *_o, const flatbuffers::resolver_function_t *_resolver) const {
  (void)_o;
  (void)_resolver;
  { auto _e = label(); if (_e) _o->label = _e->str(); };
  { auto _e = frameIndex(); _o->frameIndex = _e; };
}

inline flatbuffers::Offset<labelDataItem> labelDataItem::Pack(flatbuffers::FlatBufferBuilder &_fbb, const labelDataItemT* _o, const flatbuffers::rehasher_function_t *_rehasher) {
  return CreatelabelDataItem(_fbb, _o, _rehasher);
}

inline flatbuffers::Offset<labelDataItem> CreatelabelDataItem(flatbuffers::FlatBufferBuilder &_fbb, const labelDataItemT *_o, const flatbuffers::rehasher_function_t *_rehasher) {
  (void)_rehasher;
  (void)_o;
  struct _VectorArgs { flatbuffers::FlatBufferBuilder *__fbb; const labelDataItemT* __o; const flatbuffers::rehasher_function_t *__rehasher; } _va = { &_fbb, _o, _rehasher}; (void)_va;
  auto _label = _o->label.empty() ? 0 : _fbb.CreateString(_o->label);
  auto _frameIndex = _o->frameIndex;
  return ss::ssfb::CreatelabelDataItem(
      _fbb,
      _label,
      _frameIndex);
}

inline AnimationDataT *AnimationData::UnPack(const flatbuffers::resolver_function_t *_resolver) const {
  auto _o = new AnimationDataT();
  UnPackTo(_o, _resolver);
  return _o;
}

inline void AnimationData::UnPackTo(AnimationDataT *_o, const flatbuffers::resolver_function_t *_resolver) const {
  (void)_o;
  (void)_resolver;
  { auto _e = name(); if (_e) _o->name = _e->str(); };
  { auto _e = defaultData(); if (_e) { _o->defaultData.resize(_e->size()); for (flatbuffers::uoffset_t _i = 0; _i < _e->size(); _i++) { _o->defaultData[_i] = std::unique_ptr<AnimationInitialDataT>(_e->Get(_i)->UnPack(_resolver)); } } };
  { auto _e = frameData(); if (_e) { _o->frameData.resize(_e->size()); for (flatbuffers::uoffset_t _i = 0; _i < _e->size(); _i++) { _o->frameData[_i] = std::unique_ptr<frameDataIndexT>(_e->Get(_i)->UnPack(_resolver)); } } };
  { auto _e = userData(); if (_e) { _o->userData.resize(_e->size()); for (flatbuffers::uoffset_t _i = 0; _i < _e->size(); _i++) { _o->userData[_i] = std::unique_ptr<userDataPerFrameT>(_e->Get(_i)->UnPack(_resolver)); } } };
  { auto _e = labelData(); if (_e) { _o->labelData.resize(_e->size()); for (flatbuffers::uoffset_t _i = 0; _i < _e->size(); _i++) { _o->labelData[_i] = std::unique_ptr<labelDataItemT>(_e->Get(_i)->UnPack(_resolver)); } } };
  { auto _e = meshsDataUV(); if (_e) { _o->meshsDataUV.resize(_e->size()); for (flatbuffers::uoffset_t _i = 0; _i < _e->size(); _i++) { _o->meshsDataUV[_i] = std::unique_ptr<meshDataUVT>(_e->Get(_i)->UnPack(_resolver)); } } };
  { auto _e = meshsDataIndices(); if (_e) { _o->meshsDataIndices.resize(_e->size()); for (flatbuffers::uoffset_t _i = 0; _i < _e->size(); _i++) { _o->meshsDataIndices[_i] = std::unique_ptr<meshDataIndicesT>(_e->Get(_i)->UnPack(_resolver)); } } };
  { auto _e = startFrames(); _o->startFrames = _e; };
  { auto _e = endFrames(); _o->endFrames = _e; };
  { auto _e = totalFrames(); _o->totalFrames = _e; };
  { auto _e = fps(); _o->fps = _e; };
  { auto _e = labelNum(); _o->labelNum = _e; };
  { auto _e = canvasSizeW(); _o->canvasSizeW = _e; };
  { auto _e = canvasSizeH(); _o->canvasSizeH = _e; };
  { auto _e = canvasPvotX(); _o->canvasPvotX = _e; };
  { auto _e = canvasPvotY(); _o->canvasPvotY = _e; };
}

inline flatbuffers::Offset<AnimationData> AnimationData::Pack(flatbuffers::FlatBufferBuilder &_fbb, const AnimationDataT* _o, const flatbuffers::rehasher_function_t *_rehasher) {
  return CreateAnimationData(_fbb, _o, _rehasher);
}

inline flatbuffers::Offset<AnimationData> CreateAnimationData(flatbuffers::FlatBufferBuilder &_fbb, const AnimationDataT *_o, const flatbuffers::rehasher_function_t *_rehasher) {
  (void)_rehasher;
  (void)_o;
  struct _VectorArgs { flatbuffers::FlatBufferBuilder *__fbb; const AnimationDataT* __o; const flatbuffers::rehasher_function_t *__rehasher; } _va = { &_fbb, _o, _rehasher}; (void)_va;
  auto _name = _o->name.empty() ? 0 : _fbb.CreateString(_o->name);
  auto _defaultData = _o->defaultData.size() ? _fbb.CreateVector<flatbuffers::Offset<AnimationInitialData>> (_o->defaultData.size(), [](size_t i, _VectorArgs *__va) { return CreateAnimationInitialData(*__va->__fbb, __va->__o->defaultData[i].get(), __va->__rehasher); }, &_va ) : 0;
  auto _frameData = _o->frameData.size() ? _fbb.CreateVector<flatbuffers::Offset<frameDataIndex>> (_o->frameData.size(), [](size_t i, _VectorArgs *__va) { return CreateframeDataIndex(*__va->__fbb, __va->__o->frameData[i].get(), __va->__rehasher); }, &_va ) : 0;
  auto _userData = _o->userData.size() ? _fbb.CreateVector<flatbuffers::Offset<userDataPerFrame>> (_o->userData.size(), [](size_t i, _VectorArgs *__va) { return CreateuserDataPerFrame(*__va->__fbb, __va->__o->userData[i].get(), __va->__rehasher); }, &_va ) : 0;
  auto _labelData = _o->labelData.size() ? _fbb.CreateVector<flatbuffers::Offset<labelDataItem>> (_o->labelData.size(), [](size_t i, _VectorArgs *__va) { return CreatelabelDataItem(*__va->__fbb, __va->__o->labelData[i].get(), __va->__rehasher); }, &_va ) : 0;
  auto _meshsDataUV = _o->meshsDataUV.size() ? _fbb.CreateVector<flatbuffers::Offset<meshDataUV>> (_o->meshsDataUV.size(), [](size_t i, _VectorArgs *__va) { return CreatemeshDataUV(*__va->__fbb, __va->__o->meshsDataUV[i].get(), __va->__rehasher); }, &_va ) : 0;
  auto _meshsDataIndices = _o->meshsDataIndices.size() ? _fbb.CreateVector<flatbuffers::Offset<meshDataIndices>> (_o->meshsDataIndices.size(), [](size_t i, _VectorArgs *__va) { return CreatemeshDataIndices(*__va->__fbb, __va->__o->meshsDataIndices[i].get(), __va->__rehasher); }, &_va ) : 0;
  auto _startFrames = _o->startFrames;
  auto _endFrames = _o->endFrames;
  auto _totalFrames = _o->totalFrames;
  auto _fps = _o->fps;
  auto _labelNum = _o->labelNum;
  auto _canvasSizeW = _o->canvasSizeW;
  auto _canvasSizeH = _o->canvasSizeH;
  auto _canvasPvotX = _o->canvasPvotX;
  auto _canvasPvotY = _o->canvasPvotY;
  return ss::ssfb::CreateAnimationData(
      _fbb,
      _name,
      _defaultData,
      _frameData,
      _userData,
      _labelData,
      _meshsDataUV,
      _meshsDataIndices,
      _startFrames,
      _endFrames,
      _totalFrames,
      _fps,
      _labelNum,
      _canvasSizeW,
      _canvasSizeH,
      _canvasPvotX,
      _canvasPvotY);
}

inline AnimationInitialDataT *AnimationInitialData::UnPack(const flatbuffers::resolver_function_t *_resolver) const {
  auto _o = new AnimationInitialDataT();
  UnPackTo(_o, _resolver);
  return _o;
}

inline void AnimationInitialData::UnPackTo(AnimationInitialDataT *_o, const flatbuffers::resolver_function_t *_resolver) const {
  (void)_o;
  (void)_resolver;
  { auto _e = index(); _o->index = _e; };
  { auto _e = lowflag(); _o->lowflag = _e; };
  { auto _e = highflag(); _o->highflag = _e; };
  { auto _e = priority(); _o->priority = _e; };
  { auto _e = cellIndex(); _o->cellIndex = _e; };
  { auto _e = opacity(); _o->opacity = _e; };
  { auto _e = localopacity(); _o->localopacity = _e; };
  { auto _e = masklimen(); _o->masklimen = _e; };
  { auto _e = positionX(); _o->positionX = _e; };
  { auto _e = positionY(); _o->positionY = _e; };
  { auto _e = positionZ(); _o->positionZ = _e; };
  { auto _e = pivotX(); _o->pivotX = _e; };
  { auto _e = pivotY(); _o->pivotY = _e; };
  { auto _e = rotationX(); _o->rotationX = _e; };
  { auto _e = rotationY(); _o->rotationY = _e; };
  { auto _e = rotationZ(); _o->rotationZ = _e; };
  { auto _e = scaleX(); _o->scaleX = _e; };
  { auto _e = scaleY(); _o->scaleY = _e; };
  { auto _e = localscaleX(); _o->localscaleX = _e; };
  { auto _e = localscaleY(); _o->localscaleY = _e; };
  { auto _e = size_X(); _o->size_X = _e; };
  { auto _e = size_Y(); _o->size_Y = _e; };
  { auto _e = uv_move_X(); _o->uv_move_X = _e; };
  { auto _e = uv_move_Y(); _o->uv_move_Y = _e; };
  { auto _e = uv_rotation(); _o->uv_rotation = _e; };
  { auto _e = uv_scale_X(); _o->uv_scale_X = _e; };
  { auto _e = uv_scale_Y(); _o->uv_scale_Y = _e; };
  { auto _e = boundingRadius(); _o->boundingRadius = _e; };
  { auto _e = instanceValue_curKeyframe(); _o->instanceValue_curKeyframe = _e; };
  { auto _e = instanceValue_startFrame(); _o->instanceValue_startFrame = _e; };
  { auto _e = instanceValue_endFrame(); _o->instanceValue_endFrame = _e; };
  { auto _e = instanceValue_loopNum(); _o->instanceValue_loopNum = _e; };
  { auto _e = instanceValue_speed(); _o->instanceValue_speed = _e; };
  { auto _e = instanceValue_loopflag(); _o->instanceValue_loopflag = _e; };
  { auto _e = effectValue_curKeyframe(); _o->effectValue_curKeyframe = _e; };
  { auto _e = effectValue_startTime(); _o->effectValue_startTime = _e; };
  { auto _e = effectValue_speed(); _o->effectValue_speed = _e; };
  { auto _e = effectValue_loopflag(); _o->effectValue_loopflag = _e; };
}

inline flatbuffers::Offset<AnimationInitialData> AnimationInitialData::Pack(flatbuffers::FlatBufferBuilder &_fbb, const AnimationInitialDataT* _o, const flatbuffers::rehasher_function_t *_rehasher) {
  return CreateAnimationInitialData(_fbb, _o, _rehasher);
}

inline flatbuffers::Offset<AnimationInitialData> CreateAnimationInitialData(flatbuffers::FlatBufferBuilder &_fbb, const AnimationInitialDataT *_o, const flatbuffers::rehasher_function_t *_rehasher) {
  (void)_rehasher;
  (void)_o;
  struct _VectorArgs { flatbuffers::FlatBufferBuilder *__fbb; const AnimationInitialDataT* __o; const flatbuffers::rehasher_function_t *__rehasher; } _va = { &_fbb, _o, _rehasher}; (void)_va;
  auto _index = _o->index;
  auto _lowflag = _o->lowflag;
  auto _highflag = _o->highflag;
  auto _priority = _o->priority;
  auto _cellIndex = _o->cellIndex;
  auto _opacity = _o->opacity;
  auto _localopacity = _o->localopacity;
  auto _masklimen = _o->masklimen;
  auto _positionX = _o->positionX;
  auto _positionY = _o->positionY;
  auto _positionZ = _o->positionZ;
  auto _pivotX = _o->pivotX;
  auto _pivotY = _o->pivotY;
  auto _rotationX = _o->rotationX;
  auto _rotationY = _o->rotationY;
  auto _rotationZ = _o->rotationZ;
  auto _scaleX = _o->scaleX;
  auto _scaleY = _o->scaleY;
  auto _localscaleX = _o->localscaleX;
  auto _localscaleY = _o->localscaleY;
  auto _size_X = _o->size_X;
  auto _size_Y = _o->size_Y;
  auto _uv_move_X = _o->uv_move_X;
  auto _uv_move_Y = _o->uv_move_Y;
  auto _uv_rotation = _o->uv_rotation;
  auto _uv_scale_X = _o->uv_scale_X;
  auto _uv_scale_Y = _o->uv_scale_Y;
  auto _boundingRadius = _o->boundingRadius;
  auto _instanceValue_curKeyframe = _o->instanceValue_curKeyframe;
  auto _instanceValue_startFrame = _o->instanceValue_startFrame;
  auto _instanceValue_endFrame = _o->instanceValue_endFrame;
  auto _instanceValue_loopNum = _o->instanceValue_loopNum;
  auto _instanceValue_speed = _o->instanceValue_speed;
  auto _instanceValue_loopflag = _o->instanceValue_loopflag;
  auto _effectValue_curKeyframe = _o->effectValue_curKeyframe;
  auto _effectValue_startTime = _o->effectValue_startTime;
  auto _effectValue_speed = _o->effectValue_speed;
  auto _effectValue_loopflag = _o->effectValue_loopflag;
  return ss::ssfb::CreateAnimationInitialData(
      _fbb,
      _index,
      _lowflag,
      _highflag,
      _priority,
      _cellIndex,
      _opacity,
      _localopacity,
      _masklimen,
      _positionX,
      _positionY,
      _positionZ,
      _pivotX,
      _pivotY,
      _rotationX,
      _rotationY,
      _rotationZ,
      _scaleX,
      _scaleY,
      _localscaleX,
      _localscaleY,
      _size_X,
      _size_Y,
      _uv_move_X,
      _uv_move_Y,
      _uv_rotation,
      _uv_scale_X,
      _uv_scale_Y,
      _boundingRadius,
      _instanceValue_curKeyframe,
      _instanceValue_startFrame,
      _instanceValue_endFrame,
      _instanceValue_loopNum,
      _instanceValue_speed,
      _instanceValue_loopflag,
      _effectValue_curKeyframe,
      _effectValue_startTime,
      _effectValue_speed,
      _effectValue_loopflag);
}

inline PartDataT *PartData::UnPack(const flatbuffers::resolver_function_t *_resolver) const {
  auto _o = new PartDataT();
  UnPackTo(_o, _resolver);
  return _o;
}

inline void PartData::UnPackTo(PartDataT *_o, const flatbuffers::resolver_function_t *_resolver) const {
  (void)_o;
  (void)_resolver;
  { auto _e = name(); if (_e) _o->name = _e->str(); };
  { auto _e = index(); _o->index = _e; };
  { auto _e = parentIndex(); _o->parentIndex = _e; };
  { auto _e = type(); _o->type = _e; };
  { auto _e = boundsType(); _o->boundsType = _e; };
  { auto _e = alphaBlendType(); _o->alphaBlendType = _e; };
  { auto _e = refname(); if (_e) _o->refname = _e->str(); };
  { auto _e = effectfilename(); if (_e) _o->effectfilename = _e->str(); };
  { auto _e = colorLabel(); if (_e) _o->colorLabel = _e->str(); };
  { auto _e = maskInfluence(); _o->maskInfluence = _e; };
}

inline flatbuffers::Offset<PartData> PartData::Pack(flatbuffers::FlatBufferBuilder &_fbb, const PartDataT* _o, const flatbuffers::rehasher_function_t *_rehasher) {
  return CreatePartData(_fbb, _o, _rehasher);
}

inline flatbuffers::Offset<PartData> CreatePartData(flatbuffers::FlatBufferBuilder &_fbb, const PartDataT *_o, const flatbuffers::rehasher_function_t *_rehasher) {
  (void)_rehasher;
  (void)_o;
  struct _VectorArgs { flatbuffers::FlatBufferBuilder *__fbb; const PartDataT* __o; const flatbuffers::rehasher_function_t *__rehasher; } _va = { &_fbb, _o, _rehasher}; (void)_va;
  auto _name = _o->name.empty() ? 0 : _fbb.CreateString(_o->name);
  auto _index = _o->index;
  auto _parentIndex = _o->parentIndex;
  auto _type = _o->type;
  auto _boundsType = _o->boundsType;
  auto _alphaBlendType = _o->alphaBlendType;
  auto _refname = _o->refname.empty() ? 0 : _fbb.CreateString(_o->refname);
  auto _effectfilename = _o->effectfilename.empty() ? 0 : _fbb.CreateString(_o->effectfilename);
  auto _colorLabel = _o->colorLabel.empty() ? 0 : _fbb.CreateString(_o->colorLabel);
  auto _maskInfluence = _o->maskInfluence;
  return ss::ssfb::CreatePartData(
      _fbb,
      _name,
      _index,
      _parentIndex,
      _type,
      _boundsType,
      _alphaBlendType,
      _refname,
      _effectfilename,
      _colorLabel,
      _maskInfluence);
}

inline AnimePackDataT *AnimePackData::UnPack(const flatbuffers::resolver_function_t *_resolver) const {
  auto _o = new AnimePackDataT();
  UnPackTo(_o, _resolver);
  return _o;
}

inline void AnimePackData::UnPackTo(AnimePackDataT *_o, const flatbuffers::resolver_function_t *_resolver) const {
  (void)_o;
  (void)_resolver;
  { auto _e = name(); if (_e) _o->name = _e->str(); };
  { auto _e = parts(); if (_e) { _o->parts.resize(_e->size()); for (flatbuffers::uoffset_t _i = 0; _i < _e->size(); _i++) { _o->parts[_i] = std::unique_ptr<PartDataT>(_e->Get(_i)->UnPack(_resolver)); } } };
  { auto _e = animations(); if (_e) { _o->animations.resize(_e->size()); for (flatbuffers::uoffset_t _i = 0; _i < _e->size(); _i++) { _o->animations[_i] = std::unique_ptr<AnimationDataT>(_e->Get(_i)->UnPack(_resolver)); } } };
}

inline flatbuffers::Offset<AnimePackData> AnimePackData::Pack(flatbuffers::FlatBufferBuilder &_fbb, const AnimePackDataT* _o, const flatbuffers::rehasher_function_t *_rehasher) {
  return CreateAnimePackData(_fbb, _o, _rehasher);
}

inline flatbuffers::Offset<AnimePackData> CreateAnimePackData(flatbuffers::FlatBufferBuilder &_fbb, const AnimePackDataT *_o, const flatbuffers::rehasher_function_t *_rehasher) {
  (void)_rehasher;
  (void)_o;
  struct _VectorArgs { flatbuffers::FlatBufferBuilder *__fbb; const AnimePackDataT* __o; const flatbuffers::rehasher_function_t *__rehasher; } _va = { &_fbb, _o, _rehasher}; (void)_va;
  auto _name = _o->name.empty() ? 0 : _fbb.CreateString(_o->name);
  auto _parts = _o->parts.size() ? _fbb.CreateVector<flatbuffers::Offset<PartData>> (_o->parts.size(), [](size_t i, _VectorArgs *__va) { return CreatePartData(*__va->__fbb, __va->__o->parts[i].get(), __va->__rehasher); }, &_va ) : 0;
  auto _animations = _o->animations.size() ? _fbb.CreateVector<flatbuffers::Offset<AnimationData>> (_o->animations.size(), [](size_t i, _VectorArgs *__va) { return CreateAnimationData(*__va->__fbb, __va->__o->animations[i].get(), __va->__rehasher); }, &_va ) : 0;
  return ss::ssfb::CreateAnimePackData(
      _fbb,
      _name,
      _parts,
      _animations);
}

inline ProjectDataT *ProjectData::UnPack(const flatbuffers::resolver_function_t *_resolver) const {
  auto _o = new ProjectDataT();
  UnPackTo(_o, _resolver);
  return _o;
}

inline void ProjectData::UnPackTo(ProjectDataT *_o, const flatbuffers::resolver_function_t *_resolver) const {
  (void)_o;
  (void)_resolver;
  { auto _e = dataId(); _o->dataId = _e; };
  { auto _e = version(); _o->version = _e; };
  { auto _e = flags(); _o->flags = _e; };
  { auto _e = imageBaseDir(); if (_e) _o->imageBaseDir = _e->str(); };
  { auto _e = cells(); if (_e) { _o->cells.resize(_e->size()); for (flatbuffers::uoffset_t _i = 0; _i < _e->size(); _i++) { _o->cells[_i] = std::unique_ptr<CellT>(_e->Get(_i)->UnPack(_resolver)); } } };
  { auto _e = animePacks(); if (_e) { _o->animePacks.resize(_e->size()); for (flatbuffers::uoffset_t _i = 0; _i < _e->size(); _i++) { _o->animePacks[_i] = std::unique_ptr<AnimePackDataT>(_e->Get(_i)->UnPack(_resolver)); } } };
  { auto _e = effectFileList(); if (_e) { _o->effectFileList.resize(_e->size()); for (flatbuffers::uoffset_t _i = 0; _i < _e->size(); _i++) { _o->effectFileList[_i] = std::unique_ptr<EffectFileT>(_e->Get(_i)->UnPack(_resolver)); } } };
  { auto _e = numCells(); _o->numCells = _e; };
  { auto _e = numAnimePacks(); _o->numAnimePacks = _e; };
  { auto _e = numEffectFileList(); _o->numEffectFileList = _e; };
}

inline flatbuffers::Offset<ProjectData> ProjectData::Pack(flatbuffers::FlatBufferBuilder &_fbb, const ProjectDataT* _o, const flatbuffers::rehasher_function_t *_rehasher) {
  return CreateProjectData(_fbb, _o, _rehasher);
}

inline flatbuffers::Offset<ProjectData> CreateProjectData(flatbuffers::FlatBufferBuilder &_fbb, const ProjectDataT *_o, const flatbuffers::rehasher_function_t *_rehasher) {
  (void)_rehasher;
  (void)_o;
  struct _VectorArgs { flatbuffers::FlatBufferBuilder *__fbb; const ProjectDataT* __o; const flatbuffers::rehasher_function_t *__rehasher; } _va = { &_fbb, _o, _rehasher}; (void)_va;
  auto _dataId = _o->dataId;
  auto _version = _o->version;
  auto _flags = _o->flags;
  auto _imageBaseDir = _o->imageBaseDir.empty() ? 0 : _fbb.CreateString(_o->imageBaseDir);
  auto _cells = _o->cells.size() ? _fbb.CreateVector<flatbuffers::Offset<Cell>> (_o->cells.size(), [](size_t i, _VectorArgs *__va) { return CreateCell(*__va->__fbb, __va->__o->cells[i].get(), __va->__rehasher); }, &_va ) : 0;
  auto _animePacks = _o->animePacks.size() ? _fbb.CreateVector<flatbuffers::Offset<AnimePackData>> (_o->animePacks.size(), [](size_t i, _VectorArgs *__va) { return CreateAnimePackData(*__va->__fbb, __va->__o->animePacks[i].get(), __va->__rehasher); }, &_va ) : 0;
  auto _effectFileList = _o->effectFileList.size() ? _fbb.CreateVector<flatbuffers::Offset<EffectFile>> (_o->effectFileList.size(), [](size_t i, _VectorArgs *__va) { return CreateEffectFile(*__va->__fbb, __va->__o->effectFileList[i].get(), __va->__rehasher); }, &_va ) : 0;
  auto _numCells = _o->numCells;
  auto _numAnimePacks = _o->numAnimePacks;
  auto _numEffectFileList = _o->numEffectFileList;
  return ss::ssfb::CreateProjectData(
      _fbb,
      _dataId,
      _version,
      _flags,
      _imageBaseDir,
      _cells,
      _animePacks,
      _effectFileList,
      _numCells,
      _numAnimePacks,
      _numEffectFileList);
}

inline bool VerifyEffectNodeBehavior(flatbuffers::Verifier &verifier, const void *obj, EffectNodeBehavior type) {
  switch (type) {
    case EffectNodeBehavior_NONE: {
      return true;
    }
    case EffectNodeBehavior_EffectParticleElementBasic: {
      return true;
    }
    case EffectNodeBehavior_EffectParticleElementRndSeedChange: {
      return true;
    }
    case EffectNodeBehavior_EffectParticleElementDelay: {
      return true;
    }
    case EffectNodeBehavior_EffectParticleElementGravity: {
      return true;
    }
    case EffectNodeBehavior_EffectParticleElementPosition: {
      return true;
    }
    case EffectNodeBehavior_EffectParticleElementRotation: {
      return true;
    }
    case EffectNodeBehavior_EffectParticleElementRotationTrans: {
      return true;
    }
    case EffectNodeBehavior_EffectParticleElementTransSpeed: {
      return true;
    }
    case EffectNodeBehavior_EffectParticleElementTangentialAcceleration: {
      return true;
    }
    case EffectNodeBehavior_EffectParticleElementInitColor: {
      return true;
    }
    case EffectNodeBehavior_EffectParticleElementTransColor: {
      return true;
    }
    case EffectNodeBehavior_EffectParticleElementAlphaFade: {
      return true;
    }
    case EffectNodeBehavior_EffectParticleElementSize: {
      return true;
    }
    case EffectNodeBehavior_EffectParticleElementTransSize: {
      return true;
    }
    case EffectNodeBehavior_EffectParticlePointGravity: {
      return true;
    }
    case EffectNodeBehavior_EffectParticleTurnToDirectionEnabled: {
      return true;
    }
    case EffectNodeBehavior_EffectParticleInfiniteEmitEnabled: {
      return true;
    }
    default: return false;
  }
}

inline bool VerifyEffectNodeBehaviorVector(flatbuffers::Verifier &verifier, const flatbuffers::Vector<flatbuffers::Offset<void>> *values, const flatbuffers::Vector<uint8_t> *types) {
  if (!values || !types) return !values && !types;
  if (values->size() != types->size()) return false;
  for (flatbuffers::uoffset_t i = 0; i < values->size(); ++i) {
    if (!VerifyEffectNodeBehavior(
        verifier,  values->Get(i), types->GetEnum<EffectNodeBehavior>(i))) {
      return false;
    }
  }
  return true;
}

inline void *EffectNodeBehaviorUnion::UnPack(const void *obj, EffectNodeBehavior type, const flatbuffers::resolver_function_t *resolver) {
  switch (type) {
    case EffectNodeBehavior_EffectParticleElementBasic: {
      auto ptr = reinterpret_cast<const EffectParticleElementBasic *>(obj);
      return new EffectParticleElementBasic(*ptr);
    }
    case EffectNodeBehavior_EffectParticleElementRndSeedChange: {
      auto ptr = reinterpret_cast<const EffectParticleElementRndSeedChange *>(obj);
      return new EffectParticleElementRndSeedChange(*ptr);
    }
    case EffectNodeBehavior_EffectParticleElementDelay: {
      auto ptr = reinterpret_cast<const EffectParticleElementDelay *>(obj);
      return new EffectParticleElementDelay(*ptr);
    }
    case EffectNodeBehavior_EffectParticleElementGravity: {
      auto ptr = reinterpret_cast<const EffectParticleElementGravity *>(obj);
      return new EffectParticleElementGravity(*ptr);
    }
    case EffectNodeBehavior_EffectParticleElementPosition: {
      auto ptr = reinterpret_cast<const EffectParticleElementPosition *>(obj);
      return new EffectParticleElementPosition(*ptr);
    }
    case EffectNodeBehavior_EffectParticleElementRotation: {
      auto ptr = reinterpret_cast<const EffectParticleElementRotation *>(obj);
      return new EffectParticleElementRotation(*ptr);
    }
    case EffectNodeBehavior_EffectParticleElementRotationTrans: {
      auto ptr = reinterpret_cast<const EffectParticleElementRotationTrans *>(obj);
      return new EffectParticleElementRotationTrans(*ptr);
    }
    case EffectNodeBehavior_EffectParticleElementTransSpeed: {
      auto ptr = reinterpret_cast<const EffectParticleElementTransSpeed *>(obj);
      return new EffectParticleElementTransSpeed(*ptr);
    }
    case EffectNodeBehavior_EffectParticleElementTangentialAcceleration: {
      auto ptr = reinterpret_cast<const EffectParticleElementTangentialAcceleration *>(obj);
      return new EffectParticleElementTangentialAcceleration(*ptr);
    }
    case EffectNodeBehavior_EffectParticleElementInitColor: {
      auto ptr = reinterpret_cast<const EffectParticleElementInitColor *>(obj);
      return new EffectParticleElementInitColor(*ptr);
    }
    case EffectNodeBehavior_EffectParticleElementTransColor: {
      auto ptr = reinterpret_cast<const EffectParticleElementTransColor *>(obj);
      return new EffectParticleElementTransColor(*ptr);
    }
    case EffectNodeBehavior_EffectParticleElementAlphaFade: {
      auto ptr = reinterpret_cast<const EffectParticleElementAlphaFade *>(obj);
      return new EffectParticleElementAlphaFade(*ptr);
    }
    case EffectNodeBehavior_EffectParticleElementSize: {
      auto ptr = reinterpret_cast<const EffectParticleElementSize *>(obj);
      return new EffectParticleElementSize(*ptr);
    }
    case EffectNodeBehavior_EffectParticleElementTransSize: {
      auto ptr = reinterpret_cast<const EffectParticleElementTransSize *>(obj);
      return new EffectParticleElementTransSize(*ptr);
    }
    case EffectNodeBehavior_EffectParticlePointGravity: {
      auto ptr = reinterpret_cast<const EffectParticlePointGravity *>(obj);
      return new EffectParticlePointGravity(*ptr);
    }
    case EffectNodeBehavior_EffectParticleTurnToDirectionEnabled: {
      auto ptr = reinterpret_cast<const EffectParticleTurnToDirectionEnabled *>(obj);
      return new EffectParticleTurnToDirectionEnabled(*ptr);
    }
    case EffectNodeBehavior_EffectParticleInfiniteEmitEnabled: {
      auto ptr = reinterpret_cast<const EffectParticleInfiniteEmitEnabled *>(obj);
      return new EffectParticleInfiniteEmitEnabled(*ptr);
    }
    default: return nullptr;
  }
}

inline flatbuffers::Offset<void> EffectNodeBehaviorUnion::Pack(flatbuffers::FlatBufferBuilder &_fbb, const flatbuffers::rehasher_function_t *_rehasher) const {
  switch (type) {
    case EffectNodeBehavior_EffectParticleElementBasic: {
      auto ptr = reinterpret_cast<const EffectParticleElementBasic *>(value);
      return _fbb.CreateStruct(*ptr).Union();
    }
    case EffectNodeBehavior_EffectParticleElementRndSeedChange: {
      auto ptr = reinterpret_cast<const EffectParticleElementRndSeedChange *>(value);
      return _fbb.CreateStruct(*ptr).Union();
    }
    case EffectNodeBehavior_EffectParticleElementDelay: {
      auto ptr = reinterpret_cast<const EffectParticleElementDelay *>(value);
      return _fbb.CreateStruct(*ptr).Union();
    }
    case EffectNodeBehavior_EffectParticleElementGravity: {
      auto ptr = reinterpret_cast<const EffectParticleElementGravity *>(value);
      return _fbb.CreateStruct(*ptr).Union();
    }
    case EffectNodeBehavior_EffectParticleElementPosition: {
      auto ptr = reinterpret_cast<const EffectParticleElementPosition *>(value);
      return _fbb.CreateStruct(*ptr).Union();
    }
    case EffectNodeBehavior_EffectParticleElementRotation: {
      auto ptr = reinterpret_cast<const EffectParticleElementRotation *>(value);
      return _fbb.CreateStruct(*ptr).Union();
    }
    case EffectNodeBehavior_EffectParticleElementRotationTrans: {
      auto ptr = reinterpret_cast<const EffectParticleElementRotationTrans *>(value);
      return _fbb.CreateStruct(*ptr).Union();
    }
    case EffectNodeBehavior_EffectParticleElementTransSpeed: {
      auto ptr = reinterpret_cast<const EffectParticleElementTransSpeed *>(value);
      return _fbb.CreateStruct(*ptr).Union();
    }
    case EffectNodeBehavior_EffectParticleElementTangentialAcceleration: {
      auto ptr = reinterpret_cast<const EffectParticleElementTangentialAcceleration *>(value);
      return _fbb.CreateStruct(*ptr).Union();
    }
    case EffectNodeBehavior_EffectParticleElementInitColor: {
      auto ptr = reinterpret_cast<const EffectParticleElementInitColor *>(value);
      return _fbb.CreateStruct(*ptr).Union();
    }
    case EffectNodeBehavior_EffectParticleElementTransColor: {
      auto ptr = reinterpret_cast<const EffectParticleElementTransColor *>(value);
      return _fbb.CreateStruct(*ptr).Union();
    }
    case EffectNodeBehavior_EffectParticleElementAlphaFade: {
      auto ptr = reinterpret_cast<const EffectParticleElementAlphaFade *>(value);
      return _fbb.CreateStruct(*ptr).Union();
    }
    case EffectNodeBehavior_EffectParticleElementSize: {
      auto ptr = reinterpret_cast<const EffectParticleElementSize *>(value);
      return _fbb.CreateStruct(*ptr).Union();
    }
    case EffectNodeBehavior_EffectParticleElementTransSize: {
      auto ptr = reinterpret_cast<const EffectParticleElementTransSize *>(value);
      return _fbb.CreateStruct(*ptr).Union();
    }
    case EffectNodeBehavior_EffectParticlePointGravity: {
      auto ptr = reinterpret_cast<const EffectParticlePointGravity *>(value);
      return _fbb.CreateStruct(*ptr).Union();
    }
    case EffectNodeBehavior_EffectParticleTurnToDirectionEnabled: {
      auto ptr = reinterpret_cast<const EffectParticleTurnToDirectionEnabled *>(value);
      return _fbb.CreateStruct(*ptr).Union();
    }
    case EffectNodeBehavior_EffectParticleInfiniteEmitEnabled: {
      auto ptr = reinterpret_cast<const EffectParticleInfiniteEmitEnabled *>(value);
      return _fbb.CreateStruct(*ptr).Union();
    }
    default: return 0;
  }
}

inline EffectNodeBehaviorUnion::EffectNodeBehaviorUnion(const EffectNodeBehaviorUnion &u) FLATBUFFERS_NOEXCEPT : type(u.type), value(nullptr) {
  switch (type) {
    case EffectNodeBehavior_EffectParticleElementBasic: {
      value = new EffectParticleElementBasic(*reinterpret_cast<EffectParticleElementBasic *>(u.value));
      break;
    }
    case EffectNodeBehavior_EffectParticleElementRndSeedChange: {
      value = new EffectParticleElementRndSeedChange(*reinterpret_cast<EffectParticleElementRndSeedChange *>(u.value));
      break;
    }
    case EffectNodeBehavior_EffectParticleElementDelay: {
      value = new EffectParticleElementDelay(*reinterpret_cast<EffectParticleElementDelay *>(u.value));
      break;
    }
    case EffectNodeBehavior_EffectParticleElementGravity: {
      value = new EffectParticleElementGravity(*reinterpret_cast<EffectParticleElementGravity *>(u.value));
      break;
    }
    case EffectNodeBehavior_EffectParticleElementPosition: {
      value = new EffectParticleElementPosition(*reinterpret_cast<EffectParticleElementPosition *>(u.value));
      break;
    }
    case EffectNodeBehavior_EffectParticleElementRotation: {
      value = new EffectParticleElementRotation(*reinterpret_cast<EffectParticleElementRotation *>(u.value));
      break;
    }
    case EffectNodeBehavior_EffectParticleElementRotationTrans: {
      value = new EffectParticleElementRotationTrans(*reinterpret_cast<EffectParticleElementRotationTrans *>(u.value));
      break;
    }
    case EffectNodeBehavior_EffectParticleElementTransSpeed: {
      value = new EffectParticleElementTransSpeed(*reinterpret_cast<EffectParticleElementTransSpeed *>(u.value));
      break;
    }
    case EffectNodeBehavior_EffectParticleElementTangentialAcceleration: {
      value = new EffectParticleElementTangentialAcceleration(*reinterpret_cast<EffectParticleElementTangentialAcceleration *>(u.value));
      break;
    }
    case EffectNodeBehavior_EffectParticleElementInitColor: {
      value = new EffectParticleElementInitColor(*reinterpret_cast<EffectParticleElementInitColor *>(u.value));
      break;
    }
    case EffectNodeBehavior_EffectParticleElementTransColor: {
      value = new EffectParticleElementTransColor(*reinterpret_cast<EffectParticleElementTransColor *>(u.value));
      break;
    }
    case EffectNodeBehavior_EffectParticleElementAlphaFade: {
      value = new EffectParticleElementAlphaFade(*reinterpret_cast<EffectParticleElementAlphaFade *>(u.value));
      break;
    }
    case EffectNodeBehavior_EffectParticleElementSize: {
      value = new EffectParticleElementSize(*reinterpret_cast<EffectParticleElementSize *>(u.value));
      break;
    }
    case EffectNodeBehavior_EffectParticleElementTransSize: {
      value = new EffectParticleElementTransSize(*reinterpret_cast<EffectParticleElementTransSize *>(u.value));
      break;
    }
    case EffectNodeBehavior_EffectParticlePointGravity: {
      value = new EffectParticlePointGravity(*reinterpret_cast<EffectParticlePointGravity *>(u.value));
      break;
    }
    case EffectNodeBehavior_EffectParticleTurnToDirectionEnabled: {
      value = new EffectParticleTurnToDirectionEnabled(*reinterpret_cast<EffectParticleTurnToDirectionEnabled *>(u.value));
      break;
    }
    case EffectNodeBehavior_EffectParticleInfiniteEmitEnabled: {
      value = new EffectParticleInfiniteEmitEnabled(*reinterpret_cast<EffectParticleInfiniteEmitEnabled *>(u.value));
      break;
    }
    default:
      break;
  }
}

inline void EffectNodeBehaviorUnion::Reset() {
  switch (type) {
    case EffectNodeBehavior_EffectParticleElementBasic: {
      auto ptr = reinterpret_cast<EffectParticleElementBasic *>(value);
      delete ptr;
      break;
    }
    case EffectNodeBehavior_EffectParticleElementRndSeedChange: {
      auto ptr = reinterpret_cast<EffectParticleElementRndSeedChange *>(value);
      delete ptr;
      break;
    }
    case EffectNodeBehavior_EffectParticleElementDelay: {
      auto ptr = reinterpret_cast<EffectParticleElementDelay *>(value);
      delete ptr;
      break;
    }
    case EffectNodeBehavior_EffectParticleElementGravity: {
      auto ptr = reinterpret_cast<EffectParticleElementGravity *>(value);
      delete ptr;
      break;
    }
    case EffectNodeBehavior_EffectParticleElementPosition: {
      auto ptr = reinterpret_cast<EffectParticleElementPosition *>(value);
      delete ptr;
      break;
    }
    case EffectNodeBehavior_EffectParticleElementRotation: {
      auto ptr = reinterpret_cast<EffectParticleElementRotation *>(value);
      delete ptr;
      break;
    }
    case EffectNodeBehavior_EffectParticleElementRotationTrans: {
      auto ptr = reinterpret_cast<EffectParticleElementRotationTrans *>(value);
      delete ptr;
      break;
    }
    case EffectNodeBehavior_EffectParticleElementTransSpeed: {
      auto ptr = reinterpret_cast<EffectParticleElementTransSpeed *>(value);
      delete ptr;
      break;
    }
    case EffectNodeBehavior_EffectParticleElementTangentialAcceleration: {
      auto ptr = reinterpret_cast<EffectParticleElementTangentialAcceleration *>(value);
      delete ptr;
      break;
    }
    case EffectNodeBehavior_EffectParticleElementInitColor: {
      auto ptr = reinterpret_cast<EffectParticleElementInitColor *>(value);
      delete ptr;
      break;
    }
    case EffectNodeBehavior_EffectParticleElementTransColor: {
      auto ptr = reinterpret_cast<EffectParticleElementTransColor *>(value);
      delete ptr;
      break;
    }
    case EffectNodeBehavior_EffectParticleElementAlphaFade: {
      auto ptr = reinterpret_cast<EffectParticleElementAlphaFade *>(value);
      delete ptr;
      break;
    }
    case EffectNodeBehavior_EffectParticleElementSize: {
      auto ptr = reinterpret_cast<EffectParticleElementSize *>(value);
      delete ptr;
      break;
    }
    case EffectNodeBehavior_EffectParticleElementTransSize: {
      auto ptr = reinterpret_cast<EffectParticleElementTransSize *>(value);
      delete ptr;
      break;
    }
    case EffectNodeBehavior_EffectParticlePointGravity: {
      auto ptr = reinterpret_cast<EffectParticlePointGravity *>(value);
      delete ptr;
      break;
    }
    case EffectNodeBehavior_EffectParticleTurnToDirectionEnabled: {
      auto ptr = reinterpret_cast<EffectParticleTurnToDirectionEnabled *>(value);
      delete ptr;
      break;
    }
    case EffectNodeBehavior_EffectParticleInfiniteEmitEnabled: {
      auto ptr = reinterpret_cast<EffectParticleInfiniteEmitEnabled *>(value);
      delete ptr;
      break;
    }
    default: break;
  }
  value = nullptr;
  type = EffectNodeBehavior_NONE;
}

inline bool VerifyuserDataValue(flatbuffers::Verifier &verifier, const void *obj, userDataValue type) {
  switch (type) {
    case userDataValue_NONE: {
      return true;
    }
    case userDataValue_userDataInteger: {
      return true;
    }
    case userDataValue_userDataRect: {
      return true;
    }
    case userDataValue_userDataPoint: {
      return true;
    }
    case userDataValue_userDataString: {
      auto ptr = reinterpret_cast<const userDataString *>(obj);
      return verifier.VerifyTable(ptr);
    }
    default: return false;
  }
}

inline bool VerifyuserDataValueVector(flatbuffers::Verifier &verifier, const flatbuffers::Vector<flatbuffers::Offset<void>> *values, const flatbuffers::Vector<uint8_t> *types) {
  if (!values || !types) return !values && !types;
  if (values->size() != types->size()) return false;
  for (flatbuffers::uoffset_t i = 0; i < values->size(); ++i) {
    if (!VerifyuserDataValue(
        verifier,  values->Get(i), types->GetEnum<userDataValue>(i))) {
      return false;
    }
  }
  return true;
}

inline void *userDataValueUnion::UnPack(const void *obj, userDataValue type, const flatbuffers::resolver_function_t *resolver) {
  switch (type) {
    case userDataValue_userDataInteger: {
      auto ptr = reinterpret_cast<const userDataInteger *>(obj);
      return new userDataInteger(*ptr);
    }
    case userDataValue_userDataRect: {
      auto ptr = reinterpret_cast<const userDataRect *>(obj);
      return new userDataRect(*ptr);
    }
    case userDataValue_userDataPoint: {
      auto ptr = reinterpret_cast<const userDataPoint *>(obj);
      return new userDataPoint(*ptr);
    }
    case userDataValue_userDataString: {
      auto ptr = reinterpret_cast<const userDataString *>(obj);
      return ptr->UnPack(resolver);
    }
    default: return nullptr;
  }
}

inline flatbuffers::Offset<void> userDataValueUnion::Pack(flatbuffers::FlatBufferBuilder &_fbb, const flatbuffers::rehasher_function_t *_rehasher) const {
  switch (type) {
    case userDataValue_userDataInteger: {
      auto ptr = reinterpret_cast<const userDataInteger *>(value);
      return _fbb.CreateStruct(*ptr).Union();
    }
    case userDataValue_userDataRect: {
      auto ptr = reinterpret_cast<const userDataRect *>(value);
      return _fbb.CreateStruct(*ptr).Union();
    }
    case userDataValue_userDataPoint: {
      auto ptr = reinterpret_cast<const userDataPoint *>(value);
      return _fbb.CreateStruct(*ptr).Union();
    }
    case userDataValue_userDataString: {
      auto ptr = reinterpret_cast<const userDataStringT *>(value);
      return CreateuserDataString(_fbb, ptr, _rehasher).Union();
    }
    default: return 0;
  }
}

inline userDataValueUnion::userDataValueUnion(const userDataValueUnion &u) FLATBUFFERS_NOEXCEPT : type(u.type), value(nullptr) {
  switch (type) {
    case userDataValue_userDataInteger: {
      value = new userDataInteger(*reinterpret_cast<userDataInteger *>(u.value));
      break;
    }
    case userDataValue_userDataRect: {
      value = new userDataRect(*reinterpret_cast<userDataRect *>(u.value));
      break;
    }
    case userDataValue_userDataPoint: {
      value = new userDataPoint(*reinterpret_cast<userDataPoint *>(u.value));
      break;
    }
    case userDataValue_userDataString: {
      value = new userDataStringT(*reinterpret_cast<userDataStringT *>(u.value));
      break;
    }
    default:
      break;
  }
}

inline void userDataValueUnion::Reset() {
  switch (type) {
    case userDataValue_userDataInteger: {
      auto ptr = reinterpret_cast<userDataInteger *>(value);
      delete ptr;
      break;
    }
    case userDataValue_userDataRect: {
      auto ptr = reinterpret_cast<userDataRect *>(value);
      delete ptr;
      break;
    }
    case userDataValue_userDataPoint: {
      auto ptr = reinterpret_cast<userDataPoint *>(value);
      delete ptr;
      break;
    }
    case userDataValue_userDataString: {
      auto ptr = reinterpret_cast<userDataStringT *>(value);
      delete ptr;
      break;
    }
    default: break;
  }
  value = nullptr;
  type = userDataValue_NONE;
}

inline const ss::ssfb::ProjectData *GetProjectData(const void *buf) {
  return flatbuffers::GetRoot<ss::ssfb::ProjectData>(buf);
}

inline const ss::ssfb::ProjectData *GetSizePrefixedProjectData(const void *buf) {
  return flatbuffers::GetSizePrefixedRoot<ss::ssfb::ProjectData>(buf);
}

inline const char *ProjectDataIdentifier() {
  return "SSFB";
}

inline bool ProjectDataBufferHasIdentifier(const void *buf) {
  return flatbuffers::BufferHasIdentifier(
      buf, ProjectDataIdentifier());
}

inline bool VerifyProjectDataBuffer(
    flatbuffers::Verifier &verifier) {
  return verifier.VerifyBuffer<ss::ssfb::ProjectData>(ProjectDataIdentifier());
}

inline bool VerifySizePrefixedProjectDataBuffer(
    flatbuffers::Verifier &verifier) {
  return verifier.VerifySizePrefixedBuffer<ss::ssfb::ProjectData>(ProjectDataIdentifier());
}

inline void FinishProjectDataBuffer(
    flatbuffers::FlatBufferBuilder &fbb,
    flatbuffers::Offset<ss::ssfb::ProjectData> root) {
  fbb.Finish(root, ProjectDataIdentifier());
}

inline void FinishSizePrefixedProjectDataBuffer(
    flatbuffers::FlatBufferBuilder &fbb,
    flatbuffers::Offset<ss::ssfb::ProjectData> root) {
  fbb.FinishSizePrefixed(root, ProjectDataIdentifier());
}

inline std::unique_ptr<ProjectDataT> UnPackProjectData(
    const void *buf,
    const flatbuffers::resolver_function_t *res = nullptr) {
  return std::unique_ptr<ProjectDataT>(GetProjectData(buf)->UnPack(res));
}

}  // namespace ssfb
}  // namespace ss

#endif  // FLATBUFFERS_GENERATED_SSFB_SS_SSFB_H_
