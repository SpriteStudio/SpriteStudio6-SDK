// automatically generated by the FlatBuffers compiler, do not modify


#ifndef FLATBUFFERS_GENERATED_SSFB_SS_SSFB_H_
#define FLATBUFFERS_GENERATED_SSFB_SS_SSFB_H_

#include "flatbuffers/flatbuffers.h"

namespace ss {
namespace ssfb {

struct EffectParticleInfiniteEmitEnabled;

struct EffectParticleTurnToDirectionEnabled;

struct EffectParticlePointGravity;

struct EffectParticleElementTransSize;

struct EffectParticleElementSize;

struct EffectParticleElementAlphaFade;

struct EffectParticleElementTransColor;

struct EffectParticleElementInitColor;

struct EffectParticleElementTangentialAcceleration;

struct EffectParticleElementTransSpeed;

struct EffectParticleElementRotationTrans;

struct EffectParticleElementRotation;

struct EffectParticleElementPosition;

struct EffectParticleElementGravity;

struct EffectParticleElementDelay;

struct EffectParticleElementRndSeedChange;

struct EffectParticleElementBasic;

struct EffectNode;

struct EffectFile;

struct CellMap;

struct Cell;

struct meshDataUVItem;

struct meshDataUVEmpty;

struct meshDataIndices;

struct frameDataIndex;

struct userDataInteger;

struct userDataRect;

struct userDataPoint;

struct userDataString;

struct userDataItem;

struct userDataPerFrame;

struct labelDataItem;

struct AnimationData;

struct AnimationInitialData;

struct PartData;

struct AnimePackData;

struct ProjectData;

enum SsPartType {
  SsPartType_Invalid = -1,
  SsPartType_Nulltype = 0,
  SsPartType_Normal = 1,
  SsPartType_Text = 2,
  SsPartType_Instance = 3,
  SsPartType_Armature = 4,
  SsPartType_Effect = 5,
  SsPartType_Mesh = 6,
  SsPartType_Movenode = 7,
  SsPartType_Constraint = 8,
  SsPartType_Mask = 9,
  SsPartType_Joint = 10,
  SsPartType_Bonepoint = 11,
  SsPartType_MIN = SsPartType_Invalid,
  SsPartType_MAX = SsPartType_Bonepoint
};

inline const SsPartType (&EnumValuesSsPartType())[13] {
  static const SsPartType values[] = {
    SsPartType_Invalid,
    SsPartType_Nulltype,
    SsPartType_Normal,
    SsPartType_Text,
    SsPartType_Instance,
    SsPartType_Armature,
    SsPartType_Effect,
    SsPartType_Mesh,
    SsPartType_Movenode,
    SsPartType_Constraint,
    SsPartType_Mask,
    SsPartType_Joint,
    SsPartType_Bonepoint
  };
  return values;
}

inline const char * const *EnumNamesSsPartType() {
  static const char * const names[] = {
    "Invalid",
    "Nulltype",
    "Normal",
    "Text",
    "Instance",
    "Armature",
    "Effect",
    "Mesh",
    "Movenode",
    "Constraint",
    "Mask",
    "Joint",
    "Bonepoint",
    nullptr
  };
  return names;
}

inline const char *EnumNameSsPartType(SsPartType e) {
  const size_t index = static_cast<int>(e) - static_cast<int>(SsPartType_Invalid);
  return EnumNamesSsPartType()[index];
}

enum PART_FLAG {
  PART_FLAG_INVISIBLE = 1,
  PART_FLAG_FLIP_H = 2,
  PART_FLAG_FLIP_V = 4,
  PART_FLAG_CELL_INDEX = 8,
  PART_FLAG_POSITION_X = 16,
  PART_FLAG_POSITION_Y = 32,
  PART_FLAG_POSITION_Z = 64,
  PART_FLAG_PIVOT_X = 128,
  PART_FLAG_PIVOT_Y = 256,
  PART_FLAG_ROTATIONX = 512,
  PART_FLAG_ROTATIONY = 1024,
  PART_FLAG_ROTATIONZ = 2048,
  PART_FLAG_SCALE_X = 4096,
  PART_FLAG_SCALE_Y = 8192,
  PART_FLAG_LOCALSCALE_X = 16384,
  PART_FLAG_LOCALSCALE_Y = 32768,
  PART_FLAG_OPACITY = 65536,
  PART_FLAG_LOCALOPACITY = 131072,
  PART_FLAG_PARTS_COLOR = 262144,
  PART_FLAG_VERTEX_TRANSFORM = 524288,
  PART_FLAG_SIZE_X = 1048576,
  PART_FLAG_SIZE_Y = 2097152,
  PART_FLAG_U_MOVE = 4194304,
  PART_FLAG_V_MOVE = 8388608,
  PART_FLAG_UV_ROTATION = 16777216,
  PART_FLAG_U_SCALE = 33554432,
  PART_FLAG_V_SCALE = 67108864,
  PART_FLAG_BOUNDINGRADIUS = 134217728,
  PART_FLAG_MASK = 268435456,
  PART_FLAG_PRIORITY = 536870912,
  PART_FLAG_INSTANCE_KEYFRAME = 1073741824,
  PART_FLAG_EFFECT_KEYFRAME = 2147483648,
  PART_FLAG_NONE = 0,
  PART_FLAG_ANY = 4294967295
};

inline const PART_FLAG (&EnumValuesPART_FLAG())[32] {
  static const PART_FLAG values[] = {
    PART_FLAG_INVISIBLE,
    PART_FLAG_FLIP_H,
    PART_FLAG_FLIP_V,
    PART_FLAG_CELL_INDEX,
    PART_FLAG_POSITION_X,
    PART_FLAG_POSITION_Y,
    PART_FLAG_POSITION_Z,
    PART_FLAG_PIVOT_X,
    PART_FLAG_PIVOT_Y,
    PART_FLAG_ROTATIONX,
    PART_FLAG_ROTATIONY,
    PART_FLAG_ROTATIONZ,
    PART_FLAG_SCALE_X,
    PART_FLAG_SCALE_Y,
    PART_FLAG_LOCALSCALE_X,
    PART_FLAG_LOCALSCALE_Y,
    PART_FLAG_OPACITY,
    PART_FLAG_LOCALOPACITY,
    PART_FLAG_PARTS_COLOR,
    PART_FLAG_VERTEX_TRANSFORM,
    PART_FLAG_SIZE_X,
    PART_FLAG_SIZE_Y,
    PART_FLAG_U_MOVE,
    PART_FLAG_V_MOVE,
    PART_FLAG_UV_ROTATION,
    PART_FLAG_U_SCALE,
    PART_FLAG_V_SCALE,
    PART_FLAG_BOUNDINGRADIUS,
    PART_FLAG_MASK,
    PART_FLAG_PRIORITY,
    PART_FLAG_INSTANCE_KEYFRAME,
    PART_FLAG_EFFECT_KEYFRAME
  };
  return values;
}

enum PART_FLAG2 {
  PART_FLAG2_MESHDATA = 1,
  PART_FLAG2_NONE = 0,
  PART_FLAG2_ANY = 1
};

inline const PART_FLAG2 (&EnumValuesPART_FLAG2())[1] {
  static const PART_FLAG2 values[] = {
    PART_FLAG2_MESHDATA
  };
  return values;
}

inline const char * const *EnumNamesPART_FLAG2() {
  static const char * const names[] = {
    "MESHDATA",
    nullptr
  };
  return names;
}

inline const char *EnumNamePART_FLAG2(PART_FLAG2 e) {
  const size_t index = static_cast<int>(e) - static_cast<int>(PART_FLAG2_MESHDATA);
  return EnumNamesPART_FLAG2()[index];
}

enum VERTEX_FLAG {
  VERTEX_FLAG_LT = 1,
  VERTEX_FLAG_RT = 2,
  VERTEX_FLAG_LB = 4,
  VERTEX_FLAG_RB = 8,
  VERTEX_FLAG_ONE = 16,
  VERTEX_FLAG_NONE = 0,
  VERTEX_FLAG_ANY = 31
};

inline const VERTEX_FLAG (&EnumValuesVERTEX_FLAG())[5] {
  static const VERTEX_FLAG values[] = {
    VERTEX_FLAG_LT,
    VERTEX_FLAG_RT,
    VERTEX_FLAG_LB,
    VERTEX_FLAG_RB,
    VERTEX_FLAG_ONE
  };
  return values;
}

inline const char * const *EnumNamesVERTEX_FLAG() {
  static const char * const names[] = {
    "LT",
    "RT",
    "",
    "LB",
    "",
    "",
    "",
    "RB",
    "",
    "",
    "",
    "",
    "",
    "",
    "",
    "ONE",
    nullptr
  };
  return names;
}

inline const char *EnumNameVERTEX_FLAG(VERTEX_FLAG e) {
  const size_t index = static_cast<int>(e) - static_cast<int>(VERTEX_FLAG_LT);
  return EnumNamesVERTEX_FLAG()[index];
}

enum EffectNodeBehavior {
  EffectNodeBehavior_NONE = 0,
  EffectNodeBehavior_EffectParticleElementBasic = 1,
  EffectNodeBehavior_EffectParticleElementRndSeedChange = 2,
  EffectNodeBehavior_EffectParticleElementDelay = 3,
  EffectNodeBehavior_EffectParticleElementGravity = 4,
  EffectNodeBehavior_EffectParticleElementPosition = 5,
  EffectNodeBehavior_EffectParticleElementRotation = 6,
  EffectNodeBehavior_EffectParticleElementRotationTrans = 7,
  EffectNodeBehavior_EffectParticleElementTransSpeed = 8,
  EffectNodeBehavior_EffectParticleElementTangentialAcceleration = 9,
  EffectNodeBehavior_EffectParticleElementInitColor = 10,
  EffectNodeBehavior_EffectParticleElementTransColor = 11,
  EffectNodeBehavior_EffectParticleElementAlphaFade = 12,
  EffectNodeBehavior_EffectParticleElementSize = 13,
  EffectNodeBehavior_EffectParticleElementTransSize = 14,
  EffectNodeBehavior_EffectParticlePointGravity = 15,
  EffectNodeBehavior_EffectParticleTurnToDirectionEnabled = 16,
  EffectNodeBehavior_EffectParticleInfiniteEmitEnabled = 17,
  EffectNodeBehavior_MIN = EffectNodeBehavior_NONE,
  EffectNodeBehavior_MAX = EffectNodeBehavior_EffectParticleInfiniteEmitEnabled
};

inline const EffectNodeBehavior (&EnumValuesEffectNodeBehavior())[18] {
  static const EffectNodeBehavior values[] = {
    EffectNodeBehavior_NONE,
    EffectNodeBehavior_EffectParticleElementBasic,
    EffectNodeBehavior_EffectParticleElementRndSeedChange,
    EffectNodeBehavior_EffectParticleElementDelay,
    EffectNodeBehavior_EffectParticleElementGravity,
    EffectNodeBehavior_EffectParticleElementPosition,
    EffectNodeBehavior_EffectParticleElementRotation,
    EffectNodeBehavior_EffectParticleElementRotationTrans,
    EffectNodeBehavior_EffectParticleElementTransSpeed,
    EffectNodeBehavior_EffectParticleElementTangentialAcceleration,
    EffectNodeBehavior_EffectParticleElementInitColor,
    EffectNodeBehavior_EffectParticleElementTransColor,
    EffectNodeBehavior_EffectParticleElementAlphaFade,
    EffectNodeBehavior_EffectParticleElementSize,
    EffectNodeBehavior_EffectParticleElementTransSize,
    EffectNodeBehavior_EffectParticlePointGravity,
    EffectNodeBehavior_EffectParticleTurnToDirectionEnabled,
    EffectNodeBehavior_EffectParticleInfiniteEmitEnabled
  };
  return values;
}

inline const char * const *EnumNamesEffectNodeBehavior() {
  static const char * const names[] = {
    "NONE",
    "EffectParticleElementBasic",
    "EffectParticleElementRndSeedChange",
    "EffectParticleElementDelay",
    "EffectParticleElementGravity",
    "EffectParticleElementPosition",
    "EffectParticleElementRotation",
    "EffectParticleElementRotationTrans",
    "EffectParticleElementTransSpeed",
    "EffectParticleElementTangentialAcceleration",
    "EffectParticleElementInitColor",
    "EffectParticleElementTransColor",
    "EffectParticleElementAlphaFade",
    "EffectParticleElementSize",
    "EffectParticleElementTransSize",
    "EffectParticlePointGravity",
    "EffectParticleTurnToDirectionEnabled",
    "EffectParticleInfiniteEmitEnabled",
    nullptr
  };
  return names;
}

inline const char *EnumNameEffectNodeBehavior(EffectNodeBehavior e) {
  const size_t index = static_cast<int>(e);
  return EnumNamesEffectNodeBehavior()[index];
}

template<typename T> struct EffectNodeBehaviorTraits {
  static const EffectNodeBehavior enum_value = EffectNodeBehavior_NONE;
};

template<> struct EffectNodeBehaviorTraits<EffectParticleElementBasic> {
  static const EffectNodeBehavior enum_value = EffectNodeBehavior_EffectParticleElementBasic;
};

template<> struct EffectNodeBehaviorTraits<EffectParticleElementRndSeedChange> {
  static const EffectNodeBehavior enum_value = EffectNodeBehavior_EffectParticleElementRndSeedChange;
};

template<> struct EffectNodeBehaviorTraits<EffectParticleElementDelay> {
  static const EffectNodeBehavior enum_value = EffectNodeBehavior_EffectParticleElementDelay;
};

template<> struct EffectNodeBehaviorTraits<EffectParticleElementGravity> {
  static const EffectNodeBehavior enum_value = EffectNodeBehavior_EffectParticleElementGravity;
};

template<> struct EffectNodeBehaviorTraits<EffectParticleElementPosition> {
  static const EffectNodeBehavior enum_value = EffectNodeBehavior_EffectParticleElementPosition;
};

template<> struct EffectNodeBehaviorTraits<EffectParticleElementRotation> {
  static const EffectNodeBehavior enum_value = EffectNodeBehavior_EffectParticleElementRotation;
};

template<> struct EffectNodeBehaviorTraits<EffectParticleElementRotationTrans> {
  static const EffectNodeBehavior enum_value = EffectNodeBehavior_EffectParticleElementRotationTrans;
};

template<> struct EffectNodeBehaviorTraits<EffectParticleElementTransSpeed> {
  static const EffectNodeBehavior enum_value = EffectNodeBehavior_EffectParticleElementTransSpeed;
};

template<> struct EffectNodeBehaviorTraits<EffectParticleElementTangentialAcceleration> {
  static const EffectNodeBehavior enum_value = EffectNodeBehavior_EffectParticleElementTangentialAcceleration;
};

template<> struct EffectNodeBehaviorTraits<EffectParticleElementInitColor> {
  static const EffectNodeBehavior enum_value = EffectNodeBehavior_EffectParticleElementInitColor;
};

template<> struct EffectNodeBehaviorTraits<EffectParticleElementTransColor> {
  static const EffectNodeBehavior enum_value = EffectNodeBehavior_EffectParticleElementTransColor;
};

template<> struct EffectNodeBehaviorTraits<EffectParticleElementAlphaFade> {
  static const EffectNodeBehavior enum_value = EffectNodeBehavior_EffectParticleElementAlphaFade;
};

template<> struct EffectNodeBehaviorTraits<EffectParticleElementSize> {
  static const EffectNodeBehavior enum_value = EffectNodeBehavior_EffectParticleElementSize;
};

template<> struct EffectNodeBehaviorTraits<EffectParticleElementTransSize> {
  static const EffectNodeBehavior enum_value = EffectNodeBehavior_EffectParticleElementTransSize;
};

template<> struct EffectNodeBehaviorTraits<EffectParticlePointGravity> {
  static const EffectNodeBehavior enum_value = EffectNodeBehavior_EffectParticlePointGravity;
};

template<> struct EffectNodeBehaviorTraits<EffectParticleTurnToDirectionEnabled> {
  static const EffectNodeBehavior enum_value = EffectNodeBehavior_EffectParticleTurnToDirectionEnabled;
};

template<> struct EffectNodeBehaviorTraits<EffectParticleInfiniteEmitEnabled> {
  static const EffectNodeBehavior enum_value = EffectNodeBehavior_EffectParticleInfiniteEmitEnabled;
};

bool VerifyEffectNodeBehavior(flatbuffers::Verifier &verifier, const void *obj, EffectNodeBehavior type);
bool VerifyEffectNodeBehaviorVector(flatbuffers::Verifier &verifier, const flatbuffers::Vector<flatbuffers::Offset<void>> *values, const flatbuffers::Vector<uint8_t> *types);

enum meshDataUVValue {
  meshDataUVValue_NONE = 0,
  meshDataUVValue_meshDataUVItem = 1,
  meshDataUVValue_meshDataUVEmpty = 2,
  meshDataUVValue_MIN = meshDataUVValue_NONE,
  meshDataUVValue_MAX = meshDataUVValue_meshDataUVEmpty
};

inline const meshDataUVValue (&EnumValuesmeshDataUVValue())[3] {
  static const meshDataUVValue values[] = {
    meshDataUVValue_NONE,
    meshDataUVValue_meshDataUVItem,
    meshDataUVValue_meshDataUVEmpty
  };
  return values;
}

inline const char * const *EnumNamesmeshDataUVValue() {
  static const char * const names[] = {
    "NONE",
    "meshDataUVItem",
    "meshDataUVEmpty",
    nullptr
  };
  return names;
}

inline const char *EnumNamemeshDataUVValue(meshDataUVValue e) {
  const size_t index = static_cast<int>(e);
  return EnumNamesmeshDataUVValue()[index];
}

template<typename T> struct meshDataUVValueTraits {
  static const meshDataUVValue enum_value = meshDataUVValue_NONE;
};

template<> struct meshDataUVValueTraits<meshDataUVItem> {
  static const meshDataUVValue enum_value = meshDataUVValue_meshDataUVItem;
};

template<> struct meshDataUVValueTraits<meshDataUVEmpty> {
  static const meshDataUVValue enum_value = meshDataUVValue_meshDataUVEmpty;
};

bool VerifymeshDataUVValue(flatbuffers::Verifier &verifier, const void *obj, meshDataUVValue type);
bool VerifymeshDataUVValueVector(flatbuffers::Verifier &verifier, const flatbuffers::Vector<flatbuffers::Offset<void>> *values, const flatbuffers::Vector<uint8_t> *types);

enum userDataValue {
  userDataValue_NONE = 0,
  userDataValue_userDataInteger = 1,
  userDataValue_userDataRect = 2,
  userDataValue_userDataPoint = 3,
  userDataValue_userDataString = 4,
  userDataValue_MIN = userDataValue_NONE,
  userDataValue_MAX = userDataValue_userDataString
};

inline const userDataValue (&EnumValuesuserDataValue())[5] {
  static const userDataValue values[] = {
    userDataValue_NONE,
    userDataValue_userDataInteger,
    userDataValue_userDataRect,
    userDataValue_userDataPoint,
    userDataValue_userDataString
  };
  return values;
}

inline const char * const *EnumNamesuserDataValue() {
  static const char * const names[] = {
    "NONE",
    "userDataInteger",
    "userDataRect",
    "userDataPoint",
    "userDataString",
    nullptr
  };
  return names;
}

inline const char *EnumNameuserDataValue(userDataValue e) {
  const size_t index = static_cast<int>(e);
  return EnumNamesuserDataValue()[index];
}

template<typename T> struct userDataValueTraits {
  static const userDataValue enum_value = userDataValue_NONE;
};

template<> struct userDataValueTraits<userDataInteger> {
  static const userDataValue enum_value = userDataValue_userDataInteger;
};

template<> struct userDataValueTraits<userDataRect> {
  static const userDataValue enum_value = userDataValue_userDataRect;
};

template<> struct userDataValueTraits<userDataPoint> {
  static const userDataValue enum_value = userDataValue_userDataPoint;
};

template<> struct userDataValueTraits<userDataString> {
  static const userDataValue enum_value = userDataValue_userDataString;
};

bool VerifyuserDataValue(flatbuffers::Verifier &verifier, const void *obj, userDataValue type);
bool VerifyuserDataValueVector(flatbuffers::Verifier &verifier, const flatbuffers::Vector<flatbuffers::Offset<void>> *values, const flatbuffers::Vector<uint8_t> *types);

struct EffectParticleInfiniteEmitEnabled FLATBUFFERS_FINAL_CLASS : private flatbuffers::Table {
  enum {
    VT_FLAG = 4
  };
  int32_t flag() const {
    return GetField<int32_t>(VT_FLAG, 0);
  }
  bool Verify(flatbuffers::Verifier &verifier) const {
    return VerifyTableStart(verifier) &&
           VerifyField<int32_t>(verifier, VT_FLAG) &&
           verifier.EndTable();
  }
};

struct EffectParticleInfiniteEmitEnabledBuilder {
  flatbuffers::FlatBufferBuilder &fbb_;
  flatbuffers::uoffset_t start_;
  void add_flag(int32_t flag) {
    fbb_.AddElement<int32_t>(EffectParticleInfiniteEmitEnabled::VT_FLAG, flag, 0);
  }
  explicit EffectParticleInfiniteEmitEnabledBuilder(flatbuffers::FlatBufferBuilder &_fbb)
        : fbb_(_fbb) {
    start_ = fbb_.StartTable();
  }
  EffectParticleInfiniteEmitEnabledBuilder &operator=(const EffectParticleInfiniteEmitEnabledBuilder &);
  flatbuffers::Offset<EffectParticleInfiniteEmitEnabled> Finish() {
    const auto end = fbb_.EndTable(start_);
    auto o = flatbuffers::Offset<EffectParticleInfiniteEmitEnabled>(end);
    return o;
  }
};

inline flatbuffers::Offset<EffectParticleInfiniteEmitEnabled> CreateEffectParticleInfiniteEmitEnabled(
    flatbuffers::FlatBufferBuilder &_fbb,
    int32_t flag = 0) {
  EffectParticleInfiniteEmitEnabledBuilder builder_(_fbb);
  builder_.add_flag(flag);
  return builder_.Finish();
}

struct EffectParticleTurnToDirectionEnabled FLATBUFFERS_FINAL_CLASS : private flatbuffers::Table {
  enum {
    VT_ROTATION = 4
  };
  float Rotation() const {
    return GetField<float>(VT_ROTATION, 0.0f);
  }
  bool Verify(flatbuffers::Verifier &verifier) const {
    return VerifyTableStart(verifier) &&
           VerifyField<float>(verifier, VT_ROTATION) &&
           verifier.EndTable();
  }
};

struct EffectParticleTurnToDirectionEnabledBuilder {
  flatbuffers::FlatBufferBuilder &fbb_;
  flatbuffers::uoffset_t start_;
  void add_Rotation(float Rotation) {
    fbb_.AddElement<float>(EffectParticleTurnToDirectionEnabled::VT_ROTATION, Rotation, 0.0f);
  }
  explicit EffectParticleTurnToDirectionEnabledBuilder(flatbuffers::FlatBufferBuilder &_fbb)
        : fbb_(_fbb) {
    start_ = fbb_.StartTable();
  }
  EffectParticleTurnToDirectionEnabledBuilder &operator=(const EffectParticleTurnToDirectionEnabledBuilder &);
  flatbuffers::Offset<EffectParticleTurnToDirectionEnabled> Finish() {
    const auto end = fbb_.EndTable(start_);
    auto o = flatbuffers::Offset<EffectParticleTurnToDirectionEnabled>(end);
    return o;
  }
};

inline flatbuffers::Offset<EffectParticleTurnToDirectionEnabled> CreateEffectParticleTurnToDirectionEnabled(
    flatbuffers::FlatBufferBuilder &_fbb,
    float Rotation = 0.0f) {
  EffectParticleTurnToDirectionEnabledBuilder builder_(_fbb);
  builder_.add_Rotation(Rotation);
  return builder_.Finish();
}

struct EffectParticlePointGravity FLATBUFFERS_FINAL_CLASS : private flatbuffers::Table {
  enum {
    VT_POSITION_X = 4,
    VT_POSITION_Y = 6,
    VT_POWER = 8
  };
  float Position_x() const {
    return GetField<float>(VT_POSITION_X, 0.0f);
  }
  float Position_y() const {
    return GetField<float>(VT_POSITION_Y, 0.0f);
  }
  float Power() const {
    return GetField<float>(VT_POWER, 0.0f);
  }
  bool Verify(flatbuffers::Verifier &verifier) const {
    return VerifyTableStart(verifier) &&
           VerifyField<float>(verifier, VT_POSITION_X) &&
           VerifyField<float>(verifier, VT_POSITION_Y) &&
           VerifyField<float>(verifier, VT_POWER) &&
           verifier.EndTable();
  }
};

struct EffectParticlePointGravityBuilder {
  flatbuffers::FlatBufferBuilder &fbb_;
  flatbuffers::uoffset_t start_;
  void add_Position_x(float Position_x) {
    fbb_.AddElement<float>(EffectParticlePointGravity::VT_POSITION_X, Position_x, 0.0f);
  }
  void add_Position_y(float Position_y) {
    fbb_.AddElement<float>(EffectParticlePointGravity::VT_POSITION_Y, Position_y, 0.0f);
  }
  void add_Power(float Power) {
    fbb_.AddElement<float>(EffectParticlePointGravity::VT_POWER, Power, 0.0f);
  }
  explicit EffectParticlePointGravityBuilder(flatbuffers::FlatBufferBuilder &_fbb)
        : fbb_(_fbb) {
    start_ = fbb_.StartTable();
  }
  EffectParticlePointGravityBuilder &operator=(const EffectParticlePointGravityBuilder &);
  flatbuffers::Offset<EffectParticlePointGravity> Finish() {
    const auto end = fbb_.EndTable(start_);
    auto o = flatbuffers::Offset<EffectParticlePointGravity>(end);
    return o;
  }
};

inline flatbuffers::Offset<EffectParticlePointGravity> CreateEffectParticlePointGravity(
    flatbuffers::FlatBufferBuilder &_fbb,
    float Position_x = 0.0f,
    float Position_y = 0.0f,
    float Power = 0.0f) {
  EffectParticlePointGravityBuilder builder_(_fbb);
  builder_.add_Power(Power);
  builder_.add_Position_y(Position_y);
  builder_.add_Position_x(Position_x);
  return builder_.Finish();
}

struct EffectParticleElementTransSize FLATBUFFERS_FINAL_CLASS : private flatbuffers::Table {
  enum {
    VT_SIZEXMINVALUE = 4,
    VT_SIZEXMAXVALUE = 6,
    VT_SIZEYMINVALUE = 8,
    VT_SIZEYMAXVALUE = 10,
    VT_SCALEFACTORMINVALUE = 12,
    VT_SCALEFACTORMAXVALUE = 14
  };
  float SizeXMinValue() const {
    return GetField<float>(VT_SIZEXMINVALUE, 0.0f);
  }
  float SizeXMaxValue() const {
    return GetField<float>(VT_SIZEXMAXVALUE, 0.0f);
  }
  float SizeYMinValue() const {
    return GetField<float>(VT_SIZEYMINVALUE, 0.0f);
  }
  float SizeYMaxValue() const {
    return GetField<float>(VT_SIZEYMAXVALUE, 0.0f);
  }
  float ScaleFactorMinValue() const {
    return GetField<float>(VT_SCALEFACTORMINVALUE, 0.0f);
  }
  float ScaleFactorMaxValue() const {
    return GetField<float>(VT_SCALEFACTORMAXVALUE, 0.0f);
  }
  bool Verify(flatbuffers::Verifier &verifier) const {
    return VerifyTableStart(verifier) &&
           VerifyField<float>(verifier, VT_SIZEXMINVALUE) &&
           VerifyField<float>(verifier, VT_SIZEXMAXVALUE) &&
           VerifyField<float>(verifier, VT_SIZEYMINVALUE) &&
           VerifyField<float>(verifier, VT_SIZEYMAXVALUE) &&
           VerifyField<float>(verifier, VT_SCALEFACTORMINVALUE) &&
           VerifyField<float>(verifier, VT_SCALEFACTORMAXVALUE) &&
           verifier.EndTable();
  }
};

struct EffectParticleElementTransSizeBuilder {
  flatbuffers::FlatBufferBuilder &fbb_;
  flatbuffers::uoffset_t start_;
  void add_SizeXMinValue(float SizeXMinValue) {
    fbb_.AddElement<float>(EffectParticleElementTransSize::VT_SIZEXMINVALUE, SizeXMinValue, 0.0f);
  }
  void add_SizeXMaxValue(float SizeXMaxValue) {
    fbb_.AddElement<float>(EffectParticleElementTransSize::VT_SIZEXMAXVALUE, SizeXMaxValue, 0.0f);
  }
  void add_SizeYMinValue(float SizeYMinValue) {
    fbb_.AddElement<float>(EffectParticleElementTransSize::VT_SIZEYMINVALUE, SizeYMinValue, 0.0f);
  }
  void add_SizeYMaxValue(float SizeYMaxValue) {
    fbb_.AddElement<float>(EffectParticleElementTransSize::VT_SIZEYMAXVALUE, SizeYMaxValue, 0.0f);
  }
  void add_ScaleFactorMinValue(float ScaleFactorMinValue) {
    fbb_.AddElement<float>(EffectParticleElementTransSize::VT_SCALEFACTORMINVALUE, ScaleFactorMinValue, 0.0f);
  }
  void add_ScaleFactorMaxValue(float ScaleFactorMaxValue) {
    fbb_.AddElement<float>(EffectParticleElementTransSize::VT_SCALEFACTORMAXVALUE, ScaleFactorMaxValue, 0.0f);
  }
  explicit EffectParticleElementTransSizeBuilder(flatbuffers::FlatBufferBuilder &_fbb)
        : fbb_(_fbb) {
    start_ = fbb_.StartTable();
  }
  EffectParticleElementTransSizeBuilder &operator=(const EffectParticleElementTransSizeBuilder &);
  flatbuffers::Offset<EffectParticleElementTransSize> Finish() {
    const auto end = fbb_.EndTable(start_);
    auto o = flatbuffers::Offset<EffectParticleElementTransSize>(end);
    return o;
  }
};

inline flatbuffers::Offset<EffectParticleElementTransSize> CreateEffectParticleElementTransSize(
    flatbuffers::FlatBufferBuilder &_fbb,
    float SizeXMinValue = 0.0f,
    float SizeXMaxValue = 0.0f,
    float SizeYMinValue = 0.0f,
    float SizeYMaxValue = 0.0f,
    float ScaleFactorMinValue = 0.0f,
    float ScaleFactorMaxValue = 0.0f) {
  EffectParticleElementTransSizeBuilder builder_(_fbb);
  builder_.add_ScaleFactorMaxValue(ScaleFactorMaxValue);
  builder_.add_ScaleFactorMinValue(ScaleFactorMinValue);
  builder_.add_SizeYMaxValue(SizeYMaxValue);
  builder_.add_SizeYMinValue(SizeYMinValue);
  builder_.add_SizeXMaxValue(SizeXMaxValue);
  builder_.add_SizeXMinValue(SizeXMinValue);
  return builder_.Finish();
}

struct EffectParticleElementSize FLATBUFFERS_FINAL_CLASS : private flatbuffers::Table {
  enum {
    VT_SIZEXMINVALUE = 4,
    VT_SIZEXMAXVALUE = 6,
    VT_SIZEYMINVALUE = 8,
    VT_SIZEYMAXVALUE = 10,
    VT_SCALEFACTORMINVALUE = 12,
    VT_SCALEFACTORMAXVALUE = 14
  };
  float SizeXMinValue() const {
    return GetField<float>(VT_SIZEXMINVALUE, 0.0f);
  }
  float SizeXMaxValue() const {
    return GetField<float>(VT_SIZEXMAXVALUE, 0.0f);
  }
  float SizeYMinValue() const {
    return GetField<float>(VT_SIZEYMINVALUE, 0.0f);
  }
  float SizeYMaxValue() const {
    return GetField<float>(VT_SIZEYMAXVALUE, 0.0f);
  }
  float ScaleFactorMinValue() const {
    return GetField<float>(VT_SCALEFACTORMINVALUE, 0.0f);
  }
  float ScaleFactorMaxValue() const {
    return GetField<float>(VT_SCALEFACTORMAXVALUE, 0.0f);
  }
  bool Verify(flatbuffers::Verifier &verifier) const {
    return VerifyTableStart(verifier) &&
           VerifyField<float>(verifier, VT_SIZEXMINVALUE) &&
           VerifyField<float>(verifier, VT_SIZEXMAXVALUE) &&
           VerifyField<float>(verifier, VT_SIZEYMINVALUE) &&
           VerifyField<float>(verifier, VT_SIZEYMAXVALUE) &&
           VerifyField<float>(verifier, VT_SCALEFACTORMINVALUE) &&
           VerifyField<float>(verifier, VT_SCALEFACTORMAXVALUE) &&
           verifier.EndTable();
  }
};

struct EffectParticleElementSizeBuilder {
  flatbuffers::FlatBufferBuilder &fbb_;
  flatbuffers::uoffset_t start_;
  void add_SizeXMinValue(float SizeXMinValue) {
    fbb_.AddElement<float>(EffectParticleElementSize::VT_SIZEXMINVALUE, SizeXMinValue, 0.0f);
  }
  void add_SizeXMaxValue(float SizeXMaxValue) {
    fbb_.AddElement<float>(EffectParticleElementSize::VT_SIZEXMAXVALUE, SizeXMaxValue, 0.0f);
  }
  void add_SizeYMinValue(float SizeYMinValue) {
    fbb_.AddElement<float>(EffectParticleElementSize::VT_SIZEYMINVALUE, SizeYMinValue, 0.0f);
  }
  void add_SizeYMaxValue(float SizeYMaxValue) {
    fbb_.AddElement<float>(EffectParticleElementSize::VT_SIZEYMAXVALUE, SizeYMaxValue, 0.0f);
  }
  void add_ScaleFactorMinValue(float ScaleFactorMinValue) {
    fbb_.AddElement<float>(EffectParticleElementSize::VT_SCALEFACTORMINVALUE, ScaleFactorMinValue, 0.0f);
  }
  void add_ScaleFactorMaxValue(float ScaleFactorMaxValue) {
    fbb_.AddElement<float>(EffectParticleElementSize::VT_SCALEFACTORMAXVALUE, ScaleFactorMaxValue, 0.0f);
  }
  explicit EffectParticleElementSizeBuilder(flatbuffers::FlatBufferBuilder &_fbb)
        : fbb_(_fbb) {
    start_ = fbb_.StartTable();
  }
  EffectParticleElementSizeBuilder &operator=(const EffectParticleElementSizeBuilder &);
  flatbuffers::Offset<EffectParticleElementSize> Finish() {
    const auto end = fbb_.EndTable(start_);
    auto o = flatbuffers::Offset<EffectParticleElementSize>(end);
    return o;
  }
};

inline flatbuffers::Offset<EffectParticleElementSize> CreateEffectParticleElementSize(
    flatbuffers::FlatBufferBuilder &_fbb,
    float SizeXMinValue = 0.0f,
    float SizeXMaxValue = 0.0f,
    float SizeYMinValue = 0.0f,
    float SizeYMaxValue = 0.0f,
    float ScaleFactorMinValue = 0.0f,
    float ScaleFactorMaxValue = 0.0f) {
  EffectParticleElementSizeBuilder builder_(_fbb);
  builder_.add_ScaleFactorMaxValue(ScaleFactorMaxValue);
  builder_.add_ScaleFactorMinValue(ScaleFactorMinValue);
  builder_.add_SizeYMaxValue(SizeYMaxValue);
  builder_.add_SizeYMinValue(SizeYMinValue);
  builder_.add_SizeXMaxValue(SizeXMaxValue);
  builder_.add_SizeXMinValue(SizeXMinValue);
  return builder_.Finish();
}

struct EffectParticleElementAlphaFade FLATBUFFERS_FINAL_CLASS : private flatbuffers::Table {
  enum {
    VT_DISPRANGEMINVALUE = 4,
    VT_DISPRANGEMAXVALUE = 6
  };
  float disprangeMinValue() const {
    return GetField<float>(VT_DISPRANGEMINVALUE, 0.0f);
  }
  float disprangeMaxValue() const {
    return GetField<float>(VT_DISPRANGEMAXVALUE, 0.0f);
  }
  bool Verify(flatbuffers::Verifier &verifier) const {
    return VerifyTableStart(verifier) &&
           VerifyField<float>(verifier, VT_DISPRANGEMINVALUE) &&
           VerifyField<float>(verifier, VT_DISPRANGEMAXVALUE) &&
           verifier.EndTable();
  }
};

struct EffectParticleElementAlphaFadeBuilder {
  flatbuffers::FlatBufferBuilder &fbb_;
  flatbuffers::uoffset_t start_;
  void add_disprangeMinValue(float disprangeMinValue) {
    fbb_.AddElement<float>(EffectParticleElementAlphaFade::VT_DISPRANGEMINVALUE, disprangeMinValue, 0.0f);
  }
  void add_disprangeMaxValue(float disprangeMaxValue) {
    fbb_.AddElement<float>(EffectParticleElementAlphaFade::VT_DISPRANGEMAXVALUE, disprangeMaxValue, 0.0f);
  }
  explicit EffectParticleElementAlphaFadeBuilder(flatbuffers::FlatBufferBuilder &_fbb)
        : fbb_(_fbb) {
    start_ = fbb_.StartTable();
  }
  EffectParticleElementAlphaFadeBuilder &operator=(const EffectParticleElementAlphaFadeBuilder &);
  flatbuffers::Offset<EffectParticleElementAlphaFade> Finish() {
    const auto end = fbb_.EndTable(start_);
    auto o = flatbuffers::Offset<EffectParticleElementAlphaFade>(end);
    return o;
  }
};

inline flatbuffers::Offset<EffectParticleElementAlphaFade> CreateEffectParticleElementAlphaFade(
    flatbuffers::FlatBufferBuilder &_fbb,
    float disprangeMinValue = 0.0f,
    float disprangeMaxValue = 0.0f) {
  EffectParticleElementAlphaFadeBuilder builder_(_fbb);
  builder_.add_disprangeMaxValue(disprangeMaxValue);
  builder_.add_disprangeMinValue(disprangeMinValue);
  return builder_.Finish();
}

struct EffectParticleElementTransColor FLATBUFFERS_FINAL_CLASS : private flatbuffers::Table {
  enum {
    VT_COLORMINVALUE = 4,
    VT_COLORMAXVALUE = 6
  };
  uint32_t ColorMinValue() const {
    return GetField<uint32_t>(VT_COLORMINVALUE, 0);
  }
  uint32_t ColorMaxValue() const {
    return GetField<uint32_t>(VT_COLORMAXVALUE, 0);
  }
  bool Verify(flatbuffers::Verifier &verifier) const {
    return VerifyTableStart(verifier) &&
           VerifyField<uint32_t>(verifier, VT_COLORMINVALUE) &&
           VerifyField<uint32_t>(verifier, VT_COLORMAXVALUE) &&
           verifier.EndTable();
  }
};

struct EffectParticleElementTransColorBuilder {
  flatbuffers::FlatBufferBuilder &fbb_;
  flatbuffers::uoffset_t start_;
  void add_ColorMinValue(uint32_t ColorMinValue) {
    fbb_.AddElement<uint32_t>(EffectParticleElementTransColor::VT_COLORMINVALUE, ColorMinValue, 0);
  }
  void add_ColorMaxValue(uint32_t ColorMaxValue) {
    fbb_.AddElement<uint32_t>(EffectParticleElementTransColor::VT_COLORMAXVALUE, ColorMaxValue, 0);
  }
  explicit EffectParticleElementTransColorBuilder(flatbuffers::FlatBufferBuilder &_fbb)
        : fbb_(_fbb) {
    start_ = fbb_.StartTable();
  }
  EffectParticleElementTransColorBuilder &operator=(const EffectParticleElementTransColorBuilder &);
  flatbuffers::Offset<EffectParticleElementTransColor> Finish() {
    const auto end = fbb_.EndTable(start_);
    auto o = flatbuffers::Offset<EffectParticleElementTransColor>(end);
    return o;
  }
};

inline flatbuffers::Offset<EffectParticleElementTransColor> CreateEffectParticleElementTransColor(
    flatbuffers::FlatBufferBuilder &_fbb,
    uint32_t ColorMinValue = 0,
    uint32_t ColorMaxValue = 0) {
  EffectParticleElementTransColorBuilder builder_(_fbb);
  builder_.add_ColorMaxValue(ColorMaxValue);
  builder_.add_ColorMinValue(ColorMinValue);
  return builder_.Finish();
}

struct EffectParticleElementInitColor FLATBUFFERS_FINAL_CLASS : private flatbuffers::Table {
  enum {
    VT_COLORMINVALUE = 4,
    VT_COLORMAXVALUE = 6
  };
  uint32_t ColorMinValue() const {
    return GetField<uint32_t>(VT_COLORMINVALUE, 0);
  }
  uint32_t ColorMaxValue() const {
    return GetField<uint32_t>(VT_COLORMAXVALUE, 0);
  }
  bool Verify(flatbuffers::Verifier &verifier) const {
    return VerifyTableStart(verifier) &&
           VerifyField<uint32_t>(verifier, VT_COLORMINVALUE) &&
           VerifyField<uint32_t>(verifier, VT_COLORMAXVALUE) &&
           verifier.EndTable();
  }
};

struct EffectParticleElementInitColorBuilder {
  flatbuffers::FlatBufferBuilder &fbb_;
  flatbuffers::uoffset_t start_;
  void add_ColorMinValue(uint32_t ColorMinValue) {
    fbb_.AddElement<uint32_t>(EffectParticleElementInitColor::VT_COLORMINVALUE, ColorMinValue, 0);
  }
  void add_ColorMaxValue(uint32_t ColorMaxValue) {
    fbb_.AddElement<uint32_t>(EffectParticleElementInitColor::VT_COLORMAXVALUE, ColorMaxValue, 0);
  }
  explicit EffectParticleElementInitColorBuilder(flatbuffers::FlatBufferBuilder &_fbb)
        : fbb_(_fbb) {
    start_ = fbb_.StartTable();
  }
  EffectParticleElementInitColorBuilder &operator=(const EffectParticleElementInitColorBuilder &);
  flatbuffers::Offset<EffectParticleElementInitColor> Finish() {
    const auto end = fbb_.EndTable(start_);
    auto o = flatbuffers::Offset<EffectParticleElementInitColor>(end);
    return o;
  }
};

inline flatbuffers::Offset<EffectParticleElementInitColor> CreateEffectParticleElementInitColor(
    flatbuffers::FlatBufferBuilder &_fbb,
    uint32_t ColorMinValue = 0,
    uint32_t ColorMaxValue = 0) {
  EffectParticleElementInitColorBuilder builder_(_fbb);
  builder_.add_ColorMaxValue(ColorMaxValue);
  builder_.add_ColorMinValue(ColorMinValue);
  return builder_.Finish();
}

struct EffectParticleElementTangentialAcceleration FLATBUFFERS_FINAL_CLASS : private flatbuffers::Table {
  enum {
    VT_ACCELERATIONMINVALUE = 4,
    VT_ACCELERATIONMAXVALUE = 6
  };
  float AccelerationMinValue() const {
    return GetField<float>(VT_ACCELERATIONMINVALUE, 0.0f);
  }
  float AccelerationMaxValue() const {
    return GetField<float>(VT_ACCELERATIONMAXVALUE, 0.0f);
  }
  bool Verify(flatbuffers::Verifier &verifier) const {
    return VerifyTableStart(verifier) &&
           VerifyField<float>(verifier, VT_ACCELERATIONMINVALUE) &&
           VerifyField<float>(verifier, VT_ACCELERATIONMAXVALUE) &&
           verifier.EndTable();
  }
};

struct EffectParticleElementTangentialAccelerationBuilder {
  flatbuffers::FlatBufferBuilder &fbb_;
  flatbuffers::uoffset_t start_;
  void add_AccelerationMinValue(float AccelerationMinValue) {
    fbb_.AddElement<float>(EffectParticleElementTangentialAcceleration::VT_ACCELERATIONMINVALUE, AccelerationMinValue, 0.0f);
  }
  void add_AccelerationMaxValue(float AccelerationMaxValue) {
    fbb_.AddElement<float>(EffectParticleElementTangentialAcceleration::VT_ACCELERATIONMAXVALUE, AccelerationMaxValue, 0.0f);
  }
  explicit EffectParticleElementTangentialAccelerationBuilder(flatbuffers::FlatBufferBuilder &_fbb)
        : fbb_(_fbb) {
    start_ = fbb_.StartTable();
  }
  EffectParticleElementTangentialAccelerationBuilder &operator=(const EffectParticleElementTangentialAccelerationBuilder &);
  flatbuffers::Offset<EffectParticleElementTangentialAcceleration> Finish() {
    const auto end = fbb_.EndTable(start_);
    auto o = flatbuffers::Offset<EffectParticleElementTangentialAcceleration>(end);
    return o;
  }
};

inline flatbuffers::Offset<EffectParticleElementTangentialAcceleration> CreateEffectParticleElementTangentialAcceleration(
    flatbuffers::FlatBufferBuilder &_fbb,
    float AccelerationMinValue = 0.0f,
    float AccelerationMaxValue = 0.0f) {
  EffectParticleElementTangentialAccelerationBuilder builder_(_fbb);
  builder_.add_AccelerationMaxValue(AccelerationMaxValue);
  builder_.add_AccelerationMinValue(AccelerationMinValue);
  return builder_.Finish();
}

struct EffectParticleElementTransSpeed FLATBUFFERS_FINAL_CLASS : private flatbuffers::Table {
  enum {
    VT_SPEEDMINVALUE = 4,
    VT_SPEEDMAXVALUE = 6
  };
  float SpeedMinValue() const {
    return GetField<float>(VT_SPEEDMINVALUE, 0.0f);
  }
  float SpeedMaxValue() const {
    return GetField<float>(VT_SPEEDMAXVALUE, 0.0f);
  }
  bool Verify(flatbuffers::Verifier &verifier) const {
    return VerifyTableStart(verifier) &&
           VerifyField<float>(verifier, VT_SPEEDMINVALUE) &&
           VerifyField<float>(verifier, VT_SPEEDMAXVALUE) &&
           verifier.EndTable();
  }
};

struct EffectParticleElementTransSpeedBuilder {
  flatbuffers::FlatBufferBuilder &fbb_;
  flatbuffers::uoffset_t start_;
  void add_SpeedMinValue(float SpeedMinValue) {
    fbb_.AddElement<float>(EffectParticleElementTransSpeed::VT_SPEEDMINVALUE, SpeedMinValue, 0.0f);
  }
  void add_SpeedMaxValue(float SpeedMaxValue) {
    fbb_.AddElement<float>(EffectParticleElementTransSpeed::VT_SPEEDMAXVALUE, SpeedMaxValue, 0.0f);
  }
  explicit EffectParticleElementTransSpeedBuilder(flatbuffers::FlatBufferBuilder &_fbb)
        : fbb_(_fbb) {
    start_ = fbb_.StartTable();
  }
  EffectParticleElementTransSpeedBuilder &operator=(const EffectParticleElementTransSpeedBuilder &);
  flatbuffers::Offset<EffectParticleElementTransSpeed> Finish() {
    const auto end = fbb_.EndTable(start_);
    auto o = flatbuffers::Offset<EffectParticleElementTransSpeed>(end);
    return o;
  }
};

inline flatbuffers::Offset<EffectParticleElementTransSpeed> CreateEffectParticleElementTransSpeed(
    flatbuffers::FlatBufferBuilder &_fbb,
    float SpeedMinValue = 0.0f,
    float SpeedMaxValue = 0.0f) {
  EffectParticleElementTransSpeedBuilder builder_(_fbb);
  builder_.add_SpeedMaxValue(SpeedMaxValue);
  builder_.add_SpeedMinValue(SpeedMinValue);
  return builder_.Finish();
}

struct EffectParticleElementRotationTrans FLATBUFFERS_FINAL_CLASS : private flatbuffers::Table {
  enum {
    VT_ROTATIONFACTOR = 4,
    VT_ENDLIFETIMEPER = 6
  };
  float RotationFactor() const {
    return GetField<float>(VT_ROTATIONFACTOR, 0.0f);
  }
  float EndLifeTimePer() const {
    return GetField<float>(VT_ENDLIFETIMEPER, 0.0f);
  }
  bool Verify(flatbuffers::Verifier &verifier) const {
    return VerifyTableStart(verifier) &&
           VerifyField<float>(verifier, VT_ROTATIONFACTOR) &&
           VerifyField<float>(verifier, VT_ENDLIFETIMEPER) &&
           verifier.EndTable();
  }
};

struct EffectParticleElementRotationTransBuilder {
  flatbuffers::FlatBufferBuilder &fbb_;
  flatbuffers::uoffset_t start_;
  void add_RotationFactor(float RotationFactor) {
    fbb_.AddElement<float>(EffectParticleElementRotationTrans::VT_ROTATIONFACTOR, RotationFactor, 0.0f);
  }
  void add_EndLifeTimePer(float EndLifeTimePer) {
    fbb_.AddElement<float>(EffectParticleElementRotationTrans::VT_ENDLIFETIMEPER, EndLifeTimePer, 0.0f);
  }
  explicit EffectParticleElementRotationTransBuilder(flatbuffers::FlatBufferBuilder &_fbb)
        : fbb_(_fbb) {
    start_ = fbb_.StartTable();
  }
  EffectParticleElementRotationTransBuilder &operator=(const EffectParticleElementRotationTransBuilder &);
  flatbuffers::Offset<EffectParticleElementRotationTrans> Finish() {
    const auto end = fbb_.EndTable(start_);
    auto o = flatbuffers::Offset<EffectParticleElementRotationTrans>(end);
    return o;
  }
};

inline flatbuffers::Offset<EffectParticleElementRotationTrans> CreateEffectParticleElementRotationTrans(
    flatbuffers::FlatBufferBuilder &_fbb,
    float RotationFactor = 0.0f,
    float EndLifeTimePer = 0.0f) {
  EffectParticleElementRotationTransBuilder builder_(_fbb);
  builder_.add_EndLifeTimePer(EndLifeTimePer);
  builder_.add_RotationFactor(RotationFactor);
  return builder_.Finish();
}

struct EffectParticleElementRotation FLATBUFFERS_FINAL_CLASS : private flatbuffers::Table {
  enum {
    VT_ROTATIONMINVALUE = 4,
    VT_ROTATIONMAXVALUE = 6,
    VT_ROTATIONADDMINVALUE = 8,
    VT_ROTATIONADDMAXVALUE = 10
  };
  float RotationMinValue() const {
    return GetField<float>(VT_ROTATIONMINVALUE, 0.0f);
  }
  float RotationMaxValue() const {
    return GetField<float>(VT_ROTATIONMAXVALUE, 0.0f);
  }
  float RotationAddMinValue() const {
    return GetField<float>(VT_ROTATIONADDMINVALUE, 0.0f);
  }
  float RotationAddMaxValue() const {
    return GetField<float>(VT_ROTATIONADDMAXVALUE, 0.0f);
  }
  bool Verify(flatbuffers::Verifier &verifier) const {
    return VerifyTableStart(verifier) &&
           VerifyField<float>(verifier, VT_ROTATIONMINVALUE) &&
           VerifyField<float>(verifier, VT_ROTATIONMAXVALUE) &&
           VerifyField<float>(verifier, VT_ROTATIONADDMINVALUE) &&
           VerifyField<float>(verifier, VT_ROTATIONADDMAXVALUE) &&
           verifier.EndTable();
  }
};

struct EffectParticleElementRotationBuilder {
  flatbuffers::FlatBufferBuilder &fbb_;
  flatbuffers::uoffset_t start_;
  void add_RotationMinValue(float RotationMinValue) {
    fbb_.AddElement<float>(EffectParticleElementRotation::VT_ROTATIONMINVALUE, RotationMinValue, 0.0f);
  }
  void add_RotationMaxValue(float RotationMaxValue) {
    fbb_.AddElement<float>(EffectParticleElementRotation::VT_ROTATIONMAXVALUE, RotationMaxValue, 0.0f);
  }
  void add_RotationAddMinValue(float RotationAddMinValue) {
    fbb_.AddElement<float>(EffectParticleElementRotation::VT_ROTATIONADDMINVALUE, RotationAddMinValue, 0.0f);
  }
  void add_RotationAddMaxValue(float RotationAddMaxValue) {
    fbb_.AddElement<float>(EffectParticleElementRotation::VT_ROTATIONADDMAXVALUE, RotationAddMaxValue, 0.0f);
  }
  explicit EffectParticleElementRotationBuilder(flatbuffers::FlatBufferBuilder &_fbb)
        : fbb_(_fbb) {
    start_ = fbb_.StartTable();
  }
  EffectParticleElementRotationBuilder &operator=(const EffectParticleElementRotationBuilder &);
  flatbuffers::Offset<EffectParticleElementRotation> Finish() {
    const auto end = fbb_.EndTable(start_);
    auto o = flatbuffers::Offset<EffectParticleElementRotation>(end);
    return o;
  }
};

inline flatbuffers::Offset<EffectParticleElementRotation> CreateEffectParticleElementRotation(
    flatbuffers::FlatBufferBuilder &_fbb,
    float RotationMinValue = 0.0f,
    float RotationMaxValue = 0.0f,
    float RotationAddMinValue = 0.0f,
    float RotationAddMaxValue = 0.0f) {
  EffectParticleElementRotationBuilder builder_(_fbb);
  builder_.add_RotationAddMaxValue(RotationAddMaxValue);
  builder_.add_RotationAddMinValue(RotationAddMinValue);
  builder_.add_RotationMaxValue(RotationMaxValue);
  builder_.add_RotationMinValue(RotationMinValue);
  return builder_.Finish();
}

struct EffectParticleElementPosition FLATBUFFERS_FINAL_CLASS : private flatbuffers::Table {
  enum {
    VT_OFFSETXMINVALUE = 4,
    VT_OFFSETXMAXVALUE = 6,
    VT_OFFSETYMINVALUE = 8,
    VT_OFFSETYMAXVALUE = 10
  };
  float OffsetXMinValue() const {
    return GetField<float>(VT_OFFSETXMINVALUE, 0.0f);
  }
  float OffsetXMaxValue() const {
    return GetField<float>(VT_OFFSETXMAXVALUE, 0.0f);
  }
  float OffsetYMinValue() const {
    return GetField<float>(VT_OFFSETYMINVALUE, 0.0f);
  }
  float OffsetYMaxValue() const {
    return GetField<float>(VT_OFFSETYMAXVALUE, 0.0f);
  }
  bool Verify(flatbuffers::Verifier &verifier) const {
    return VerifyTableStart(verifier) &&
           VerifyField<float>(verifier, VT_OFFSETXMINVALUE) &&
           VerifyField<float>(verifier, VT_OFFSETXMAXVALUE) &&
           VerifyField<float>(verifier, VT_OFFSETYMINVALUE) &&
           VerifyField<float>(verifier, VT_OFFSETYMAXVALUE) &&
           verifier.EndTable();
  }
};

struct EffectParticleElementPositionBuilder {
  flatbuffers::FlatBufferBuilder &fbb_;
  flatbuffers::uoffset_t start_;
  void add_OffsetXMinValue(float OffsetXMinValue) {
    fbb_.AddElement<float>(EffectParticleElementPosition::VT_OFFSETXMINVALUE, OffsetXMinValue, 0.0f);
  }
  void add_OffsetXMaxValue(float OffsetXMaxValue) {
    fbb_.AddElement<float>(EffectParticleElementPosition::VT_OFFSETXMAXVALUE, OffsetXMaxValue, 0.0f);
  }
  void add_OffsetYMinValue(float OffsetYMinValue) {
    fbb_.AddElement<float>(EffectParticleElementPosition::VT_OFFSETYMINVALUE, OffsetYMinValue, 0.0f);
  }
  void add_OffsetYMaxValue(float OffsetYMaxValue) {
    fbb_.AddElement<float>(EffectParticleElementPosition::VT_OFFSETYMAXVALUE, OffsetYMaxValue, 0.0f);
  }
  explicit EffectParticleElementPositionBuilder(flatbuffers::FlatBufferBuilder &_fbb)
        : fbb_(_fbb) {
    start_ = fbb_.StartTable();
  }
  EffectParticleElementPositionBuilder &operator=(const EffectParticleElementPositionBuilder &);
  flatbuffers::Offset<EffectParticleElementPosition> Finish() {
    const auto end = fbb_.EndTable(start_);
    auto o = flatbuffers::Offset<EffectParticleElementPosition>(end);
    return o;
  }
};

inline flatbuffers::Offset<EffectParticleElementPosition> CreateEffectParticleElementPosition(
    flatbuffers::FlatBufferBuilder &_fbb,
    float OffsetXMinValue = 0.0f,
    float OffsetXMaxValue = 0.0f,
    float OffsetYMinValue = 0.0f,
    float OffsetYMaxValue = 0.0f) {
  EffectParticleElementPositionBuilder builder_(_fbb);
  builder_.add_OffsetYMaxValue(OffsetYMaxValue);
  builder_.add_OffsetYMinValue(OffsetYMinValue);
  builder_.add_OffsetXMaxValue(OffsetXMaxValue);
  builder_.add_OffsetXMinValue(OffsetXMinValue);
  return builder_.Finish();
}

struct EffectParticleElementGravity FLATBUFFERS_FINAL_CLASS : private flatbuffers::Table {
  enum {
    VT_GRAVITY_X = 4,
    VT_GRAVITY_Y = 6
  };
  float Gravity_x() const {
    return GetField<float>(VT_GRAVITY_X, 0.0f);
  }
  float Gravity_y() const {
    return GetField<float>(VT_GRAVITY_Y, 0.0f);
  }
  bool Verify(flatbuffers::Verifier &verifier) const {
    return VerifyTableStart(verifier) &&
           VerifyField<float>(verifier, VT_GRAVITY_X) &&
           VerifyField<float>(verifier, VT_GRAVITY_Y) &&
           verifier.EndTable();
  }
};

struct EffectParticleElementGravityBuilder {
  flatbuffers::FlatBufferBuilder &fbb_;
  flatbuffers::uoffset_t start_;
  void add_Gravity_x(float Gravity_x) {
    fbb_.AddElement<float>(EffectParticleElementGravity::VT_GRAVITY_X, Gravity_x, 0.0f);
  }
  void add_Gravity_y(float Gravity_y) {
    fbb_.AddElement<float>(EffectParticleElementGravity::VT_GRAVITY_Y, Gravity_y, 0.0f);
  }
  explicit EffectParticleElementGravityBuilder(flatbuffers::FlatBufferBuilder &_fbb)
        : fbb_(_fbb) {
    start_ = fbb_.StartTable();
  }
  EffectParticleElementGravityBuilder &operator=(const EffectParticleElementGravityBuilder &);
  flatbuffers::Offset<EffectParticleElementGravity> Finish() {
    const auto end = fbb_.EndTable(start_);
    auto o = flatbuffers::Offset<EffectParticleElementGravity>(end);
    return o;
  }
};

inline flatbuffers::Offset<EffectParticleElementGravity> CreateEffectParticleElementGravity(
    flatbuffers::FlatBufferBuilder &_fbb,
    float Gravity_x = 0.0f,
    float Gravity_y = 0.0f) {
  EffectParticleElementGravityBuilder builder_(_fbb);
  builder_.add_Gravity_y(Gravity_y);
  builder_.add_Gravity_x(Gravity_x);
  return builder_.Finish();
}

struct EffectParticleElementDelay FLATBUFFERS_FINAL_CLASS : private flatbuffers::Table {
  enum {
    VT_DELAYTIME = 4
  };
  int32_t DelayTime() const {
    return GetField<int32_t>(VT_DELAYTIME, 0);
  }
  bool Verify(flatbuffers::Verifier &verifier) const {
    return VerifyTableStart(verifier) &&
           VerifyField<int32_t>(verifier, VT_DELAYTIME) &&
           verifier.EndTable();
  }
};

struct EffectParticleElementDelayBuilder {
  flatbuffers::FlatBufferBuilder &fbb_;
  flatbuffers::uoffset_t start_;
  void add_DelayTime(int32_t DelayTime) {
    fbb_.AddElement<int32_t>(EffectParticleElementDelay::VT_DELAYTIME, DelayTime, 0);
  }
  explicit EffectParticleElementDelayBuilder(flatbuffers::FlatBufferBuilder &_fbb)
        : fbb_(_fbb) {
    start_ = fbb_.StartTable();
  }
  EffectParticleElementDelayBuilder &operator=(const EffectParticleElementDelayBuilder &);
  flatbuffers::Offset<EffectParticleElementDelay> Finish() {
    const auto end = fbb_.EndTable(start_);
    auto o = flatbuffers::Offset<EffectParticleElementDelay>(end);
    return o;
  }
};

inline flatbuffers::Offset<EffectParticleElementDelay> CreateEffectParticleElementDelay(
    flatbuffers::FlatBufferBuilder &_fbb,
    int32_t DelayTime = 0) {
  EffectParticleElementDelayBuilder builder_(_fbb);
  builder_.add_DelayTime(DelayTime);
  return builder_.Finish();
}

struct EffectParticleElementRndSeedChange FLATBUFFERS_FINAL_CLASS : private flatbuffers::Table {
  enum {
    VT_SEED = 4
  };
  int32_t Seed() const {
    return GetField<int32_t>(VT_SEED, 0);
  }
  bool Verify(flatbuffers::Verifier &verifier) const {
    return VerifyTableStart(verifier) &&
           VerifyField<int32_t>(verifier, VT_SEED) &&
           verifier.EndTable();
  }
};

struct EffectParticleElementRndSeedChangeBuilder {
  flatbuffers::FlatBufferBuilder &fbb_;
  flatbuffers::uoffset_t start_;
  void add_Seed(int32_t Seed) {
    fbb_.AddElement<int32_t>(EffectParticleElementRndSeedChange::VT_SEED, Seed, 0);
  }
  explicit EffectParticleElementRndSeedChangeBuilder(flatbuffers::FlatBufferBuilder &_fbb)
        : fbb_(_fbb) {
    start_ = fbb_.StartTable();
  }
  EffectParticleElementRndSeedChangeBuilder &operator=(const EffectParticleElementRndSeedChangeBuilder &);
  flatbuffers::Offset<EffectParticleElementRndSeedChange> Finish() {
    const auto end = fbb_.EndTable(start_);
    auto o = flatbuffers::Offset<EffectParticleElementRndSeedChange>(end);
    return o;
  }
};

inline flatbuffers::Offset<EffectParticleElementRndSeedChange> CreateEffectParticleElementRndSeedChange(
    flatbuffers::FlatBufferBuilder &_fbb,
    int32_t Seed = 0) {
  EffectParticleElementRndSeedChangeBuilder builder_(_fbb);
  builder_.add_Seed(Seed);
  return builder_.Finish();
}

struct EffectParticleElementBasic FLATBUFFERS_FINAL_CLASS : private flatbuffers::Table {
  enum {
    VT_SSEFFECTFUNCTIONTYPE = 4,
    VT_PRIORITY = 6,
    VT_MAXIMUMPARTICLE = 8,
    VT_ATTIMECREATE = 10,
    VT_INTERVAL = 12,
    VT_LIFETIME = 14,
    VT_SPEEDMINVALUE = 16,
    VT_SPEEDMAXVALUE = 18,
    VT_LIFESPANMINVALUE = 20,
    VT_LIFESPANMAXVALUE = 22,
    VT_ANGLE = 24,
    VT_ANGLEVARIANCE = 26
  };
  int32_t SsEffectFunctionType() const {
    return GetField<int32_t>(VT_SSEFFECTFUNCTIONTYPE, 0);
  }
  int32_t priority() const {
    return GetField<int32_t>(VT_PRIORITY, 0);
  }
  int32_t maximumParticle() const {
    return GetField<int32_t>(VT_MAXIMUMPARTICLE, 0);
  }
  int32_t attimeCreate() const {
    return GetField<int32_t>(VT_ATTIMECREATE, 0);
  }
  int32_t interval() const {
    return GetField<int32_t>(VT_INTERVAL, 0);
  }
  int32_t lifetime() const {
    return GetField<int32_t>(VT_LIFETIME, 0);
  }
  float speedMinValue() const {
    return GetField<float>(VT_SPEEDMINVALUE, 0.0f);
  }
  float speedMaxValue() const {
    return GetField<float>(VT_SPEEDMAXVALUE, 0.0f);
  }
  int32_t lifespanMinValue() const {
    return GetField<int32_t>(VT_LIFESPANMINVALUE, 0);
  }
  int32_t lifespanMaxValue() const {
    return GetField<int32_t>(VT_LIFESPANMAXVALUE, 0);
  }
  float angle() const {
    return GetField<float>(VT_ANGLE, 0.0f);
  }
  float angleVariance() const {
    return GetField<float>(VT_ANGLEVARIANCE, 0.0f);
  }
  bool Verify(flatbuffers::Verifier &verifier) const {
    return VerifyTableStart(verifier) &&
           VerifyField<int32_t>(verifier, VT_SSEFFECTFUNCTIONTYPE) &&
           VerifyField<int32_t>(verifier, VT_PRIORITY) &&
           VerifyField<int32_t>(verifier, VT_MAXIMUMPARTICLE) &&
           VerifyField<int32_t>(verifier, VT_ATTIMECREATE) &&
           VerifyField<int32_t>(verifier, VT_INTERVAL) &&
           VerifyField<int32_t>(verifier, VT_LIFETIME) &&
           VerifyField<float>(verifier, VT_SPEEDMINVALUE) &&
           VerifyField<float>(verifier, VT_SPEEDMAXVALUE) &&
           VerifyField<int32_t>(verifier, VT_LIFESPANMINVALUE) &&
           VerifyField<int32_t>(verifier, VT_LIFESPANMAXVALUE) &&
           VerifyField<float>(verifier, VT_ANGLE) &&
           VerifyField<float>(verifier, VT_ANGLEVARIANCE) &&
           verifier.EndTable();
  }
};

struct EffectParticleElementBasicBuilder {
  flatbuffers::FlatBufferBuilder &fbb_;
  flatbuffers::uoffset_t start_;
  void add_SsEffectFunctionType(int32_t SsEffectFunctionType) {
    fbb_.AddElement<int32_t>(EffectParticleElementBasic::VT_SSEFFECTFUNCTIONTYPE, SsEffectFunctionType, 0);
  }
  void add_priority(int32_t priority) {
    fbb_.AddElement<int32_t>(EffectParticleElementBasic::VT_PRIORITY, priority, 0);
  }
  void add_maximumParticle(int32_t maximumParticle) {
    fbb_.AddElement<int32_t>(EffectParticleElementBasic::VT_MAXIMUMPARTICLE, maximumParticle, 0);
  }
  void add_attimeCreate(int32_t attimeCreate) {
    fbb_.AddElement<int32_t>(EffectParticleElementBasic::VT_ATTIMECREATE, attimeCreate, 0);
  }
  void add_interval(int32_t interval) {
    fbb_.AddElement<int32_t>(EffectParticleElementBasic::VT_INTERVAL, interval, 0);
  }
  void add_lifetime(int32_t lifetime) {
    fbb_.AddElement<int32_t>(EffectParticleElementBasic::VT_LIFETIME, lifetime, 0);
  }
  void add_speedMinValue(float speedMinValue) {
    fbb_.AddElement<float>(EffectParticleElementBasic::VT_SPEEDMINVALUE, speedMinValue, 0.0f);
  }
  void add_speedMaxValue(float speedMaxValue) {
    fbb_.AddElement<float>(EffectParticleElementBasic::VT_SPEEDMAXVALUE, speedMaxValue, 0.0f);
  }
  void add_lifespanMinValue(int32_t lifespanMinValue) {
    fbb_.AddElement<int32_t>(EffectParticleElementBasic::VT_LIFESPANMINVALUE, lifespanMinValue, 0);
  }
  void add_lifespanMaxValue(int32_t lifespanMaxValue) {
    fbb_.AddElement<int32_t>(EffectParticleElementBasic::VT_LIFESPANMAXVALUE, lifespanMaxValue, 0);
  }
  void add_angle(float angle) {
    fbb_.AddElement<float>(EffectParticleElementBasic::VT_ANGLE, angle, 0.0f);
  }
  void add_angleVariance(float angleVariance) {
    fbb_.AddElement<float>(EffectParticleElementBasic::VT_ANGLEVARIANCE, angleVariance, 0.0f);
  }
  explicit EffectParticleElementBasicBuilder(flatbuffers::FlatBufferBuilder &_fbb)
        : fbb_(_fbb) {
    start_ = fbb_.StartTable();
  }
  EffectParticleElementBasicBuilder &operator=(const EffectParticleElementBasicBuilder &);
  flatbuffers::Offset<EffectParticleElementBasic> Finish() {
    const auto end = fbb_.EndTable(start_);
    auto o = flatbuffers::Offset<EffectParticleElementBasic>(end);
    return o;
  }
};

inline flatbuffers::Offset<EffectParticleElementBasic> CreateEffectParticleElementBasic(
    flatbuffers::FlatBufferBuilder &_fbb,
    int32_t SsEffectFunctionType = 0,
    int32_t priority = 0,
    int32_t maximumParticle = 0,
    int32_t attimeCreate = 0,
    int32_t interval = 0,
    int32_t lifetime = 0,
    float speedMinValue = 0.0f,
    float speedMaxValue = 0.0f,
    int32_t lifespanMinValue = 0,
    int32_t lifespanMaxValue = 0,
    float angle = 0.0f,
    float angleVariance = 0.0f) {
  EffectParticleElementBasicBuilder builder_(_fbb);
  builder_.add_angleVariance(angleVariance);
  builder_.add_angle(angle);
  builder_.add_lifespanMaxValue(lifespanMaxValue);
  builder_.add_lifespanMinValue(lifespanMinValue);
  builder_.add_speedMaxValue(speedMaxValue);
  builder_.add_speedMinValue(speedMinValue);
  builder_.add_lifetime(lifetime);
  builder_.add_interval(interval);
  builder_.add_attimeCreate(attimeCreate);
  builder_.add_maximumParticle(maximumParticle);
  builder_.add_priority(priority);
  builder_.add_SsEffectFunctionType(SsEffectFunctionType);
  return builder_.Finish();
}

struct EffectNode FLATBUFFERS_FINAL_CLASS : private flatbuffers::Table {
  enum {
    VT_ARRAYINDEX = 4,
    VT_PARENTINDEX = 6,
    VT_TYPE = 8,
    VT_CELLINDEX = 10,
    VT_BLENDTYPE = 12,
    VT_NUMBEHAVIOR = 14,
    VT_BEHAVIOR_TYPE = 16,
    VT_BEHAVIOR = 18
  };
  int16_t arrayIndex() const {
    return GetField<int16_t>(VT_ARRAYINDEX, 0);
  }
  int16_t parentIndex() const {
    return GetField<int16_t>(VT_PARENTINDEX, 0);
  }
  int16_t type() const {
    return GetField<int16_t>(VT_TYPE, 0);
  }
  int16_t cellIndex() const {
    return GetField<int16_t>(VT_CELLINDEX, 0);
  }
  int16_t blendType() const {
    return GetField<int16_t>(VT_BLENDTYPE, 0);
  }
  int16_t numBehavior() const {
    return GetField<int16_t>(VT_NUMBEHAVIOR, 0);
  }
  const flatbuffers::Vector<uint8_t> *Behavior_type() const {
    return GetPointer<const flatbuffers::Vector<uint8_t> *>(VT_BEHAVIOR_TYPE);
  }
  const flatbuffers::Vector<flatbuffers::Offset<void>> *Behavior() const {
    return GetPointer<const flatbuffers::Vector<flatbuffers::Offset<void>> *>(VT_BEHAVIOR);
  }
  bool Verify(flatbuffers::Verifier &verifier) const {
    return VerifyTableStart(verifier) &&
           VerifyField<int16_t>(verifier, VT_ARRAYINDEX) &&
           VerifyField<int16_t>(verifier, VT_PARENTINDEX) &&
           VerifyField<int16_t>(verifier, VT_TYPE) &&
           VerifyField<int16_t>(verifier, VT_CELLINDEX) &&
           VerifyField<int16_t>(verifier, VT_BLENDTYPE) &&
           VerifyField<int16_t>(verifier, VT_NUMBEHAVIOR) &&
           VerifyOffset(verifier, VT_BEHAVIOR_TYPE) &&
           verifier.Verify(Behavior_type()) &&
           VerifyOffset(verifier, VT_BEHAVIOR) &&
           verifier.Verify(Behavior()) &&
           VerifyEffectNodeBehaviorVector(verifier, Behavior(), Behavior_type()) &&
           verifier.EndTable();
  }
};

struct EffectNodeBuilder {
  flatbuffers::FlatBufferBuilder &fbb_;
  flatbuffers::uoffset_t start_;
  void add_arrayIndex(int16_t arrayIndex) {
    fbb_.AddElement<int16_t>(EffectNode::VT_ARRAYINDEX, arrayIndex, 0);
  }
  void add_parentIndex(int16_t parentIndex) {
    fbb_.AddElement<int16_t>(EffectNode::VT_PARENTINDEX, parentIndex, 0);
  }
  void add_type(int16_t type) {
    fbb_.AddElement<int16_t>(EffectNode::VT_TYPE, type, 0);
  }
  void add_cellIndex(int16_t cellIndex) {
    fbb_.AddElement<int16_t>(EffectNode::VT_CELLINDEX, cellIndex, 0);
  }
  void add_blendType(int16_t blendType) {
    fbb_.AddElement<int16_t>(EffectNode::VT_BLENDTYPE, blendType, 0);
  }
  void add_numBehavior(int16_t numBehavior) {
    fbb_.AddElement<int16_t>(EffectNode::VT_NUMBEHAVIOR, numBehavior, 0);
  }
  void add_Behavior_type(flatbuffers::Offset<flatbuffers::Vector<uint8_t>> Behavior_type) {
    fbb_.AddOffset(EffectNode::VT_BEHAVIOR_TYPE, Behavior_type);
  }
  void add_Behavior(flatbuffers::Offset<flatbuffers::Vector<flatbuffers::Offset<void>>> Behavior) {
    fbb_.AddOffset(EffectNode::VT_BEHAVIOR, Behavior);
  }
  explicit EffectNodeBuilder(flatbuffers::FlatBufferBuilder &_fbb)
        : fbb_(_fbb) {
    start_ = fbb_.StartTable();
  }
  EffectNodeBuilder &operator=(const EffectNodeBuilder &);
  flatbuffers::Offset<EffectNode> Finish() {
    const auto end = fbb_.EndTable(start_);
    auto o = flatbuffers::Offset<EffectNode>(end);
    return o;
  }
};

inline flatbuffers::Offset<EffectNode> CreateEffectNode(
    flatbuffers::FlatBufferBuilder &_fbb,
    int16_t arrayIndex = 0,
    int16_t parentIndex = 0,
    int16_t type = 0,
    int16_t cellIndex = 0,
    int16_t blendType = 0,
    int16_t numBehavior = 0,
    flatbuffers::Offset<flatbuffers::Vector<uint8_t>> Behavior_type = 0,
    flatbuffers::Offset<flatbuffers::Vector<flatbuffers::Offset<void>>> Behavior = 0) {
  EffectNodeBuilder builder_(_fbb);
  builder_.add_Behavior(Behavior);
  builder_.add_Behavior_type(Behavior_type);
  builder_.add_numBehavior(numBehavior);
  builder_.add_blendType(blendType);
  builder_.add_cellIndex(cellIndex);
  builder_.add_type(type);
  builder_.add_parentIndex(parentIndex);
  builder_.add_arrayIndex(arrayIndex);
  return builder_.Finish();
}

inline flatbuffers::Offset<EffectNode> CreateEffectNodeDirect(
    flatbuffers::FlatBufferBuilder &_fbb,
    int16_t arrayIndex = 0,
    int16_t parentIndex = 0,
    int16_t type = 0,
    int16_t cellIndex = 0,
    int16_t blendType = 0,
    int16_t numBehavior = 0,
    const std::vector<uint8_t> *Behavior_type = nullptr,
    const std::vector<flatbuffers::Offset<void>> *Behavior = nullptr) {
  return ss::ssfb::CreateEffectNode(
      _fbb,
      arrayIndex,
      parentIndex,
      type,
      cellIndex,
      blendType,
      numBehavior,
      Behavior_type ? _fbb.CreateVector<uint8_t>(*Behavior_type) : 0,
      Behavior ? _fbb.CreateVector<flatbuffers::Offset<void>>(*Behavior) : 0);
}

struct EffectFile FLATBUFFERS_FINAL_CLASS : private flatbuffers::Table {
  enum {
    VT_NAME = 4,
    VT_FPS = 6,
    VT_ISLOCKRANDSEED = 8,
    VT_LOCKRANDSEED = 10,
    VT_LAYOUTSCALEX = 12,
    VT_LAYOUTSCALEY = 14,
    VT_NUMNODELIST = 16,
    VT_EFFECTNODE = 18
  };
  const flatbuffers::String *name() const {
    return GetPointer<const flatbuffers::String *>(VT_NAME);
  }
  int16_t fps() const {
    return GetField<int16_t>(VT_FPS, 0);
  }
  int16_t isLockRandSeed() const {
    return GetField<int16_t>(VT_ISLOCKRANDSEED, 0);
  }
  int16_t lockRandSeed() const {
    return GetField<int16_t>(VT_LOCKRANDSEED, 0);
  }
  int16_t layoutScaleX() const {
    return GetField<int16_t>(VT_LAYOUTSCALEX, 0);
  }
  int16_t layoutScaleY() const {
    return GetField<int16_t>(VT_LAYOUTSCALEY, 0);
  }
  int16_t numNodeList() const {
    return GetField<int16_t>(VT_NUMNODELIST, 0);
  }
  const flatbuffers::Vector<flatbuffers::Offset<EffectNode>> *effectNode() const {
    return GetPointer<const flatbuffers::Vector<flatbuffers::Offset<EffectNode>> *>(VT_EFFECTNODE);
  }
  bool Verify(flatbuffers::Verifier &verifier) const {
    return VerifyTableStart(verifier) &&
           VerifyOffset(verifier, VT_NAME) &&
           verifier.Verify(name()) &&
           VerifyField<int16_t>(verifier, VT_FPS) &&
           VerifyField<int16_t>(verifier, VT_ISLOCKRANDSEED) &&
           VerifyField<int16_t>(verifier, VT_LOCKRANDSEED) &&
           VerifyField<int16_t>(verifier, VT_LAYOUTSCALEX) &&
           VerifyField<int16_t>(verifier, VT_LAYOUTSCALEY) &&
           VerifyField<int16_t>(verifier, VT_NUMNODELIST) &&
           VerifyOffset(verifier, VT_EFFECTNODE) &&
           verifier.Verify(effectNode()) &&
           verifier.VerifyVectorOfTables(effectNode()) &&
           verifier.EndTable();
  }
};

struct EffectFileBuilder {
  flatbuffers::FlatBufferBuilder &fbb_;
  flatbuffers::uoffset_t start_;
  void add_name(flatbuffers::Offset<flatbuffers::String> name) {
    fbb_.AddOffset(EffectFile::VT_NAME, name);
  }
  void add_fps(int16_t fps) {
    fbb_.AddElement<int16_t>(EffectFile::VT_FPS, fps, 0);
  }
  void add_isLockRandSeed(int16_t isLockRandSeed) {
    fbb_.AddElement<int16_t>(EffectFile::VT_ISLOCKRANDSEED, isLockRandSeed, 0);
  }
  void add_lockRandSeed(int16_t lockRandSeed) {
    fbb_.AddElement<int16_t>(EffectFile::VT_LOCKRANDSEED, lockRandSeed, 0);
  }
  void add_layoutScaleX(int16_t layoutScaleX) {
    fbb_.AddElement<int16_t>(EffectFile::VT_LAYOUTSCALEX, layoutScaleX, 0);
  }
  void add_layoutScaleY(int16_t layoutScaleY) {
    fbb_.AddElement<int16_t>(EffectFile::VT_LAYOUTSCALEY, layoutScaleY, 0);
  }
  void add_numNodeList(int16_t numNodeList) {
    fbb_.AddElement<int16_t>(EffectFile::VT_NUMNODELIST, numNodeList, 0);
  }
  void add_effectNode(flatbuffers::Offset<flatbuffers::Vector<flatbuffers::Offset<EffectNode>>> effectNode) {
    fbb_.AddOffset(EffectFile::VT_EFFECTNODE, effectNode);
  }
  explicit EffectFileBuilder(flatbuffers::FlatBufferBuilder &_fbb)
        : fbb_(_fbb) {
    start_ = fbb_.StartTable();
  }
  EffectFileBuilder &operator=(const EffectFileBuilder &);
  flatbuffers::Offset<EffectFile> Finish() {
    const auto end = fbb_.EndTable(start_);
    auto o = flatbuffers::Offset<EffectFile>(end);
    return o;
  }
};

inline flatbuffers::Offset<EffectFile> CreateEffectFile(
    flatbuffers::FlatBufferBuilder &_fbb,
    flatbuffers::Offset<flatbuffers::String> name = 0,
    int16_t fps = 0,
    int16_t isLockRandSeed = 0,
    int16_t lockRandSeed = 0,
    int16_t layoutScaleX = 0,
    int16_t layoutScaleY = 0,
    int16_t numNodeList = 0,
    flatbuffers::Offset<flatbuffers::Vector<flatbuffers::Offset<EffectNode>>> effectNode = 0) {
  EffectFileBuilder builder_(_fbb);
  builder_.add_effectNode(effectNode);
  builder_.add_name(name);
  builder_.add_numNodeList(numNodeList);
  builder_.add_layoutScaleY(layoutScaleY);
  builder_.add_layoutScaleX(layoutScaleX);
  builder_.add_lockRandSeed(lockRandSeed);
  builder_.add_isLockRandSeed(isLockRandSeed);
  builder_.add_fps(fps);
  return builder_.Finish();
}

inline flatbuffers::Offset<EffectFile> CreateEffectFileDirect(
    flatbuffers::FlatBufferBuilder &_fbb,
    const char *name = nullptr,
    int16_t fps = 0,
    int16_t isLockRandSeed = 0,
    int16_t lockRandSeed = 0,
    int16_t layoutScaleX = 0,
    int16_t layoutScaleY = 0,
    int16_t numNodeList = 0,
    const std::vector<flatbuffers::Offset<EffectNode>> *effectNode = nullptr) {
  return ss::ssfb::CreateEffectFile(
      _fbb,
      name ? _fbb.CreateString(name) : 0,
      fps,
      isLockRandSeed,
      lockRandSeed,
      layoutScaleX,
      layoutScaleY,
      numNodeList,
      effectNode ? _fbb.CreateVector<flatbuffers::Offset<EffectNode>>(*effectNode) : 0);
}

struct CellMap FLATBUFFERS_FINAL_CLASS : private flatbuffers::Table {
  enum {
    VT_NAME = 4,
    VT_IMAGEPATH = 6,
    VT_INDEX = 8,
    VT_WRAPMODE = 10,
    VT_FILTERMODE = 12
  };
  const flatbuffers::String *name() const {
    return GetPointer<const flatbuffers::String *>(VT_NAME);
  }
  const flatbuffers::String *imagePath() const {
    return GetPointer<const flatbuffers::String *>(VT_IMAGEPATH);
  }
  int16_t index() const {
    return GetField<int16_t>(VT_INDEX, 0);
  }
  int16_t wrapmode() const {
    return GetField<int16_t>(VT_WRAPMODE, 0);
  }
  int16_t filtermode() const {
    return GetField<int16_t>(VT_FILTERMODE, 0);
  }
  bool Verify(flatbuffers::Verifier &verifier) const {
    return VerifyTableStart(verifier) &&
           VerifyOffset(verifier, VT_NAME) &&
           verifier.Verify(name()) &&
           VerifyOffset(verifier, VT_IMAGEPATH) &&
           verifier.Verify(imagePath()) &&
           VerifyField<int16_t>(verifier, VT_INDEX) &&
           VerifyField<int16_t>(verifier, VT_WRAPMODE) &&
           VerifyField<int16_t>(verifier, VT_FILTERMODE) &&
           verifier.EndTable();
  }
};

struct CellMapBuilder {
  flatbuffers::FlatBufferBuilder &fbb_;
  flatbuffers::uoffset_t start_;
  void add_name(flatbuffers::Offset<flatbuffers::String> name) {
    fbb_.AddOffset(CellMap::VT_NAME, name);
  }
  void add_imagePath(flatbuffers::Offset<flatbuffers::String> imagePath) {
    fbb_.AddOffset(CellMap::VT_IMAGEPATH, imagePath);
  }
  void add_index(int16_t index) {
    fbb_.AddElement<int16_t>(CellMap::VT_INDEX, index, 0);
  }
  void add_wrapmode(int16_t wrapmode) {
    fbb_.AddElement<int16_t>(CellMap::VT_WRAPMODE, wrapmode, 0);
  }
  void add_filtermode(int16_t filtermode) {
    fbb_.AddElement<int16_t>(CellMap::VT_FILTERMODE, filtermode, 0);
  }
  explicit CellMapBuilder(flatbuffers::FlatBufferBuilder &_fbb)
        : fbb_(_fbb) {
    start_ = fbb_.StartTable();
  }
  CellMapBuilder &operator=(const CellMapBuilder &);
  flatbuffers::Offset<CellMap> Finish() {
    const auto end = fbb_.EndTable(start_);
    auto o = flatbuffers::Offset<CellMap>(end);
    return o;
  }
};

inline flatbuffers::Offset<CellMap> CreateCellMap(
    flatbuffers::FlatBufferBuilder &_fbb,
    flatbuffers::Offset<flatbuffers::String> name = 0,
    flatbuffers::Offset<flatbuffers::String> imagePath = 0,
    int16_t index = 0,
    int16_t wrapmode = 0,
    int16_t filtermode = 0) {
  CellMapBuilder builder_(_fbb);
  builder_.add_imagePath(imagePath);
  builder_.add_name(name);
  builder_.add_filtermode(filtermode);
  builder_.add_wrapmode(wrapmode);
  builder_.add_index(index);
  return builder_.Finish();
}

inline flatbuffers::Offset<CellMap> CreateCellMapDirect(
    flatbuffers::FlatBufferBuilder &_fbb,
    const char *name = nullptr,
    const char *imagePath = nullptr,
    int16_t index = 0,
    int16_t wrapmode = 0,
    int16_t filtermode = 0) {
  return ss::ssfb::CreateCellMap(
      _fbb,
      name ? _fbb.CreateString(name) : 0,
      imagePath ? _fbb.CreateString(imagePath) : 0,
      index,
      wrapmode,
      filtermode);
}

struct Cell FLATBUFFERS_FINAL_CLASS : private flatbuffers::Table {
  enum {
    VT_NAME = 4,
    VT_CELLMAP = 6,
    VT_INDEXINCELLMAP = 8,
    VT_X = 10,
    VT_Y = 12,
    VT_WIDTH = 14,
    VT_HEIGHT = 16,
    VT_PIVOT_X = 18,
    VT_PIVOT_Y = 20,
    VT_U1 = 22,
    VT_V1 = 24,
    VT_U2 = 26,
    VT_V2 = 28
  };
  const flatbuffers::String *name() const {
    return GetPointer<const flatbuffers::String *>(VT_NAME);
  }
  const CellMap *cellMap() const {
    return GetPointer<const CellMap *>(VT_CELLMAP);
  }
  int16_t indexInCellMap() const {
    return GetField<int16_t>(VT_INDEXINCELLMAP, 0);
  }
  int16_t x() const {
    return GetField<int16_t>(VT_X, 0);
  }
  int16_t y() const {
    return GetField<int16_t>(VT_Y, 0);
  }
  int16_t width() const {
    return GetField<int16_t>(VT_WIDTH, 0);
  }
  int16_t height() const {
    return GetField<int16_t>(VT_HEIGHT, 0);
  }
  float pivot_x() const {
    return GetField<float>(VT_PIVOT_X, 0.0f);
  }
  float pivot_y() const {
    return GetField<float>(VT_PIVOT_Y, 0.0f);
  }
  float u1() const {
    return GetField<float>(VT_U1, 0.0f);
  }
  float v1() const {
    return GetField<float>(VT_V1, 0.0f);
  }
  float u2() const {
    return GetField<float>(VT_U2, 0.0f);
  }
  float v2() const {
    return GetField<float>(VT_V2, 0.0f);
  }
  bool Verify(flatbuffers::Verifier &verifier) const {
    return VerifyTableStart(verifier) &&
           VerifyOffset(verifier, VT_NAME) &&
           verifier.Verify(name()) &&
           VerifyOffset(verifier, VT_CELLMAP) &&
           verifier.VerifyTable(cellMap()) &&
           VerifyField<int16_t>(verifier, VT_INDEXINCELLMAP) &&
           VerifyField<int16_t>(verifier, VT_X) &&
           VerifyField<int16_t>(verifier, VT_Y) &&
           VerifyField<int16_t>(verifier, VT_WIDTH) &&
           VerifyField<int16_t>(verifier, VT_HEIGHT) &&
           VerifyField<float>(verifier, VT_PIVOT_X) &&
           VerifyField<float>(verifier, VT_PIVOT_Y) &&
           VerifyField<float>(verifier, VT_U1) &&
           VerifyField<float>(verifier, VT_V1) &&
           VerifyField<float>(verifier, VT_U2) &&
           VerifyField<float>(verifier, VT_V2) &&
           verifier.EndTable();
  }
};

struct CellBuilder {
  flatbuffers::FlatBufferBuilder &fbb_;
  flatbuffers::uoffset_t start_;
  void add_name(flatbuffers::Offset<flatbuffers::String> name) {
    fbb_.AddOffset(Cell::VT_NAME, name);
  }
  void add_cellMap(flatbuffers::Offset<CellMap> cellMap) {
    fbb_.AddOffset(Cell::VT_CELLMAP, cellMap);
  }
  void add_indexInCellMap(int16_t indexInCellMap) {
    fbb_.AddElement<int16_t>(Cell::VT_INDEXINCELLMAP, indexInCellMap, 0);
  }
  void add_x(int16_t x) {
    fbb_.AddElement<int16_t>(Cell::VT_X, x, 0);
  }
  void add_y(int16_t y) {
    fbb_.AddElement<int16_t>(Cell::VT_Y, y, 0);
  }
  void add_width(int16_t width) {
    fbb_.AddElement<int16_t>(Cell::VT_WIDTH, width, 0);
  }
  void add_height(int16_t height) {
    fbb_.AddElement<int16_t>(Cell::VT_HEIGHT, height, 0);
  }
  void add_pivot_x(float pivot_x) {
    fbb_.AddElement<float>(Cell::VT_PIVOT_X, pivot_x, 0.0f);
  }
  void add_pivot_y(float pivot_y) {
    fbb_.AddElement<float>(Cell::VT_PIVOT_Y, pivot_y, 0.0f);
  }
  void add_u1(float u1) {
    fbb_.AddElement<float>(Cell::VT_U1, u1, 0.0f);
  }
  void add_v1(float v1) {
    fbb_.AddElement<float>(Cell::VT_V1, v1, 0.0f);
  }
  void add_u2(float u2) {
    fbb_.AddElement<float>(Cell::VT_U2, u2, 0.0f);
  }
  void add_v2(float v2) {
    fbb_.AddElement<float>(Cell::VT_V2, v2, 0.0f);
  }
  explicit CellBuilder(flatbuffers::FlatBufferBuilder &_fbb)
        : fbb_(_fbb) {
    start_ = fbb_.StartTable();
  }
  CellBuilder &operator=(const CellBuilder &);
  flatbuffers::Offset<Cell> Finish() {
    const auto end = fbb_.EndTable(start_);
    auto o = flatbuffers::Offset<Cell>(end);
    return o;
  }
};

inline flatbuffers::Offset<Cell> CreateCell(
    flatbuffers::FlatBufferBuilder &_fbb,
    flatbuffers::Offset<flatbuffers::String> name = 0,
    flatbuffers::Offset<CellMap> cellMap = 0,
    int16_t indexInCellMap = 0,
    int16_t x = 0,
    int16_t y = 0,
    int16_t width = 0,
    int16_t height = 0,
    float pivot_x = 0.0f,
    float pivot_y = 0.0f,
    float u1 = 0.0f,
    float v1 = 0.0f,
    float u2 = 0.0f,
    float v2 = 0.0f) {
  CellBuilder builder_(_fbb);
  builder_.add_v2(v2);
  builder_.add_u2(u2);
  builder_.add_v1(v1);
  builder_.add_u1(u1);
  builder_.add_pivot_y(pivot_y);
  builder_.add_pivot_x(pivot_x);
  builder_.add_cellMap(cellMap);
  builder_.add_name(name);
  builder_.add_height(height);
  builder_.add_width(width);
  builder_.add_y(y);
  builder_.add_x(x);
  builder_.add_indexInCellMap(indexInCellMap);
  return builder_.Finish();
}

inline flatbuffers::Offset<Cell> CreateCellDirect(
    flatbuffers::FlatBufferBuilder &_fbb,
    const char *name = nullptr,
    flatbuffers::Offset<CellMap> cellMap = 0,
    int16_t indexInCellMap = 0,
    int16_t x = 0,
    int16_t y = 0,
    int16_t width = 0,
    int16_t height = 0,
    float pivot_x = 0.0f,
    float pivot_y = 0.0f,
    float u1 = 0.0f,
    float v1 = 0.0f,
    float u2 = 0.0f,
    float v2 = 0.0f) {
  return ss::ssfb::CreateCell(
      _fbb,
      name ? _fbb.CreateString(name) : 0,
      cellMap,
      indexInCellMap,
      x,
      y,
      width,
      height,
      pivot_x,
      pivot_y,
      u1,
      v1,
      u2,
      v2);
}

struct meshDataUVItem FLATBUFFERS_FINAL_CLASS : private flatbuffers::Table {
  enum {
    VT_ISBIND = 4,
    VT_MESHSIZE = 6,
    VT_U = 8,
    VT_V = 10
  };
  int32_t isBind() const {
    return GetField<int32_t>(VT_ISBIND, 0);
  }
  int32_t meshSize() const {
    return GetField<int32_t>(VT_MESHSIZE, 0);
  }
  const flatbuffers::Vector<float> *u() const {
    return GetPointer<const flatbuffers::Vector<float> *>(VT_U);
  }
  const flatbuffers::Vector<float> *v() const {
    return GetPointer<const flatbuffers::Vector<float> *>(VT_V);
  }
  bool Verify(flatbuffers::Verifier &verifier) const {
    return VerifyTableStart(verifier) &&
           VerifyField<int32_t>(verifier, VT_ISBIND) &&
           VerifyField<int32_t>(verifier, VT_MESHSIZE) &&
           VerifyOffset(verifier, VT_U) &&
           verifier.Verify(u()) &&
           VerifyOffset(verifier, VT_V) &&
           verifier.Verify(v()) &&
           verifier.EndTable();
  }
};

struct meshDataUVItemBuilder {
  flatbuffers::FlatBufferBuilder &fbb_;
  flatbuffers::uoffset_t start_;
  void add_isBind(int32_t isBind) {
    fbb_.AddElement<int32_t>(meshDataUVItem::VT_ISBIND, isBind, 0);
  }
  void add_meshSize(int32_t meshSize) {
    fbb_.AddElement<int32_t>(meshDataUVItem::VT_MESHSIZE, meshSize, 0);
  }
  void add_u(flatbuffers::Offset<flatbuffers::Vector<float>> u) {
    fbb_.AddOffset(meshDataUVItem::VT_U, u);
  }
  void add_v(flatbuffers::Offset<flatbuffers::Vector<float>> v) {
    fbb_.AddOffset(meshDataUVItem::VT_V, v);
  }
  explicit meshDataUVItemBuilder(flatbuffers::FlatBufferBuilder &_fbb)
        : fbb_(_fbb) {
    start_ = fbb_.StartTable();
  }
  meshDataUVItemBuilder &operator=(const meshDataUVItemBuilder &);
  flatbuffers::Offset<meshDataUVItem> Finish() {
    const auto end = fbb_.EndTable(start_);
    auto o = flatbuffers::Offset<meshDataUVItem>(end);
    return o;
  }
};

inline flatbuffers::Offset<meshDataUVItem> CreatemeshDataUVItem(
    flatbuffers::FlatBufferBuilder &_fbb,
    int32_t isBind = 0,
    int32_t meshSize = 0,
    flatbuffers::Offset<flatbuffers::Vector<float>> u = 0,
    flatbuffers::Offset<flatbuffers::Vector<float>> v = 0) {
  meshDataUVItemBuilder builder_(_fbb);
  builder_.add_v(v);
  builder_.add_u(u);
  builder_.add_meshSize(meshSize);
  builder_.add_isBind(isBind);
  return builder_.Finish();
}

inline flatbuffers::Offset<meshDataUVItem> CreatemeshDataUVItemDirect(
    flatbuffers::FlatBufferBuilder &_fbb,
    int32_t isBind = 0,
    int32_t meshSize = 0,
    const std::vector<float> *u = nullptr,
    const std::vector<float> *v = nullptr) {
  return ss::ssfb::CreatemeshDataUVItem(
      _fbb,
      isBind,
      meshSize,
      u ? _fbb.CreateVector<float>(*u) : 0,
      v ? _fbb.CreateVector<float>(*v) : 0);
}

struct meshDataUVEmpty FLATBUFFERS_FINAL_CLASS : private flatbuffers::Table {
  enum {
    VT_ISBIND = 4
  };
  int32_t isBind() const {
    return GetField<int32_t>(VT_ISBIND, 0);
  }
  bool Verify(flatbuffers::Verifier &verifier) const {
    return VerifyTableStart(verifier) &&
           VerifyField<int32_t>(verifier, VT_ISBIND) &&
           verifier.EndTable();
  }
};

struct meshDataUVEmptyBuilder {
  flatbuffers::FlatBufferBuilder &fbb_;
  flatbuffers::uoffset_t start_;
  void add_isBind(int32_t isBind) {
    fbb_.AddElement<int32_t>(meshDataUVEmpty::VT_ISBIND, isBind, 0);
  }
  explicit meshDataUVEmptyBuilder(flatbuffers::FlatBufferBuilder &_fbb)
        : fbb_(_fbb) {
    start_ = fbb_.StartTable();
  }
  meshDataUVEmptyBuilder &operator=(const meshDataUVEmptyBuilder &);
  flatbuffers::Offset<meshDataUVEmpty> Finish() {
    const auto end = fbb_.EndTable(start_);
    auto o = flatbuffers::Offset<meshDataUVEmpty>(end);
    return o;
  }
};

inline flatbuffers::Offset<meshDataUVEmpty> CreatemeshDataUVEmpty(
    flatbuffers::FlatBufferBuilder &_fbb,
    int32_t isBind = 0) {
  meshDataUVEmptyBuilder builder_(_fbb);
  builder_.add_isBind(isBind);
  return builder_.Finish();
}

struct meshDataIndices FLATBUFFERS_FINAL_CLASS : private flatbuffers::Table {
  enum {
    VT_INDICES = 4
  };
  const flatbuffers::Vector<float> *indices() const {
    return GetPointer<const flatbuffers::Vector<float> *>(VT_INDICES);
  }
  bool Verify(flatbuffers::Verifier &verifier) const {
    return VerifyTableStart(verifier) &&
           VerifyOffset(verifier, VT_INDICES) &&
           verifier.Verify(indices()) &&
           verifier.EndTable();
  }
};

struct meshDataIndicesBuilder {
  flatbuffers::FlatBufferBuilder &fbb_;
  flatbuffers::uoffset_t start_;
  void add_indices(flatbuffers::Offset<flatbuffers::Vector<float>> indices) {
    fbb_.AddOffset(meshDataIndices::VT_INDICES, indices);
  }
  explicit meshDataIndicesBuilder(flatbuffers::FlatBufferBuilder &_fbb)
        : fbb_(_fbb) {
    start_ = fbb_.StartTable();
  }
  meshDataIndicesBuilder &operator=(const meshDataIndicesBuilder &);
  flatbuffers::Offset<meshDataIndices> Finish() {
    const auto end = fbb_.EndTable(start_);
    auto o = flatbuffers::Offset<meshDataIndices>(end);
    return o;
  }
};

inline flatbuffers::Offset<meshDataIndices> CreatemeshDataIndices(
    flatbuffers::FlatBufferBuilder &_fbb,
    flatbuffers::Offset<flatbuffers::Vector<float>> indices = 0) {
  meshDataIndicesBuilder builder_(_fbb);
  builder_.add_indices(indices);
  return builder_.Finish();
}

inline flatbuffers::Offset<meshDataIndices> CreatemeshDataIndicesDirect(
    flatbuffers::FlatBufferBuilder &_fbb,
    const std::vector<float> *indices = nullptr) {
  return ss::ssfb::CreatemeshDataIndices(
      _fbb,
      indices ? _fbb.CreateVector<float>(*indices) : 0);
}

struct frameDataIndex FLATBUFFERS_FINAL_CLASS : private flatbuffers::Table {
  enum {
    VT_DATA = 4
  };
  const flatbuffers::Vector<float> *data() const {
    return GetPointer<const flatbuffers::Vector<float> *>(VT_DATA);
  }
  bool Verify(flatbuffers::Verifier &verifier) const {
    return VerifyTableStart(verifier) &&
           VerifyOffset(verifier, VT_DATA) &&
           verifier.Verify(data()) &&
           verifier.EndTable();
  }
};

struct frameDataIndexBuilder {
  flatbuffers::FlatBufferBuilder &fbb_;
  flatbuffers::uoffset_t start_;
  void add_data(flatbuffers::Offset<flatbuffers::Vector<float>> data) {
    fbb_.AddOffset(frameDataIndex::VT_DATA, data);
  }
  explicit frameDataIndexBuilder(flatbuffers::FlatBufferBuilder &_fbb)
        : fbb_(_fbb) {
    start_ = fbb_.StartTable();
  }
  frameDataIndexBuilder &operator=(const frameDataIndexBuilder &);
  flatbuffers::Offset<frameDataIndex> Finish() {
    const auto end = fbb_.EndTable(start_);
    auto o = flatbuffers::Offset<frameDataIndex>(end);
    return o;
  }
};

inline flatbuffers::Offset<frameDataIndex> CreateframeDataIndex(
    flatbuffers::FlatBufferBuilder &_fbb,
    flatbuffers::Offset<flatbuffers::Vector<float>> data = 0) {
  frameDataIndexBuilder builder_(_fbb);
  builder_.add_data(data);
  return builder_.Finish();
}

inline flatbuffers::Offset<frameDataIndex> CreateframeDataIndexDirect(
    flatbuffers::FlatBufferBuilder &_fbb,
    const std::vector<float> *data = nullptr) {
  return ss::ssfb::CreateframeDataIndex(
      _fbb,
      data ? _fbb.CreateVector<float>(*data) : 0);
}

struct userDataInteger FLATBUFFERS_FINAL_CLASS : private flatbuffers::Table {
  enum {
    VT_INTEGER = 4
  };
  int32_t integer() const {
    return GetField<int32_t>(VT_INTEGER, 0);
  }
  bool Verify(flatbuffers::Verifier &verifier) const {
    return VerifyTableStart(verifier) &&
           VerifyField<int32_t>(verifier, VT_INTEGER) &&
           verifier.EndTable();
  }
};

struct userDataIntegerBuilder {
  flatbuffers::FlatBufferBuilder &fbb_;
  flatbuffers::uoffset_t start_;
  void add_integer(int32_t integer) {
    fbb_.AddElement<int32_t>(userDataInteger::VT_INTEGER, integer, 0);
  }
  explicit userDataIntegerBuilder(flatbuffers::FlatBufferBuilder &_fbb)
        : fbb_(_fbb) {
    start_ = fbb_.StartTable();
  }
  userDataIntegerBuilder &operator=(const userDataIntegerBuilder &);
  flatbuffers::Offset<userDataInteger> Finish() {
    const auto end = fbb_.EndTable(start_);
    auto o = flatbuffers::Offset<userDataInteger>(end);
    return o;
  }
};

inline flatbuffers::Offset<userDataInteger> CreateuserDataInteger(
    flatbuffers::FlatBufferBuilder &_fbb,
    int32_t integer = 0) {
  userDataIntegerBuilder builder_(_fbb);
  builder_.add_integer(integer);
  return builder_.Finish();
}

struct userDataRect FLATBUFFERS_FINAL_CLASS : private flatbuffers::Table {
  enum {
    VT_X = 4,
    VT_Y = 6,
    VT_W = 8,
    VT_H = 10
  };
  int32_t x() const {
    return GetField<int32_t>(VT_X, 0);
  }
  int32_t y() const {
    return GetField<int32_t>(VT_Y, 0);
  }
  int32_t w() const {
    return GetField<int32_t>(VT_W, 0);
  }
  int32_t h() const {
    return GetField<int32_t>(VT_H, 0);
  }
  bool Verify(flatbuffers::Verifier &verifier) const {
    return VerifyTableStart(verifier) &&
           VerifyField<int32_t>(verifier, VT_X) &&
           VerifyField<int32_t>(verifier, VT_Y) &&
           VerifyField<int32_t>(verifier, VT_W) &&
           VerifyField<int32_t>(verifier, VT_H) &&
           verifier.EndTable();
  }
};

struct userDataRectBuilder {
  flatbuffers::FlatBufferBuilder &fbb_;
  flatbuffers::uoffset_t start_;
  void add_x(int32_t x) {
    fbb_.AddElement<int32_t>(userDataRect::VT_X, x, 0);
  }
  void add_y(int32_t y) {
    fbb_.AddElement<int32_t>(userDataRect::VT_Y, y, 0);
  }
  void add_w(int32_t w) {
    fbb_.AddElement<int32_t>(userDataRect::VT_W, w, 0);
  }
  void add_h(int32_t h) {
    fbb_.AddElement<int32_t>(userDataRect::VT_H, h, 0);
  }
  explicit userDataRectBuilder(flatbuffers::FlatBufferBuilder &_fbb)
        : fbb_(_fbb) {
    start_ = fbb_.StartTable();
  }
  userDataRectBuilder &operator=(const userDataRectBuilder &);
  flatbuffers::Offset<userDataRect> Finish() {
    const auto end = fbb_.EndTable(start_);
    auto o = flatbuffers::Offset<userDataRect>(end);
    return o;
  }
};

inline flatbuffers::Offset<userDataRect> CreateuserDataRect(
    flatbuffers::FlatBufferBuilder &_fbb,
    int32_t x = 0,
    int32_t y = 0,
    int32_t w = 0,
    int32_t h = 0) {
  userDataRectBuilder builder_(_fbb);
  builder_.add_h(h);
  builder_.add_w(w);
  builder_.add_y(y);
  builder_.add_x(x);
  return builder_.Finish();
}

struct userDataPoint FLATBUFFERS_FINAL_CLASS : private flatbuffers::Table {
  enum {
    VT_X = 4,
    VT_Y = 6
  };
  int32_t x() const {
    return GetField<int32_t>(VT_X, 0);
  }
  int32_t y() const {
    return GetField<int32_t>(VT_Y, 0);
  }
  bool Verify(flatbuffers::Verifier &verifier) const {
    return VerifyTableStart(verifier) &&
           VerifyField<int32_t>(verifier, VT_X) &&
           VerifyField<int32_t>(verifier, VT_Y) &&
           verifier.EndTable();
  }
};

struct userDataPointBuilder {
  flatbuffers::FlatBufferBuilder &fbb_;
  flatbuffers::uoffset_t start_;
  void add_x(int32_t x) {
    fbb_.AddElement<int32_t>(userDataPoint::VT_X, x, 0);
  }
  void add_y(int32_t y) {
    fbb_.AddElement<int32_t>(userDataPoint::VT_Y, y, 0);
  }
  explicit userDataPointBuilder(flatbuffers::FlatBufferBuilder &_fbb)
        : fbb_(_fbb) {
    start_ = fbb_.StartTable();
  }
  userDataPointBuilder &operator=(const userDataPointBuilder &);
  flatbuffers::Offset<userDataPoint> Finish() {
    const auto end = fbb_.EndTable(start_);
    auto o = flatbuffers::Offset<userDataPoint>(end);
    return o;
  }
};

inline flatbuffers::Offset<userDataPoint> CreateuserDataPoint(
    flatbuffers::FlatBufferBuilder &_fbb,
    int32_t x = 0,
    int32_t y = 0) {
  userDataPointBuilder builder_(_fbb);
  builder_.add_y(y);
  builder_.add_x(x);
  return builder_.Finish();
}

struct userDataString FLATBUFFERS_FINAL_CLASS : private flatbuffers::Table {
  enum {
    VT_LENGTH = 4,
    VT_DATA = 6
  };
  int32_t length() const {
    return GetField<int32_t>(VT_LENGTH, 0);
  }
  const flatbuffers::String *data() const {
    return GetPointer<const flatbuffers::String *>(VT_DATA);
  }
  bool Verify(flatbuffers::Verifier &verifier) const {
    return VerifyTableStart(verifier) &&
           VerifyField<int32_t>(verifier, VT_LENGTH) &&
           VerifyOffset(verifier, VT_DATA) &&
           verifier.Verify(data()) &&
           verifier.EndTable();
  }
};

struct userDataStringBuilder {
  flatbuffers::FlatBufferBuilder &fbb_;
  flatbuffers::uoffset_t start_;
  void add_length(int32_t length) {
    fbb_.AddElement<int32_t>(userDataString::VT_LENGTH, length, 0);
  }
  void add_data(flatbuffers::Offset<flatbuffers::String> data) {
    fbb_.AddOffset(userDataString::VT_DATA, data);
  }
  explicit userDataStringBuilder(flatbuffers::FlatBufferBuilder &_fbb)
        : fbb_(_fbb) {
    start_ = fbb_.StartTable();
  }
  userDataStringBuilder &operator=(const userDataStringBuilder &);
  flatbuffers::Offset<userDataString> Finish() {
    const auto end = fbb_.EndTable(start_);
    auto o = flatbuffers::Offset<userDataString>(end);
    return o;
  }
};

inline flatbuffers::Offset<userDataString> CreateuserDataString(
    flatbuffers::FlatBufferBuilder &_fbb,
    int32_t length = 0,
    flatbuffers::Offset<flatbuffers::String> data = 0) {
  userDataStringBuilder builder_(_fbb);
  builder_.add_data(data);
  builder_.add_length(length);
  return builder_.Finish();
}

inline flatbuffers::Offset<userDataString> CreateuserDataStringDirect(
    flatbuffers::FlatBufferBuilder &_fbb,
    int32_t length = 0,
    const char *data = nullptr) {
  return ss::ssfb::CreateuserDataString(
      _fbb,
      length,
      data ? _fbb.CreateString(data) : 0);
}

struct userDataItem FLATBUFFERS_FINAL_CLASS : private flatbuffers::Table {
  enum {
    VT_FLAGS = 4,
    VT_ARRAYINDEX = 6,
    VT_DATA_TYPE = 8,
    VT_DATA = 10
  };
  int16_t flags() const {
    return GetField<int16_t>(VT_FLAGS, 0);
  }
  int16_t arrayIndex() const {
    return GetField<int16_t>(VT_ARRAYINDEX, 0);
  }
  const flatbuffers::Vector<uint8_t> *data_type() const {
    return GetPointer<const flatbuffers::Vector<uint8_t> *>(VT_DATA_TYPE);
  }
  const flatbuffers::Vector<flatbuffers::Offset<void>> *data() const {
    return GetPointer<const flatbuffers::Vector<flatbuffers::Offset<void>> *>(VT_DATA);
  }
  bool Verify(flatbuffers::Verifier &verifier) const {
    return VerifyTableStart(verifier) &&
           VerifyField<int16_t>(verifier, VT_FLAGS) &&
           VerifyField<int16_t>(verifier, VT_ARRAYINDEX) &&
           VerifyOffset(verifier, VT_DATA_TYPE) &&
           verifier.Verify(data_type()) &&
           VerifyOffset(verifier, VT_DATA) &&
           verifier.Verify(data()) &&
           VerifyuserDataValueVector(verifier, data(), data_type()) &&
           verifier.EndTable();
  }
};

struct userDataItemBuilder {
  flatbuffers::FlatBufferBuilder &fbb_;
  flatbuffers::uoffset_t start_;
  void add_flags(int16_t flags) {
    fbb_.AddElement<int16_t>(userDataItem::VT_FLAGS, flags, 0);
  }
  void add_arrayIndex(int16_t arrayIndex) {
    fbb_.AddElement<int16_t>(userDataItem::VT_ARRAYINDEX, arrayIndex, 0);
  }
  void add_data_type(flatbuffers::Offset<flatbuffers::Vector<uint8_t>> data_type) {
    fbb_.AddOffset(userDataItem::VT_DATA_TYPE, data_type);
  }
  void add_data(flatbuffers::Offset<flatbuffers::Vector<flatbuffers::Offset<void>>> data) {
    fbb_.AddOffset(userDataItem::VT_DATA, data);
  }
  explicit userDataItemBuilder(flatbuffers::FlatBufferBuilder &_fbb)
        : fbb_(_fbb) {
    start_ = fbb_.StartTable();
  }
  userDataItemBuilder &operator=(const userDataItemBuilder &);
  flatbuffers::Offset<userDataItem> Finish() {
    const auto end = fbb_.EndTable(start_);
    auto o = flatbuffers::Offset<userDataItem>(end);
    return o;
  }
};

inline flatbuffers::Offset<userDataItem> CreateuserDataItem(
    flatbuffers::FlatBufferBuilder &_fbb,
    int16_t flags = 0,
    int16_t arrayIndex = 0,
    flatbuffers::Offset<flatbuffers::Vector<uint8_t>> data_type = 0,
    flatbuffers::Offset<flatbuffers::Vector<flatbuffers::Offset<void>>> data = 0) {
  userDataItemBuilder builder_(_fbb);
  builder_.add_data(data);
  builder_.add_data_type(data_type);
  builder_.add_arrayIndex(arrayIndex);
  builder_.add_flags(flags);
  return builder_.Finish();
}

inline flatbuffers::Offset<userDataItem> CreateuserDataItemDirect(
    flatbuffers::FlatBufferBuilder &_fbb,
    int16_t flags = 0,
    int16_t arrayIndex = 0,
    const std::vector<uint8_t> *data_type = nullptr,
    const std::vector<flatbuffers::Offset<void>> *data = nullptr) {
  return ss::ssfb::CreateuserDataItem(
      _fbb,
      flags,
      arrayIndex,
      data_type ? _fbb.CreateVector<uint8_t>(*data_type) : 0,
      data ? _fbb.CreateVector<flatbuffers::Offset<void>>(*data) : 0);
}

struct userDataPerFrame FLATBUFFERS_FINAL_CLASS : private flatbuffers::Table {
  enum {
    VT_FRAMEINDEX = 4,
    VT_DATA = 6
  };
  int16_t frameIndex() const {
    return GetField<int16_t>(VT_FRAMEINDEX, 0);
  }
  const flatbuffers::Vector<flatbuffers::Offset<userDataItem>> *data() const {
    return GetPointer<const flatbuffers::Vector<flatbuffers::Offset<userDataItem>> *>(VT_DATA);
  }
  bool Verify(flatbuffers::Verifier &verifier) const {
    return VerifyTableStart(verifier) &&
           VerifyField<int16_t>(verifier, VT_FRAMEINDEX) &&
           VerifyOffset(verifier, VT_DATA) &&
           verifier.Verify(data()) &&
           verifier.VerifyVectorOfTables(data()) &&
           verifier.EndTable();
  }
};

struct userDataPerFrameBuilder {
  flatbuffers::FlatBufferBuilder &fbb_;
  flatbuffers::uoffset_t start_;
  void add_frameIndex(int16_t frameIndex) {
    fbb_.AddElement<int16_t>(userDataPerFrame::VT_FRAMEINDEX, frameIndex, 0);
  }
  void add_data(flatbuffers::Offset<flatbuffers::Vector<flatbuffers::Offset<userDataItem>>> data) {
    fbb_.AddOffset(userDataPerFrame::VT_DATA, data);
  }
  explicit userDataPerFrameBuilder(flatbuffers::FlatBufferBuilder &_fbb)
        : fbb_(_fbb) {
    start_ = fbb_.StartTable();
  }
  userDataPerFrameBuilder &operator=(const userDataPerFrameBuilder &);
  flatbuffers::Offset<userDataPerFrame> Finish() {
    const auto end = fbb_.EndTable(start_);
    auto o = flatbuffers::Offset<userDataPerFrame>(end);
    return o;
  }
};

inline flatbuffers::Offset<userDataPerFrame> CreateuserDataPerFrame(
    flatbuffers::FlatBufferBuilder &_fbb,
    int16_t frameIndex = 0,
    flatbuffers::Offset<flatbuffers::Vector<flatbuffers::Offset<userDataItem>>> data = 0) {
  userDataPerFrameBuilder builder_(_fbb);
  builder_.add_data(data);
  builder_.add_frameIndex(frameIndex);
  return builder_.Finish();
}

inline flatbuffers::Offset<userDataPerFrame> CreateuserDataPerFrameDirect(
    flatbuffers::FlatBufferBuilder &_fbb,
    int16_t frameIndex = 0,
    const std::vector<flatbuffers::Offset<userDataItem>> *data = nullptr) {
  return ss::ssfb::CreateuserDataPerFrame(
      _fbb,
      frameIndex,
      data ? _fbb.CreateVector<flatbuffers::Offset<userDataItem>>(*data) : 0);
}

struct labelDataItem FLATBUFFERS_FINAL_CLASS : private flatbuffers::Table {
  enum {
    VT_LABEL = 4,
    VT_FRAMEINDEX = 6
  };
  const flatbuffers::String *label() const {
    return GetPointer<const flatbuffers::String *>(VT_LABEL);
  }
  int16_t frameIndex() const {
    return GetField<int16_t>(VT_FRAMEINDEX, 0);
  }
  bool Verify(flatbuffers::Verifier &verifier) const {
    return VerifyTableStart(verifier) &&
           VerifyOffset(verifier, VT_LABEL) &&
           verifier.Verify(label()) &&
           VerifyField<int16_t>(verifier, VT_FRAMEINDEX) &&
           verifier.EndTable();
  }
};

struct labelDataItemBuilder {
  flatbuffers::FlatBufferBuilder &fbb_;
  flatbuffers::uoffset_t start_;
  void add_label(flatbuffers::Offset<flatbuffers::String> label) {
    fbb_.AddOffset(labelDataItem::VT_LABEL, label);
  }
  void add_frameIndex(int16_t frameIndex) {
    fbb_.AddElement<int16_t>(labelDataItem::VT_FRAMEINDEX, frameIndex, 0);
  }
  explicit labelDataItemBuilder(flatbuffers::FlatBufferBuilder &_fbb)
        : fbb_(_fbb) {
    start_ = fbb_.StartTable();
  }
  labelDataItemBuilder &operator=(const labelDataItemBuilder &);
  flatbuffers::Offset<labelDataItem> Finish() {
    const auto end = fbb_.EndTable(start_);
    auto o = flatbuffers::Offset<labelDataItem>(end);
    return o;
  }
};

inline flatbuffers::Offset<labelDataItem> CreatelabelDataItem(
    flatbuffers::FlatBufferBuilder &_fbb,
    flatbuffers::Offset<flatbuffers::String> label = 0,
    int16_t frameIndex = 0) {
  labelDataItemBuilder builder_(_fbb);
  builder_.add_label(label);
  builder_.add_frameIndex(frameIndex);
  return builder_.Finish();
}

inline flatbuffers::Offset<labelDataItem> CreatelabelDataItemDirect(
    flatbuffers::FlatBufferBuilder &_fbb,
    const char *label = nullptr,
    int16_t frameIndex = 0) {
  return ss::ssfb::CreatelabelDataItem(
      _fbb,
      label ? _fbb.CreateString(label) : 0,
      frameIndex);
}

struct AnimationData FLATBUFFERS_FINAL_CLASS : private flatbuffers::Table {
  enum {
    VT_NAME = 4,
    VT_DEFAULTDATA = 6,
    VT_FRAMEDATA = 8,
    VT_USERDATA = 10,
    VT_LABELDATA = 12,
    VT_MESHSDATAUV_TYPE = 14,
    VT_MESHSDATAUV = 16,
    VT_MESHSDATAINDICES = 18,
    VT_STARTFRAMES = 20,
    VT_ENDFRAMES = 22,
    VT_TOTALFRAMES = 24,
    VT_FPS = 26,
    VT_LABELNUM = 28,
    VT_CANVASSIZEW = 30,
    VT_CANVASSIZEH = 32,
    VT_CANVASPVOTX = 34,
    VT_CANVASPVOTY = 36
  };
  const flatbuffers::String *name() const {
    return GetPointer<const flatbuffers::String *>(VT_NAME);
  }
  const flatbuffers::Vector<flatbuffers::Offset<AnimationInitialData>> *defaultData() const {
    return GetPointer<const flatbuffers::Vector<flatbuffers::Offset<AnimationInitialData>> *>(VT_DEFAULTDATA);
  }
  const flatbuffers::Vector<flatbuffers::Offset<frameDataIndex>> *frameData() const {
    return GetPointer<const flatbuffers::Vector<flatbuffers::Offset<frameDataIndex>> *>(VT_FRAMEDATA);
  }
  const flatbuffers::Vector<flatbuffers::Offset<userDataPerFrame>> *userData() const {
    return GetPointer<const flatbuffers::Vector<flatbuffers::Offset<userDataPerFrame>> *>(VT_USERDATA);
  }
  const flatbuffers::Vector<flatbuffers::Offset<labelDataItem>> *labelData() const {
    return GetPointer<const flatbuffers::Vector<flatbuffers::Offset<labelDataItem>> *>(VT_LABELDATA);
  }
  const flatbuffers::Vector<uint8_t> *meshsDataUV_type() const {
    return GetPointer<const flatbuffers::Vector<uint8_t> *>(VT_MESHSDATAUV_TYPE);
  }
  const flatbuffers::Vector<flatbuffers::Offset<void>> *meshsDataUV() const {
    return GetPointer<const flatbuffers::Vector<flatbuffers::Offset<void>> *>(VT_MESHSDATAUV);
  }
  const flatbuffers::Vector<flatbuffers::Offset<meshDataIndices>> *meshsDataIndices() const {
    return GetPointer<const flatbuffers::Vector<flatbuffers::Offset<meshDataIndices>> *>(VT_MESHSDATAINDICES);
  }
  int16_t startFrames() const {
    return GetField<int16_t>(VT_STARTFRAMES, 0);
  }
  int16_t endFrames() const {
    return GetField<int16_t>(VT_ENDFRAMES, 0);
  }
  int16_t totalFrames() const {
    return GetField<int16_t>(VT_TOTALFRAMES, 0);
  }
  int16_t fps() const {
    return GetField<int16_t>(VT_FPS, 0);
  }
  int16_t labelNum() const {
    return GetField<int16_t>(VT_LABELNUM, 0);
  }
  int16_t canvasSizeW() const {
    return GetField<int16_t>(VT_CANVASSIZEW, 0);
  }
  int16_t canvasSizeH() const {
    return GetField<int16_t>(VT_CANVASSIZEH, 0);
  }
  float canvasPvotX() const {
    return GetField<float>(VT_CANVASPVOTX, 0.0f);
  }
  float canvasPvotY() const {
    return GetField<float>(VT_CANVASPVOTY, 0.0f);
  }
  bool Verify(flatbuffers::Verifier &verifier) const {
    return VerifyTableStart(verifier) &&
           VerifyOffset(verifier, VT_NAME) &&
           verifier.Verify(name()) &&
           VerifyOffset(verifier, VT_DEFAULTDATA) &&
           verifier.Verify(defaultData()) &&
           verifier.VerifyVectorOfTables(defaultData()) &&
           VerifyOffset(verifier, VT_FRAMEDATA) &&
           verifier.Verify(frameData()) &&
           verifier.VerifyVectorOfTables(frameData()) &&
           VerifyOffset(verifier, VT_USERDATA) &&
           verifier.Verify(userData()) &&
           verifier.VerifyVectorOfTables(userData()) &&
           VerifyOffset(verifier, VT_LABELDATA) &&
           verifier.Verify(labelData()) &&
           verifier.VerifyVectorOfTables(labelData()) &&
           VerifyOffset(verifier, VT_MESHSDATAUV_TYPE) &&
           verifier.Verify(meshsDataUV_type()) &&
           VerifyOffset(verifier, VT_MESHSDATAUV) &&
           verifier.Verify(meshsDataUV()) &&
           VerifymeshDataUVValueVector(verifier, meshsDataUV(), meshsDataUV_type()) &&
           VerifyOffset(verifier, VT_MESHSDATAINDICES) &&
           verifier.Verify(meshsDataIndices()) &&
           verifier.VerifyVectorOfTables(meshsDataIndices()) &&
           VerifyField<int16_t>(verifier, VT_STARTFRAMES) &&
           VerifyField<int16_t>(verifier, VT_ENDFRAMES) &&
           VerifyField<int16_t>(verifier, VT_TOTALFRAMES) &&
           VerifyField<int16_t>(verifier, VT_FPS) &&
           VerifyField<int16_t>(verifier, VT_LABELNUM) &&
           VerifyField<int16_t>(verifier, VT_CANVASSIZEW) &&
           VerifyField<int16_t>(verifier, VT_CANVASSIZEH) &&
           VerifyField<float>(verifier, VT_CANVASPVOTX) &&
           VerifyField<float>(verifier, VT_CANVASPVOTY) &&
           verifier.EndTable();
  }
};

struct AnimationDataBuilder {
  flatbuffers::FlatBufferBuilder &fbb_;
  flatbuffers::uoffset_t start_;
  void add_name(flatbuffers::Offset<flatbuffers::String> name) {
    fbb_.AddOffset(AnimationData::VT_NAME, name);
  }
  void add_defaultData(flatbuffers::Offset<flatbuffers::Vector<flatbuffers::Offset<AnimationInitialData>>> defaultData) {
    fbb_.AddOffset(AnimationData::VT_DEFAULTDATA, defaultData);
  }
  void add_frameData(flatbuffers::Offset<flatbuffers::Vector<flatbuffers::Offset<frameDataIndex>>> frameData) {
    fbb_.AddOffset(AnimationData::VT_FRAMEDATA, frameData);
  }
  void add_userData(flatbuffers::Offset<flatbuffers::Vector<flatbuffers::Offset<userDataPerFrame>>> userData) {
    fbb_.AddOffset(AnimationData::VT_USERDATA, userData);
  }
  void add_labelData(flatbuffers::Offset<flatbuffers::Vector<flatbuffers::Offset<labelDataItem>>> labelData) {
    fbb_.AddOffset(AnimationData::VT_LABELDATA, labelData);
  }
  void add_meshsDataUV_type(flatbuffers::Offset<flatbuffers::Vector<uint8_t>> meshsDataUV_type) {
    fbb_.AddOffset(AnimationData::VT_MESHSDATAUV_TYPE, meshsDataUV_type);
  }
  void add_meshsDataUV(flatbuffers::Offset<flatbuffers::Vector<flatbuffers::Offset<void>>> meshsDataUV) {
    fbb_.AddOffset(AnimationData::VT_MESHSDATAUV, meshsDataUV);
  }
  void add_meshsDataIndices(flatbuffers::Offset<flatbuffers::Vector<flatbuffers::Offset<meshDataIndices>>> meshsDataIndices) {
    fbb_.AddOffset(AnimationData::VT_MESHSDATAINDICES, meshsDataIndices);
  }
  void add_startFrames(int16_t startFrames) {
    fbb_.AddElement<int16_t>(AnimationData::VT_STARTFRAMES, startFrames, 0);
  }
  void add_endFrames(int16_t endFrames) {
    fbb_.AddElement<int16_t>(AnimationData::VT_ENDFRAMES, endFrames, 0);
  }
  void add_totalFrames(int16_t totalFrames) {
    fbb_.AddElement<int16_t>(AnimationData::VT_TOTALFRAMES, totalFrames, 0);
  }
  void add_fps(int16_t fps) {
    fbb_.AddElement<int16_t>(AnimationData::VT_FPS, fps, 0);
  }
  void add_labelNum(int16_t labelNum) {
    fbb_.AddElement<int16_t>(AnimationData::VT_LABELNUM, labelNum, 0);
  }
  void add_canvasSizeW(int16_t canvasSizeW) {
    fbb_.AddElement<int16_t>(AnimationData::VT_CANVASSIZEW, canvasSizeW, 0);
  }
  void add_canvasSizeH(int16_t canvasSizeH) {
    fbb_.AddElement<int16_t>(AnimationData::VT_CANVASSIZEH, canvasSizeH, 0);
  }
  void add_canvasPvotX(float canvasPvotX) {
    fbb_.AddElement<float>(AnimationData::VT_CANVASPVOTX, canvasPvotX, 0.0f);
  }
  void add_canvasPvotY(float canvasPvotY) {
    fbb_.AddElement<float>(AnimationData::VT_CANVASPVOTY, canvasPvotY, 0.0f);
  }
  explicit AnimationDataBuilder(flatbuffers::FlatBufferBuilder &_fbb)
        : fbb_(_fbb) {
    start_ = fbb_.StartTable();
  }
  AnimationDataBuilder &operator=(const AnimationDataBuilder &);
  flatbuffers::Offset<AnimationData> Finish() {
    const auto end = fbb_.EndTable(start_);
    auto o = flatbuffers::Offset<AnimationData>(end);
    return o;
  }
};

inline flatbuffers::Offset<AnimationData> CreateAnimationData(
    flatbuffers::FlatBufferBuilder &_fbb,
    flatbuffers::Offset<flatbuffers::String> name = 0,
    flatbuffers::Offset<flatbuffers::Vector<flatbuffers::Offset<AnimationInitialData>>> defaultData = 0,
    flatbuffers::Offset<flatbuffers::Vector<flatbuffers::Offset<frameDataIndex>>> frameData = 0,
    flatbuffers::Offset<flatbuffers::Vector<flatbuffers::Offset<userDataPerFrame>>> userData = 0,
    flatbuffers::Offset<flatbuffers::Vector<flatbuffers::Offset<labelDataItem>>> labelData = 0,
    flatbuffers::Offset<flatbuffers::Vector<uint8_t>> meshsDataUV_type = 0,
    flatbuffers::Offset<flatbuffers::Vector<flatbuffers::Offset<void>>> meshsDataUV = 0,
    flatbuffers::Offset<flatbuffers::Vector<flatbuffers::Offset<meshDataIndices>>> meshsDataIndices = 0,
    int16_t startFrames = 0,
    int16_t endFrames = 0,
    int16_t totalFrames = 0,
    int16_t fps = 0,
    int16_t labelNum = 0,
    int16_t canvasSizeW = 0,
    int16_t canvasSizeH = 0,
    float canvasPvotX = 0.0f,
    float canvasPvotY = 0.0f) {
  AnimationDataBuilder builder_(_fbb);
  builder_.add_canvasPvotY(canvasPvotY);
  builder_.add_canvasPvotX(canvasPvotX);
  builder_.add_meshsDataIndices(meshsDataIndices);
  builder_.add_meshsDataUV(meshsDataUV);
  builder_.add_meshsDataUV_type(meshsDataUV_type);
  builder_.add_labelData(labelData);
  builder_.add_userData(userData);
  builder_.add_frameData(frameData);
  builder_.add_defaultData(defaultData);
  builder_.add_name(name);
  builder_.add_canvasSizeH(canvasSizeH);
  builder_.add_canvasSizeW(canvasSizeW);
  builder_.add_labelNum(labelNum);
  builder_.add_fps(fps);
  builder_.add_totalFrames(totalFrames);
  builder_.add_endFrames(endFrames);
  builder_.add_startFrames(startFrames);
  return builder_.Finish();
}

inline flatbuffers::Offset<AnimationData> CreateAnimationDataDirect(
    flatbuffers::FlatBufferBuilder &_fbb,
    const char *name = nullptr,
    const std::vector<flatbuffers::Offset<AnimationInitialData>> *defaultData = nullptr,
    const std::vector<flatbuffers::Offset<frameDataIndex>> *frameData = nullptr,
    const std::vector<flatbuffers::Offset<userDataPerFrame>> *userData = nullptr,
    const std::vector<flatbuffers::Offset<labelDataItem>> *labelData = nullptr,
    const std::vector<uint8_t> *meshsDataUV_type = nullptr,
    const std::vector<flatbuffers::Offset<void>> *meshsDataUV = nullptr,
    const std::vector<flatbuffers::Offset<meshDataIndices>> *meshsDataIndices = nullptr,
    int16_t startFrames = 0,
    int16_t endFrames = 0,
    int16_t totalFrames = 0,
    int16_t fps = 0,
    int16_t labelNum = 0,
    int16_t canvasSizeW = 0,
    int16_t canvasSizeH = 0,
    float canvasPvotX = 0.0f,
    float canvasPvotY = 0.0f) {
  return ss::ssfb::CreateAnimationData(
      _fbb,
      name ? _fbb.CreateString(name) : 0,
      defaultData ? _fbb.CreateVector<flatbuffers::Offset<AnimationInitialData>>(*defaultData) : 0,
      frameData ? _fbb.CreateVector<flatbuffers::Offset<frameDataIndex>>(*frameData) : 0,
      userData ? _fbb.CreateVector<flatbuffers::Offset<userDataPerFrame>>(*userData) : 0,
      labelData ? _fbb.CreateVector<flatbuffers::Offset<labelDataItem>>(*labelData) : 0,
      meshsDataUV_type ? _fbb.CreateVector<uint8_t>(*meshsDataUV_type) : 0,
      meshsDataUV ? _fbb.CreateVector<flatbuffers::Offset<void>>(*meshsDataUV) : 0,
      meshsDataIndices ? _fbb.CreateVector<flatbuffers::Offset<meshDataIndices>>(*meshsDataIndices) : 0,
      startFrames,
      endFrames,
      totalFrames,
      fps,
      labelNum,
      canvasSizeW,
      canvasSizeH,
      canvasPvotX,
      canvasPvotY);
}

struct AnimationInitialData FLATBUFFERS_FINAL_CLASS : private flatbuffers::Table {
  enum {
    VT_INDEX = 4,
    VT_LOWFLAG = 6,
    VT_HIGHFLAG = 8,
    VT_PRIORITY = 10,
    VT_CELLINDEX = 12,
    VT_OPACITY = 14,
    VT_LOCALOPACITY = 16,
    VT_MASKLIMEN = 18,
    VT_POSITIONX = 20,
    VT_POSITIONY = 22,
    VT_POSITIONZ = 24,
    VT_PIVOTX = 26,
    VT_PIVOTY = 28,
    VT_ROTATIONX = 30,
    VT_ROTATIONY = 32,
    VT_ROTATIONZ = 34,
    VT_SCALEX = 36,
    VT_SCALEY = 38,
    VT_LOCALSCALEX = 40,
    VT_LOCALSCALEY = 42,
    VT_SIZE_X = 44,
    VT_SIZE_Y = 46,
    VT_UV_MOVE_X = 48,
    VT_UV_MOVE_Y = 50,
    VT_UV_ROTATION = 52,
    VT_UV_SCALE_X = 54,
    VT_UV_SCALE_Y = 56,
    VT_BOUNDINGRADIUS = 58,
    VT_INSTANCEVALUE_CURKEYFRAME = 60,
    VT_INSTANCEVALUE_STARTFRAME = 62,
    VT_INSTANCEVALUE_ENDFRAME = 64,
    VT_INSTANCEVALUE_LOOPNUM = 66,
    VT_INSTANCEVALUE_SPEED = 68,
    VT_INSTANCEVALUE_LOOPFLAG = 70,
    VT_EFFECTVALUE_CURKEYFRAME = 72,
    VT_EFFECTVALUE_STARTTIME = 74,
    VT_EFFECTVALUE_SPEED = 76,
    VT_EFFECTVALUE_LOOPFLAG = 78
  };
  int16_t index() const {
    return GetField<int16_t>(VT_INDEX, 0);
  }
  int32_t lowflag() const {
    return GetField<int32_t>(VT_LOWFLAG, 0);
  }
  int32_t highflag() const {
    return GetField<int32_t>(VT_HIGHFLAG, 0);
  }
  int16_t priority() const {
    return GetField<int16_t>(VT_PRIORITY, 0);
  }
  int16_t cellIndex() const {
    return GetField<int16_t>(VT_CELLINDEX, 0);
  }
  int16_t opacity() const {
    return GetField<int16_t>(VT_OPACITY, 0);
  }
  int16_t localopacity() const {
    return GetField<int16_t>(VT_LOCALOPACITY, 0);
  }
  int16_t masklimen() const {
    return GetField<int16_t>(VT_MASKLIMEN, 0);
  }
  float positionX() const {
    return GetField<float>(VT_POSITIONX, 0.0f);
  }
  float positionY() const {
    return GetField<float>(VT_POSITIONY, 0.0f);
  }
  float positionZ() const {
    return GetField<float>(VT_POSITIONZ, 0.0f);
  }
  float pivotX() const {
    return GetField<float>(VT_PIVOTX, 0.0f);
  }
  float pivotY() const {
    return GetField<float>(VT_PIVOTY, 0.0f);
  }
  float rotationX() const {
    return GetField<float>(VT_ROTATIONX, 0.0f);
  }
  float rotationY() const {
    return GetField<float>(VT_ROTATIONY, 0.0f);
  }
  float rotationZ() const {
    return GetField<float>(VT_ROTATIONZ, 0.0f);
  }
  float scaleX() const {
    return GetField<float>(VT_SCALEX, 0.0f);
  }
  float scaleY() const {
    return GetField<float>(VT_SCALEY, 0.0f);
  }
  float localscaleX() const {
    return GetField<float>(VT_LOCALSCALEX, 0.0f);
  }
  float localscaleY() const {
    return GetField<float>(VT_LOCALSCALEY, 0.0f);
  }
  float size_X() const {
    return GetField<float>(VT_SIZE_X, 0.0f);
  }
  float size_Y() const {
    return GetField<float>(VT_SIZE_Y, 0.0f);
  }
  float uv_move_X() const {
    return GetField<float>(VT_UV_MOVE_X, 0.0f);
  }
  float uv_move_Y() const {
    return GetField<float>(VT_UV_MOVE_Y, 0.0f);
  }
  float uv_rotation() const {
    return GetField<float>(VT_UV_ROTATION, 0.0f);
  }
  float uv_scale_X() const {
    return GetField<float>(VT_UV_SCALE_X, 0.0f);
  }
  float uv_scale_Y() const {
    return GetField<float>(VT_UV_SCALE_Y, 0.0f);
  }
  float boundingRadius() const {
    return GetField<float>(VT_BOUNDINGRADIUS, 0.0f);
  }
  int32_t instanceValue_curKeyframe() const {
    return GetField<int32_t>(VT_INSTANCEVALUE_CURKEYFRAME, 0);
  }
  int32_t instanceValue_startFrame() const {
    return GetField<int32_t>(VT_INSTANCEVALUE_STARTFRAME, 0);
  }
  int32_t instanceValue_endFrame() const {
    return GetField<int32_t>(VT_INSTANCEVALUE_ENDFRAME, 0);
  }
  int32_t instanceValue_loopNum() const {
    return GetField<int32_t>(VT_INSTANCEVALUE_LOOPNUM, 0);
  }
  float instanceValue_speed() const {
    return GetField<float>(VT_INSTANCEVALUE_SPEED, 0.0f);
  }
  int32_t instanceValue_loopflag() const {
    return GetField<int32_t>(VT_INSTANCEVALUE_LOOPFLAG, 0);
  }
  int32_t effectValue_curKeyframe() const {
    return GetField<int32_t>(VT_EFFECTVALUE_CURKEYFRAME, 0);
  }
  int32_t effectValue_startTime() const {
    return GetField<int32_t>(VT_EFFECTVALUE_STARTTIME, 0);
  }
  float effectValue_speed() const {
    return GetField<float>(VT_EFFECTVALUE_SPEED, 0.0f);
  }
  int32_t effectValue_loopflag() const {
    return GetField<int32_t>(VT_EFFECTVALUE_LOOPFLAG, 0);
  }
  bool Verify(flatbuffers::Verifier &verifier) const {
    return VerifyTableStart(verifier) &&
           VerifyField<int16_t>(verifier, VT_INDEX) &&
           VerifyField<int32_t>(verifier, VT_LOWFLAG) &&
           VerifyField<int32_t>(verifier, VT_HIGHFLAG) &&
           VerifyField<int16_t>(verifier, VT_PRIORITY) &&
           VerifyField<int16_t>(verifier, VT_CELLINDEX) &&
           VerifyField<int16_t>(verifier, VT_OPACITY) &&
           VerifyField<int16_t>(verifier, VT_LOCALOPACITY) &&
           VerifyField<int16_t>(verifier, VT_MASKLIMEN) &&
           VerifyField<float>(verifier, VT_POSITIONX) &&
           VerifyField<float>(verifier, VT_POSITIONY) &&
           VerifyField<float>(verifier, VT_POSITIONZ) &&
           VerifyField<float>(verifier, VT_PIVOTX) &&
           VerifyField<float>(verifier, VT_PIVOTY) &&
           VerifyField<float>(verifier, VT_ROTATIONX) &&
           VerifyField<float>(verifier, VT_ROTATIONY) &&
           VerifyField<float>(verifier, VT_ROTATIONZ) &&
           VerifyField<float>(verifier, VT_SCALEX) &&
           VerifyField<float>(verifier, VT_SCALEY) &&
           VerifyField<float>(verifier, VT_LOCALSCALEX) &&
           VerifyField<float>(verifier, VT_LOCALSCALEY) &&
           VerifyField<float>(verifier, VT_SIZE_X) &&
           VerifyField<float>(verifier, VT_SIZE_Y) &&
           VerifyField<float>(verifier, VT_UV_MOVE_X) &&
           VerifyField<float>(verifier, VT_UV_MOVE_Y) &&
           VerifyField<float>(verifier, VT_UV_ROTATION) &&
           VerifyField<float>(verifier, VT_UV_SCALE_X) &&
           VerifyField<float>(verifier, VT_UV_SCALE_Y) &&
           VerifyField<float>(verifier, VT_BOUNDINGRADIUS) &&
           VerifyField<int32_t>(verifier, VT_INSTANCEVALUE_CURKEYFRAME) &&
           VerifyField<int32_t>(verifier, VT_INSTANCEVALUE_STARTFRAME) &&
           VerifyField<int32_t>(verifier, VT_INSTANCEVALUE_ENDFRAME) &&
           VerifyField<int32_t>(verifier, VT_INSTANCEVALUE_LOOPNUM) &&
           VerifyField<float>(verifier, VT_INSTANCEVALUE_SPEED) &&
           VerifyField<int32_t>(verifier, VT_INSTANCEVALUE_LOOPFLAG) &&
           VerifyField<int32_t>(verifier, VT_EFFECTVALUE_CURKEYFRAME) &&
           VerifyField<int32_t>(verifier, VT_EFFECTVALUE_STARTTIME) &&
           VerifyField<float>(verifier, VT_EFFECTVALUE_SPEED) &&
           VerifyField<int32_t>(verifier, VT_EFFECTVALUE_LOOPFLAG) &&
           verifier.EndTable();
  }
};

struct AnimationInitialDataBuilder {
  flatbuffers::FlatBufferBuilder &fbb_;
  flatbuffers::uoffset_t start_;
  void add_index(int16_t index) {
    fbb_.AddElement<int16_t>(AnimationInitialData::VT_INDEX, index, 0);
  }
  void add_lowflag(int32_t lowflag) {
    fbb_.AddElement<int32_t>(AnimationInitialData::VT_LOWFLAG, lowflag, 0);
  }
  void add_highflag(int32_t highflag) {
    fbb_.AddElement<int32_t>(AnimationInitialData::VT_HIGHFLAG, highflag, 0);
  }
  void add_priority(int16_t priority) {
    fbb_.AddElement<int16_t>(AnimationInitialData::VT_PRIORITY, priority, 0);
  }
  void add_cellIndex(int16_t cellIndex) {
    fbb_.AddElement<int16_t>(AnimationInitialData::VT_CELLINDEX, cellIndex, 0);
  }
  void add_opacity(int16_t opacity) {
    fbb_.AddElement<int16_t>(AnimationInitialData::VT_OPACITY, opacity, 0);
  }
  void add_localopacity(int16_t localopacity) {
    fbb_.AddElement<int16_t>(AnimationInitialData::VT_LOCALOPACITY, localopacity, 0);
  }
  void add_masklimen(int16_t masklimen) {
    fbb_.AddElement<int16_t>(AnimationInitialData::VT_MASKLIMEN, masklimen, 0);
  }
  void add_positionX(float positionX) {
    fbb_.AddElement<float>(AnimationInitialData::VT_POSITIONX, positionX, 0.0f);
  }
  void add_positionY(float positionY) {
    fbb_.AddElement<float>(AnimationInitialData::VT_POSITIONY, positionY, 0.0f);
  }
  void add_positionZ(float positionZ) {
    fbb_.AddElement<float>(AnimationInitialData::VT_POSITIONZ, positionZ, 0.0f);
  }
  void add_pivotX(float pivotX) {
    fbb_.AddElement<float>(AnimationInitialData::VT_PIVOTX, pivotX, 0.0f);
  }
  void add_pivotY(float pivotY) {
    fbb_.AddElement<float>(AnimationInitialData::VT_PIVOTY, pivotY, 0.0f);
  }
  void add_rotationX(float rotationX) {
    fbb_.AddElement<float>(AnimationInitialData::VT_ROTATIONX, rotationX, 0.0f);
  }
  void add_rotationY(float rotationY) {
    fbb_.AddElement<float>(AnimationInitialData::VT_ROTATIONY, rotationY, 0.0f);
  }
  void add_rotationZ(float rotationZ) {
    fbb_.AddElement<float>(AnimationInitialData::VT_ROTATIONZ, rotationZ, 0.0f);
  }
  void add_scaleX(float scaleX) {
    fbb_.AddElement<float>(AnimationInitialData::VT_SCALEX, scaleX, 0.0f);
  }
  void add_scaleY(float scaleY) {
    fbb_.AddElement<float>(AnimationInitialData::VT_SCALEY, scaleY, 0.0f);
  }
  void add_localscaleX(float localscaleX) {
    fbb_.AddElement<float>(AnimationInitialData::VT_LOCALSCALEX, localscaleX, 0.0f);
  }
  void add_localscaleY(float localscaleY) {
    fbb_.AddElement<float>(AnimationInitialData::VT_LOCALSCALEY, localscaleY, 0.0f);
  }
  void add_size_X(float size_X) {
    fbb_.AddElement<float>(AnimationInitialData::VT_SIZE_X, size_X, 0.0f);
  }
  void add_size_Y(float size_Y) {
    fbb_.AddElement<float>(AnimationInitialData::VT_SIZE_Y, size_Y, 0.0f);
  }
  void add_uv_move_X(float uv_move_X) {
    fbb_.AddElement<float>(AnimationInitialData::VT_UV_MOVE_X, uv_move_X, 0.0f);
  }
  void add_uv_move_Y(float uv_move_Y) {
    fbb_.AddElement<float>(AnimationInitialData::VT_UV_MOVE_Y, uv_move_Y, 0.0f);
  }
  void add_uv_rotation(float uv_rotation) {
    fbb_.AddElement<float>(AnimationInitialData::VT_UV_ROTATION, uv_rotation, 0.0f);
  }
  void add_uv_scale_X(float uv_scale_X) {
    fbb_.AddElement<float>(AnimationInitialData::VT_UV_SCALE_X, uv_scale_X, 0.0f);
  }
  void add_uv_scale_Y(float uv_scale_Y) {
    fbb_.AddElement<float>(AnimationInitialData::VT_UV_SCALE_Y, uv_scale_Y, 0.0f);
  }
  void add_boundingRadius(float boundingRadius) {
    fbb_.AddElement<float>(AnimationInitialData::VT_BOUNDINGRADIUS, boundingRadius, 0.0f);
  }
  void add_instanceValue_curKeyframe(int32_t instanceValue_curKeyframe) {
    fbb_.AddElement<int32_t>(AnimationInitialData::VT_INSTANCEVALUE_CURKEYFRAME, instanceValue_curKeyframe, 0);
  }
  void add_instanceValue_startFrame(int32_t instanceValue_startFrame) {
    fbb_.AddElement<int32_t>(AnimationInitialData::VT_INSTANCEVALUE_STARTFRAME, instanceValue_startFrame, 0);
  }
  void add_instanceValue_endFrame(int32_t instanceValue_endFrame) {
    fbb_.AddElement<int32_t>(AnimationInitialData::VT_INSTANCEVALUE_ENDFRAME, instanceValue_endFrame, 0);
  }
  void add_instanceValue_loopNum(int32_t instanceValue_loopNum) {
    fbb_.AddElement<int32_t>(AnimationInitialData::VT_INSTANCEVALUE_LOOPNUM, instanceValue_loopNum, 0);
  }
  void add_instanceValue_speed(float instanceValue_speed) {
    fbb_.AddElement<float>(AnimationInitialData::VT_INSTANCEVALUE_SPEED, instanceValue_speed, 0.0f);
  }
  void add_instanceValue_loopflag(int32_t instanceValue_loopflag) {
    fbb_.AddElement<int32_t>(AnimationInitialData::VT_INSTANCEVALUE_LOOPFLAG, instanceValue_loopflag, 0);
  }
  void add_effectValue_curKeyframe(int32_t effectValue_curKeyframe) {
    fbb_.AddElement<int32_t>(AnimationInitialData::VT_EFFECTVALUE_CURKEYFRAME, effectValue_curKeyframe, 0);
  }
  void add_effectValue_startTime(int32_t effectValue_startTime) {
    fbb_.AddElement<int32_t>(AnimationInitialData::VT_EFFECTVALUE_STARTTIME, effectValue_startTime, 0);
  }
  void add_effectValue_speed(float effectValue_speed) {
    fbb_.AddElement<float>(AnimationInitialData::VT_EFFECTVALUE_SPEED, effectValue_speed, 0.0f);
  }
  void add_effectValue_loopflag(int32_t effectValue_loopflag) {
    fbb_.AddElement<int32_t>(AnimationInitialData::VT_EFFECTVALUE_LOOPFLAG, effectValue_loopflag, 0);
  }
  explicit AnimationInitialDataBuilder(flatbuffers::FlatBufferBuilder &_fbb)
        : fbb_(_fbb) {
    start_ = fbb_.StartTable();
  }
  AnimationInitialDataBuilder &operator=(const AnimationInitialDataBuilder &);
  flatbuffers::Offset<AnimationInitialData> Finish() {
    const auto end = fbb_.EndTable(start_);
    auto o = flatbuffers::Offset<AnimationInitialData>(end);
    return o;
  }
};

inline flatbuffers::Offset<AnimationInitialData> CreateAnimationInitialData(
    flatbuffers::FlatBufferBuilder &_fbb,
    int16_t index = 0,
    int32_t lowflag = 0,
    int32_t highflag = 0,
    int16_t priority = 0,
    int16_t cellIndex = 0,
    int16_t opacity = 0,
    int16_t localopacity = 0,
    int16_t masklimen = 0,
    float positionX = 0.0f,
    float positionY = 0.0f,
    float positionZ = 0.0f,
    float pivotX = 0.0f,
    float pivotY = 0.0f,
    float rotationX = 0.0f,
    float rotationY = 0.0f,
    float rotationZ = 0.0f,
    float scaleX = 0.0f,
    float scaleY = 0.0f,
    float localscaleX = 0.0f,
    float localscaleY = 0.0f,
    float size_X = 0.0f,
    float size_Y = 0.0f,
    float uv_move_X = 0.0f,
    float uv_move_Y = 0.0f,
    float uv_rotation = 0.0f,
    float uv_scale_X = 0.0f,
    float uv_scale_Y = 0.0f,
    float boundingRadius = 0.0f,
    int32_t instanceValue_curKeyframe = 0,
    int32_t instanceValue_startFrame = 0,
    int32_t instanceValue_endFrame = 0,
    int32_t instanceValue_loopNum = 0,
    float instanceValue_speed = 0.0f,
    int32_t instanceValue_loopflag = 0,
    int32_t effectValue_curKeyframe = 0,
    int32_t effectValue_startTime = 0,
    float effectValue_speed = 0.0f,
    int32_t effectValue_loopflag = 0) {
  AnimationInitialDataBuilder builder_(_fbb);
  builder_.add_effectValue_loopflag(effectValue_loopflag);
  builder_.add_effectValue_speed(effectValue_speed);
  builder_.add_effectValue_startTime(effectValue_startTime);
  builder_.add_effectValue_curKeyframe(effectValue_curKeyframe);
  builder_.add_instanceValue_loopflag(instanceValue_loopflag);
  builder_.add_instanceValue_speed(instanceValue_speed);
  builder_.add_instanceValue_loopNum(instanceValue_loopNum);
  builder_.add_instanceValue_endFrame(instanceValue_endFrame);
  builder_.add_instanceValue_startFrame(instanceValue_startFrame);
  builder_.add_instanceValue_curKeyframe(instanceValue_curKeyframe);
  builder_.add_boundingRadius(boundingRadius);
  builder_.add_uv_scale_Y(uv_scale_Y);
  builder_.add_uv_scale_X(uv_scale_X);
  builder_.add_uv_rotation(uv_rotation);
  builder_.add_uv_move_Y(uv_move_Y);
  builder_.add_uv_move_X(uv_move_X);
  builder_.add_size_Y(size_Y);
  builder_.add_size_X(size_X);
  builder_.add_localscaleY(localscaleY);
  builder_.add_localscaleX(localscaleX);
  builder_.add_scaleY(scaleY);
  builder_.add_scaleX(scaleX);
  builder_.add_rotationZ(rotationZ);
  builder_.add_rotationY(rotationY);
  builder_.add_rotationX(rotationX);
  builder_.add_pivotY(pivotY);
  builder_.add_pivotX(pivotX);
  builder_.add_positionZ(positionZ);
  builder_.add_positionY(positionY);
  builder_.add_positionX(positionX);
  builder_.add_highflag(highflag);
  builder_.add_lowflag(lowflag);
  builder_.add_masklimen(masklimen);
  builder_.add_localopacity(localopacity);
  builder_.add_opacity(opacity);
  builder_.add_cellIndex(cellIndex);
  builder_.add_priority(priority);
  builder_.add_index(index);
  return builder_.Finish();
}

struct PartData FLATBUFFERS_FINAL_CLASS : private flatbuffers::Table {
  enum {
    VT_NAME = 4,
    VT_INDEX = 6,
    VT_PARENTINDEX = 8,
    VT_TYPE = 10,
    VT_BOUNDSTYPE = 12,
    VT_ALPHABLENDTYPE = 14,
    VT_REFNAME = 16,
    VT_EFFECTFILENAME = 18,
    VT_COLORLABEL = 20,
    VT_MASKINFLUENCE = 22
  };
  const flatbuffers::String *name() const {
    return GetPointer<const flatbuffers::String *>(VT_NAME);
  }
  int16_t index() const {
    return GetField<int16_t>(VT_INDEX, 0);
  }
  int16_t parentIndex() const {
    return GetField<int16_t>(VT_PARENTINDEX, 0);
  }
  SsPartType type() const {
    return static_cast<SsPartType>(GetField<int8_t>(VT_TYPE, 0));
  }
  int16_t boundsType() const {
    return GetField<int16_t>(VT_BOUNDSTYPE, 0);
  }
  int16_t alphaBlendType() const {
    return GetField<int16_t>(VT_ALPHABLENDTYPE, 0);
  }
  const flatbuffers::String *refname() const {
    return GetPointer<const flatbuffers::String *>(VT_REFNAME);
  }
  const flatbuffers::String *effectfilename() const {
    return GetPointer<const flatbuffers::String *>(VT_EFFECTFILENAME);
  }
  const flatbuffers::String *colorLabel() const {
    return GetPointer<const flatbuffers::String *>(VT_COLORLABEL);
  }
  int16_t maskInfluence() const {
    return GetField<int16_t>(VT_MASKINFLUENCE, 0);
  }
  bool Verify(flatbuffers::Verifier &verifier) const {
    return VerifyTableStart(verifier) &&
           VerifyOffset(verifier, VT_NAME) &&
           verifier.Verify(name()) &&
           VerifyField<int16_t>(verifier, VT_INDEX) &&
           VerifyField<int16_t>(verifier, VT_PARENTINDEX) &&
           VerifyField<int8_t>(verifier, VT_TYPE) &&
           VerifyField<int16_t>(verifier, VT_BOUNDSTYPE) &&
           VerifyField<int16_t>(verifier, VT_ALPHABLENDTYPE) &&
           VerifyOffset(verifier, VT_REFNAME) &&
           verifier.Verify(refname()) &&
           VerifyOffset(verifier, VT_EFFECTFILENAME) &&
           verifier.Verify(effectfilename()) &&
           VerifyOffset(verifier, VT_COLORLABEL) &&
           verifier.Verify(colorLabel()) &&
           VerifyField<int16_t>(verifier, VT_MASKINFLUENCE) &&
           verifier.EndTable();
  }
};

struct PartDataBuilder {
  flatbuffers::FlatBufferBuilder &fbb_;
  flatbuffers::uoffset_t start_;
  void add_name(flatbuffers::Offset<flatbuffers::String> name) {
    fbb_.AddOffset(PartData::VT_NAME, name);
  }
  void add_index(int16_t index) {
    fbb_.AddElement<int16_t>(PartData::VT_INDEX, index, 0);
  }
  void add_parentIndex(int16_t parentIndex) {
    fbb_.AddElement<int16_t>(PartData::VT_PARENTINDEX, parentIndex, 0);
  }
  void add_type(SsPartType type) {
    fbb_.AddElement<int8_t>(PartData::VT_TYPE, static_cast<int8_t>(type), 0);
  }
  void add_boundsType(int16_t boundsType) {
    fbb_.AddElement<int16_t>(PartData::VT_BOUNDSTYPE, boundsType, 0);
  }
  void add_alphaBlendType(int16_t alphaBlendType) {
    fbb_.AddElement<int16_t>(PartData::VT_ALPHABLENDTYPE, alphaBlendType, 0);
  }
  void add_refname(flatbuffers::Offset<flatbuffers::String> refname) {
    fbb_.AddOffset(PartData::VT_REFNAME, refname);
  }
  void add_effectfilename(flatbuffers::Offset<flatbuffers::String> effectfilename) {
    fbb_.AddOffset(PartData::VT_EFFECTFILENAME, effectfilename);
  }
  void add_colorLabel(flatbuffers::Offset<flatbuffers::String> colorLabel) {
    fbb_.AddOffset(PartData::VT_COLORLABEL, colorLabel);
  }
  void add_maskInfluence(int16_t maskInfluence) {
    fbb_.AddElement<int16_t>(PartData::VT_MASKINFLUENCE, maskInfluence, 0);
  }
  explicit PartDataBuilder(flatbuffers::FlatBufferBuilder &_fbb)
        : fbb_(_fbb) {
    start_ = fbb_.StartTable();
  }
  PartDataBuilder &operator=(const PartDataBuilder &);
  flatbuffers::Offset<PartData> Finish() {
    const auto end = fbb_.EndTable(start_);
    auto o = flatbuffers::Offset<PartData>(end);
    return o;
  }
};

inline flatbuffers::Offset<PartData> CreatePartData(
    flatbuffers::FlatBufferBuilder &_fbb,
    flatbuffers::Offset<flatbuffers::String> name = 0,
    int16_t index = 0,
    int16_t parentIndex = 0,
    SsPartType type = SsPartType_Nulltype,
    int16_t boundsType = 0,
    int16_t alphaBlendType = 0,
    flatbuffers::Offset<flatbuffers::String> refname = 0,
    flatbuffers::Offset<flatbuffers::String> effectfilename = 0,
    flatbuffers::Offset<flatbuffers::String> colorLabel = 0,
    int16_t maskInfluence = 0) {
  PartDataBuilder builder_(_fbb);
  builder_.add_colorLabel(colorLabel);
  builder_.add_effectfilename(effectfilename);
  builder_.add_refname(refname);
  builder_.add_name(name);
  builder_.add_maskInfluence(maskInfluence);
  builder_.add_alphaBlendType(alphaBlendType);
  builder_.add_boundsType(boundsType);
  builder_.add_parentIndex(parentIndex);
  builder_.add_index(index);
  builder_.add_type(type);
  return builder_.Finish();
}

inline flatbuffers::Offset<PartData> CreatePartDataDirect(
    flatbuffers::FlatBufferBuilder &_fbb,
    const char *name = nullptr,
    int16_t index = 0,
    int16_t parentIndex = 0,
    SsPartType type = SsPartType_Nulltype,
    int16_t boundsType = 0,
    int16_t alphaBlendType = 0,
    const char *refname = nullptr,
    const char *effectfilename = nullptr,
    const char *colorLabel = nullptr,
    int16_t maskInfluence = 0) {
  return ss::ssfb::CreatePartData(
      _fbb,
      name ? _fbb.CreateString(name) : 0,
      index,
      parentIndex,
      type,
      boundsType,
      alphaBlendType,
      refname ? _fbb.CreateString(refname) : 0,
      effectfilename ? _fbb.CreateString(effectfilename) : 0,
      colorLabel ? _fbb.CreateString(colorLabel) : 0,
      maskInfluence);
}

struct AnimePackData FLATBUFFERS_FINAL_CLASS : private flatbuffers::Table {
  enum {
    VT_NAME = 4,
    VT_PARTS = 6,
    VT_ANIMATIONS = 8
  };
  const flatbuffers::String *name() const {
    return GetPointer<const flatbuffers::String *>(VT_NAME);
  }
  const flatbuffers::Vector<flatbuffers::Offset<PartData>> *parts() const {
    return GetPointer<const flatbuffers::Vector<flatbuffers::Offset<PartData>> *>(VT_PARTS);
  }
  const flatbuffers::Vector<flatbuffers::Offset<AnimationData>> *animations() const {
    return GetPointer<const flatbuffers::Vector<flatbuffers::Offset<AnimationData>> *>(VT_ANIMATIONS);
  }
  bool Verify(flatbuffers::Verifier &verifier) const {
    return VerifyTableStart(verifier) &&
           VerifyOffset(verifier, VT_NAME) &&
           verifier.Verify(name()) &&
           VerifyOffset(verifier, VT_PARTS) &&
           verifier.Verify(parts()) &&
           verifier.VerifyVectorOfTables(parts()) &&
           VerifyOffset(verifier, VT_ANIMATIONS) &&
           verifier.Verify(animations()) &&
           verifier.VerifyVectorOfTables(animations()) &&
           verifier.EndTable();
  }
};

struct AnimePackDataBuilder {
  flatbuffers::FlatBufferBuilder &fbb_;
  flatbuffers::uoffset_t start_;
  void add_name(flatbuffers::Offset<flatbuffers::String> name) {
    fbb_.AddOffset(AnimePackData::VT_NAME, name);
  }
  void add_parts(flatbuffers::Offset<flatbuffers::Vector<flatbuffers::Offset<PartData>>> parts) {
    fbb_.AddOffset(AnimePackData::VT_PARTS, parts);
  }
  void add_animations(flatbuffers::Offset<flatbuffers::Vector<flatbuffers::Offset<AnimationData>>> animations) {
    fbb_.AddOffset(AnimePackData::VT_ANIMATIONS, animations);
  }
  explicit AnimePackDataBuilder(flatbuffers::FlatBufferBuilder &_fbb)
        : fbb_(_fbb) {
    start_ = fbb_.StartTable();
  }
  AnimePackDataBuilder &operator=(const AnimePackDataBuilder &);
  flatbuffers::Offset<AnimePackData> Finish() {
    const auto end = fbb_.EndTable(start_);
    auto o = flatbuffers::Offset<AnimePackData>(end);
    return o;
  }
};

inline flatbuffers::Offset<AnimePackData> CreateAnimePackData(
    flatbuffers::FlatBufferBuilder &_fbb,
    flatbuffers::Offset<flatbuffers::String> name = 0,
    flatbuffers::Offset<flatbuffers::Vector<flatbuffers::Offset<PartData>>> parts = 0,
    flatbuffers::Offset<flatbuffers::Vector<flatbuffers::Offset<AnimationData>>> animations = 0) {
  AnimePackDataBuilder builder_(_fbb);
  builder_.add_animations(animations);
  builder_.add_parts(parts);
  builder_.add_name(name);
  return builder_.Finish();
}

inline flatbuffers::Offset<AnimePackData> CreateAnimePackDataDirect(
    flatbuffers::FlatBufferBuilder &_fbb,
    const char *name = nullptr,
    const std::vector<flatbuffers::Offset<PartData>> *parts = nullptr,
    const std::vector<flatbuffers::Offset<AnimationData>> *animations = nullptr) {
  return ss::ssfb::CreateAnimePackData(
      _fbb,
      name ? _fbb.CreateString(name) : 0,
      parts ? _fbb.CreateVector<flatbuffers::Offset<PartData>>(*parts) : 0,
      animations ? _fbb.CreateVector<flatbuffers::Offset<AnimationData>>(*animations) : 0);
}

struct ProjectData FLATBUFFERS_FINAL_CLASS : private flatbuffers::Table {
  enum {
    VT_DATAID = 4,
    VT_VERSION = 6,
    VT_FLAGS = 8,
    VT_IMAGEBASEDIR = 10,
    VT_CELLS = 12,
    VT_ANIMEPACKS = 14,
    VT_EFFECTFILELIST = 16,
    VT_NUMCELLS = 18,
    VT_NUMANIMEPACKS = 20,
    VT_NUMEFFECTFILELIST = 22
  };
  uint32_t dataId() const {
    return GetField<uint32_t>(VT_DATAID, 0);
  }
  uint32_t version() const {
    return GetField<uint32_t>(VT_VERSION, 0);
  }
  uint32_t flags() const {
    return GetField<uint32_t>(VT_FLAGS, 0);
  }
  const flatbuffers::String *imageBaseDir() const {
    return GetPointer<const flatbuffers::String *>(VT_IMAGEBASEDIR);
  }
  const flatbuffers::Vector<flatbuffers::Offset<Cell>> *cells() const {
    return GetPointer<const flatbuffers::Vector<flatbuffers::Offset<Cell>> *>(VT_CELLS);
  }
  const flatbuffers::Vector<flatbuffers::Offset<AnimePackData>> *animePacks() const {
    return GetPointer<const flatbuffers::Vector<flatbuffers::Offset<AnimePackData>> *>(VT_ANIMEPACKS);
  }
  const flatbuffers::Vector<flatbuffers::Offset<EffectFile>> *effectFileList() const {
    return GetPointer<const flatbuffers::Vector<flatbuffers::Offset<EffectFile>> *>(VT_EFFECTFILELIST);
  }
  int16_t numCells() const {
    return GetField<int16_t>(VT_NUMCELLS, 0);
  }
  int16_t numAnimePacks() const {
    return GetField<int16_t>(VT_NUMANIMEPACKS, 0);
  }
  int16_t numEffectFileList() const {
    return GetField<int16_t>(VT_NUMEFFECTFILELIST, 0);
  }
  bool Verify(flatbuffers::Verifier &verifier) const {
    return VerifyTableStart(verifier) &&
           VerifyField<uint32_t>(verifier, VT_DATAID) &&
           VerifyField<uint32_t>(verifier, VT_VERSION) &&
           VerifyField<uint32_t>(verifier, VT_FLAGS) &&
           VerifyOffset(verifier, VT_IMAGEBASEDIR) &&
           verifier.Verify(imageBaseDir()) &&
           VerifyOffset(verifier, VT_CELLS) &&
           verifier.Verify(cells()) &&
           verifier.VerifyVectorOfTables(cells()) &&
           VerifyOffset(verifier, VT_ANIMEPACKS) &&
           verifier.Verify(animePacks()) &&
           verifier.VerifyVectorOfTables(animePacks()) &&
           VerifyOffset(verifier, VT_EFFECTFILELIST) &&
           verifier.Verify(effectFileList()) &&
           verifier.VerifyVectorOfTables(effectFileList()) &&
           VerifyField<int16_t>(verifier, VT_NUMCELLS) &&
           VerifyField<int16_t>(verifier, VT_NUMANIMEPACKS) &&
           VerifyField<int16_t>(verifier, VT_NUMEFFECTFILELIST) &&
           verifier.EndTable();
  }
};

struct ProjectDataBuilder {
  flatbuffers::FlatBufferBuilder &fbb_;
  flatbuffers::uoffset_t start_;
  void add_dataId(uint32_t dataId) {
    fbb_.AddElement<uint32_t>(ProjectData::VT_DATAID, dataId, 0);
  }
  void add_version(uint32_t version) {
    fbb_.AddElement<uint32_t>(ProjectData::VT_VERSION, version, 0);
  }
  void add_flags(uint32_t flags) {
    fbb_.AddElement<uint32_t>(ProjectData::VT_FLAGS, flags, 0);
  }
  void add_imageBaseDir(flatbuffers::Offset<flatbuffers::String> imageBaseDir) {
    fbb_.AddOffset(ProjectData::VT_IMAGEBASEDIR, imageBaseDir);
  }
  void add_cells(flatbuffers::Offset<flatbuffers::Vector<flatbuffers::Offset<Cell>>> cells) {
    fbb_.AddOffset(ProjectData::VT_CELLS, cells);
  }
  void add_animePacks(flatbuffers::Offset<flatbuffers::Vector<flatbuffers::Offset<AnimePackData>>> animePacks) {
    fbb_.AddOffset(ProjectData::VT_ANIMEPACKS, animePacks);
  }
  void add_effectFileList(flatbuffers::Offset<flatbuffers::Vector<flatbuffers::Offset<EffectFile>>> effectFileList) {
    fbb_.AddOffset(ProjectData::VT_EFFECTFILELIST, effectFileList);
  }
  void add_numCells(int16_t numCells) {
    fbb_.AddElement<int16_t>(ProjectData::VT_NUMCELLS, numCells, 0);
  }
  void add_numAnimePacks(int16_t numAnimePacks) {
    fbb_.AddElement<int16_t>(ProjectData::VT_NUMANIMEPACKS, numAnimePacks, 0);
  }
  void add_numEffectFileList(int16_t numEffectFileList) {
    fbb_.AddElement<int16_t>(ProjectData::VT_NUMEFFECTFILELIST, numEffectFileList, 0);
  }
  explicit ProjectDataBuilder(flatbuffers::FlatBufferBuilder &_fbb)
        : fbb_(_fbb) {
    start_ = fbb_.StartTable();
  }
  ProjectDataBuilder &operator=(const ProjectDataBuilder &);
  flatbuffers::Offset<ProjectData> Finish() {
    const auto end = fbb_.EndTable(start_);
    auto o = flatbuffers::Offset<ProjectData>(end);
    return o;
  }
};

inline flatbuffers::Offset<ProjectData> CreateProjectData(
    flatbuffers::FlatBufferBuilder &_fbb,
    uint32_t dataId = 0,
    uint32_t version = 0,
    uint32_t flags = 0,
    flatbuffers::Offset<flatbuffers::String> imageBaseDir = 0,
    flatbuffers::Offset<flatbuffers::Vector<flatbuffers::Offset<Cell>>> cells = 0,
    flatbuffers::Offset<flatbuffers::Vector<flatbuffers::Offset<AnimePackData>>> animePacks = 0,
    flatbuffers::Offset<flatbuffers::Vector<flatbuffers::Offset<EffectFile>>> effectFileList = 0,
    int16_t numCells = 0,
    int16_t numAnimePacks = 0,
    int16_t numEffectFileList = 0) {
  ProjectDataBuilder builder_(_fbb);
  builder_.add_effectFileList(effectFileList);
  builder_.add_animePacks(animePacks);
  builder_.add_cells(cells);
  builder_.add_imageBaseDir(imageBaseDir);
  builder_.add_flags(flags);
  builder_.add_version(version);
  builder_.add_dataId(dataId);
  builder_.add_numEffectFileList(numEffectFileList);
  builder_.add_numAnimePacks(numAnimePacks);
  builder_.add_numCells(numCells);
  return builder_.Finish();
}

inline flatbuffers::Offset<ProjectData> CreateProjectDataDirect(
    flatbuffers::FlatBufferBuilder &_fbb,
    uint32_t dataId = 0,
    uint32_t version = 0,
    uint32_t flags = 0,
    const char *imageBaseDir = nullptr,
    const std::vector<flatbuffers::Offset<Cell>> *cells = nullptr,
    const std::vector<flatbuffers::Offset<AnimePackData>> *animePacks = nullptr,
    const std::vector<flatbuffers::Offset<EffectFile>> *effectFileList = nullptr,
    int16_t numCells = 0,
    int16_t numAnimePacks = 0,
    int16_t numEffectFileList = 0) {
  return ss::ssfb::CreateProjectData(
      _fbb,
      dataId,
      version,
      flags,
      imageBaseDir ? _fbb.CreateString(imageBaseDir) : 0,
      cells ? _fbb.CreateVector<flatbuffers::Offset<Cell>>(*cells) : 0,
      animePacks ? _fbb.CreateVector<flatbuffers::Offset<AnimePackData>>(*animePacks) : 0,
      effectFileList ? _fbb.CreateVector<flatbuffers::Offset<EffectFile>>(*effectFileList) : 0,
      numCells,
      numAnimePacks,
      numEffectFileList);
}

inline bool VerifyEffectNodeBehavior(flatbuffers::Verifier &verifier, const void *obj, EffectNodeBehavior type) {
  switch (type) {
    case EffectNodeBehavior_NONE: {
      return true;
    }
    case EffectNodeBehavior_EffectParticleElementBasic: {
      auto ptr = reinterpret_cast<const EffectParticleElementBasic *>(obj);
      return verifier.VerifyTable(ptr);
    }
    case EffectNodeBehavior_EffectParticleElementRndSeedChange: {
      auto ptr = reinterpret_cast<const EffectParticleElementRndSeedChange *>(obj);
      return verifier.VerifyTable(ptr);
    }
    case EffectNodeBehavior_EffectParticleElementDelay: {
      auto ptr = reinterpret_cast<const EffectParticleElementDelay *>(obj);
      return verifier.VerifyTable(ptr);
    }
    case EffectNodeBehavior_EffectParticleElementGravity: {
      auto ptr = reinterpret_cast<const EffectParticleElementGravity *>(obj);
      return verifier.VerifyTable(ptr);
    }
    case EffectNodeBehavior_EffectParticleElementPosition: {
      auto ptr = reinterpret_cast<const EffectParticleElementPosition *>(obj);
      return verifier.VerifyTable(ptr);
    }
    case EffectNodeBehavior_EffectParticleElementRotation: {
      auto ptr = reinterpret_cast<const EffectParticleElementRotation *>(obj);
      return verifier.VerifyTable(ptr);
    }
    case EffectNodeBehavior_EffectParticleElementRotationTrans: {
      auto ptr = reinterpret_cast<const EffectParticleElementRotationTrans *>(obj);
      return verifier.VerifyTable(ptr);
    }
    case EffectNodeBehavior_EffectParticleElementTransSpeed: {
      auto ptr = reinterpret_cast<const EffectParticleElementTransSpeed *>(obj);
      return verifier.VerifyTable(ptr);
    }
    case EffectNodeBehavior_EffectParticleElementTangentialAcceleration: {
      auto ptr = reinterpret_cast<const EffectParticleElementTangentialAcceleration *>(obj);
      return verifier.VerifyTable(ptr);
    }
    case EffectNodeBehavior_EffectParticleElementInitColor: {
      auto ptr = reinterpret_cast<const EffectParticleElementInitColor *>(obj);
      return verifier.VerifyTable(ptr);
    }
    case EffectNodeBehavior_EffectParticleElementTransColor: {
      auto ptr = reinterpret_cast<const EffectParticleElementTransColor *>(obj);
      return verifier.VerifyTable(ptr);
    }
    case EffectNodeBehavior_EffectParticleElementAlphaFade: {
      auto ptr = reinterpret_cast<const EffectParticleElementAlphaFade *>(obj);
      return verifier.VerifyTable(ptr);
    }
    case EffectNodeBehavior_EffectParticleElementSize: {
      auto ptr = reinterpret_cast<const EffectParticleElementSize *>(obj);
      return verifier.VerifyTable(ptr);
    }
    case EffectNodeBehavior_EffectParticleElementTransSize: {
      auto ptr = reinterpret_cast<const EffectParticleElementTransSize *>(obj);
      return verifier.VerifyTable(ptr);
    }
    case EffectNodeBehavior_EffectParticlePointGravity: {
      auto ptr = reinterpret_cast<const EffectParticlePointGravity *>(obj);
      return verifier.VerifyTable(ptr);
    }
    case EffectNodeBehavior_EffectParticleTurnToDirectionEnabled: {
      auto ptr = reinterpret_cast<const EffectParticleTurnToDirectionEnabled *>(obj);
      return verifier.VerifyTable(ptr);
    }
    case EffectNodeBehavior_EffectParticleInfiniteEmitEnabled: {
      auto ptr = reinterpret_cast<const EffectParticleInfiniteEmitEnabled *>(obj);
      return verifier.VerifyTable(ptr);
    }
    default: return false;
  }
}

inline bool VerifyEffectNodeBehaviorVector(flatbuffers::Verifier &verifier, const flatbuffers::Vector<flatbuffers::Offset<void>> *values, const flatbuffers::Vector<uint8_t> *types) {
  if (!values || !types) return !values && !types;
  if (values->size() != types->size()) return false;
  for (flatbuffers::uoffset_t i = 0; i < values->size(); ++i) {
    if (!VerifyEffectNodeBehavior(
        verifier,  values->Get(i), types->GetEnum<EffectNodeBehavior>(i))) {
      return false;
    }
  }
  return true;
}

inline bool VerifymeshDataUVValue(flatbuffers::Verifier &verifier, const void *obj, meshDataUVValue type) {
  switch (type) {
    case meshDataUVValue_NONE: {
      return true;
    }
    case meshDataUVValue_meshDataUVItem: {
      auto ptr = reinterpret_cast<const meshDataUVItem *>(obj);
      return verifier.VerifyTable(ptr);
    }
    case meshDataUVValue_meshDataUVEmpty: {
      auto ptr = reinterpret_cast<const meshDataUVEmpty *>(obj);
      return verifier.VerifyTable(ptr);
    }
    default: return false;
  }
}

inline bool VerifymeshDataUVValueVector(flatbuffers::Verifier &verifier, const flatbuffers::Vector<flatbuffers::Offset<void>> *values, const flatbuffers::Vector<uint8_t> *types) {
  if (!values || !types) return !values && !types;
  if (values->size() != types->size()) return false;
  for (flatbuffers::uoffset_t i = 0; i < values->size(); ++i) {
    if (!VerifymeshDataUVValue(
        verifier,  values->Get(i), types->GetEnum<meshDataUVValue>(i))) {
      return false;
    }
  }
  return true;
}

inline bool VerifyuserDataValue(flatbuffers::Verifier &verifier, const void *obj, userDataValue type) {
  switch (type) {
    case userDataValue_NONE: {
      return true;
    }
    case userDataValue_userDataInteger: {
      auto ptr = reinterpret_cast<const userDataInteger *>(obj);
      return verifier.VerifyTable(ptr);
    }
    case userDataValue_userDataRect: {
      auto ptr = reinterpret_cast<const userDataRect *>(obj);
      return verifier.VerifyTable(ptr);
    }
    case userDataValue_userDataPoint: {
      auto ptr = reinterpret_cast<const userDataPoint *>(obj);
      return verifier.VerifyTable(ptr);
    }
    case userDataValue_userDataString: {
      auto ptr = reinterpret_cast<const userDataString *>(obj);
      return verifier.VerifyTable(ptr);
    }
    default: return false;
  }
}

inline bool VerifyuserDataValueVector(flatbuffers::Verifier &verifier, const flatbuffers::Vector<flatbuffers::Offset<void>> *values, const flatbuffers::Vector<uint8_t> *types) {
  if (!values || !types) return !values && !types;
  if (values->size() != types->size()) return false;
  for (flatbuffers::uoffset_t i = 0; i < values->size(); ++i) {
    if (!VerifyuserDataValue(
        verifier,  values->Get(i), types->GetEnum<userDataValue>(i))) {
      return false;
    }
  }
  return true;
}

inline const ss::ssfb::ProjectData *GetProjectData(const void *buf) {
  return flatbuffers::GetRoot<ss::ssfb::ProjectData>(buf);
}

inline const ss::ssfb::ProjectData *GetSizePrefixedProjectData(const void *buf) {
  return flatbuffers::GetSizePrefixedRoot<ss::ssfb::ProjectData>(buf);
}

inline const char *ProjectDataIdentifier() {
  return "SSFB";
}

inline bool ProjectDataBufferHasIdentifier(const void *buf) {
  return flatbuffers::BufferHasIdentifier(
      buf, ProjectDataIdentifier());
}

inline bool VerifyProjectDataBuffer(
    flatbuffers::Verifier &verifier) {
  return verifier.VerifyBuffer<ss::ssfb::ProjectData>(ProjectDataIdentifier());
}

inline bool VerifySizePrefixedProjectDataBuffer(
    flatbuffers::Verifier &verifier) {
  return verifier.VerifySizePrefixedBuffer<ss::ssfb::ProjectData>(ProjectDataIdentifier());
}

inline void FinishProjectDataBuffer(
    flatbuffers::FlatBufferBuilder &fbb,
    flatbuffers::Offset<ss::ssfb::ProjectData> root) {
  fbb.Finish(root, ProjectDataIdentifier());
}

inline void FinishSizePrefixedProjectDataBuffer(
    flatbuffers::FlatBufferBuilder &fbb,
    flatbuffers::Offset<ss::ssfb::ProjectData> root) {
  fbb.FinishSizePrefixed(root, ProjectDataIdentifier());
}

}  // namespace ssfb
}  // namespace ss

#endif  // FLATBUFFERS_GENERATED_SSFB_SS_SSFB_H_
